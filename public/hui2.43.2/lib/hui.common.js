module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "0a57":
/***/ (function(module, exports) {

module.exports = require("hui/lib/locale");

/***/ }),

/***/ "1e79":
/***/ (function(module, exports) {

module.exports = require("throttle-debounce/throttle");

/***/ }),

/***/ "2c81":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "3ee4":
/***/ (function(module, exports) {

module.exports = require("async-validator");

/***/ }),

/***/ "5a5e":
/***/ (function(module, exports) {

module.exports = require("@vue/babel-helper-vue-jsx-merge-props");

/***/ }),

/***/ "7435":
/***/ (function(module, exports) {

module.exports = require("throttle-debounce/debounce");

/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = require("vue");

/***/ }),

/***/ "9224":
/***/ (function(module) {

module.exports = JSON.parse("{\"a\":\"2.43.2\"}");

/***/ }),

/***/ "a1cc":
/***/ (function(module, exports) {

module.exports = require("resize-observer-polyfill");

/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/pagination/src/pager.vue?vue&type=template&id=fcca394c&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:"el-pager",on:{"click":_vm.onPagerClick}},[(_vm.pageCount > 0)?_c('li',{staticClass:"number",class:{ active: _vm.currentPage === 1, disabled: _vm.disabled }},[_vm._v(" 1 ")]):_vm._e(),(_vm.showPrevMore)?_c('el-tooltip',{attrs:{"content":_vm.t('el.pagination.prevMore', { count: _vm.pageCountOffset }),"effect":"light","placement":"top"}},[_c('li',{staticClass:"el-icon more btn-quickprev",class:[_vm.quickprevIconClass, { disabled: _vm.disabled }],on:{"mouseenter":function($event){return _vm.onMouseenter('left')},"mouseleave":function($event){_vm.quickprevIconClass = 'h-icon-more_hori'}}})]):_vm._e(),_vm._l((_vm.pagers),function(pager){return _c('li',{key:pager,staticClass:"number",class:{ active: _vm.currentPage === pager, disabled: _vm.disabled }},[_vm._v(" "+_vm._s(pager)+" ")])}),(_vm.showNextMore)?_c('el-tooltip',{attrs:{"content":_vm.t('el.pagination.nextMore', { count: _vm.pageCountOffset }),"effect":"light","placement":"top"}},[_c('li',{staticClass:"el-icon more btn-quicknext",class:[_vm.quicknextIconClass, { disabled: _vm.disabled }],on:{"mouseenter":function($event){return _vm.onMouseenter('right')},"mouseleave":function($event){_vm.quicknextIconClass = 'h-icon-more_hori'}}})]):_vm._e(),(_vm.pageCount > 1)?_c('li',{staticClass:"number",class:{ active: _vm.currentPage === _vm.pageCount, disabled: _vm.disabled }},[_vm._v(" "+_vm._s(_vm.pageCount)+" ")]):_vm._e()],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./packages/pagination/src/pager.vue?vue&type=template&id=fcca394c&

// EXTERNAL MODULE: external "hui/lib/locale"
var locale_ = __webpack_require__("0a57");
var locale_default = /*#__PURE__*/__webpack_require__.n(locale_);

// CONCATENATED MODULE: ./src/mixins/locale.js

/* harmony default export */ var locale = ({
  methods: {
    t(...args) {
      return locale_["t"].apply(this, args);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/pagination/src/pager.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var pagervue_type_script_lang_js_ = ({
  name: 'ElPager',
  mixins: [locale],
  props: {
    currentPage: {
      type: Number,
      default: null
    },
    pageCount: {
      type: Number,
      default: null
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      current: null,
      quicknextIconClass: 'h-icon-more_hori',
      quickprevIconClass: 'h-icon-more_hori',
      showPrevMore: false,
      showNextMore: false
    };
  },
  computed: {
    pagers() {
      const array = [];
      const pagerCount = this.pagerCount;
      const halfPagerCount = Math.floor(pagerCount / 2);
      const currentPage = Number(this.currentPage);
      const pageCount = Number(this.pageCount);
      let showPrevMore = false;
      let showNextMore = false;
      if (pageCount > pagerCount) {
        if (currentPage > pagerCount - halfPagerCount) {
          showPrevMore = true;
        }
        if (currentPage < pageCount - halfPagerCount) {
          showNextMore = true;
        }
      }
      if (showPrevMore && !showNextMore) {
        const startPage = pageCount - (pagerCount - 2);
        for (let i = startPage; i < pageCount; i++) {
          array.push(i);
        }
      } else if (!showPrevMore && showNextMore) {
        for (let i = 2; i < pagerCount; i++) {
          array.push(i);
        }
      } else if (showPrevMore && showNextMore) {
        const offset = Math.floor(pagerCount / 2) - 1;
        // 对pagerCount为偶数的情况做处理, 但是不推荐用户使用偶数的pagerCount
        const startNum = pagerCount % 2 ? currentPage - offset : currentPage - offset + 1;
        for (let i = startNum; i <= currentPage + offset; i++) {
          array.push(i);
        }
      } else {
        for (let i = 2; i < pageCount; i++) {
          array.push(i);
        }
      }

      // eslint-disable-next-line vue/no-side-effects-in-computed-properties
      this.showPrevMore = showPrevMore;
      // eslint-disable-next-line vue/no-side-effects-in-computed-properties
      this.showNextMore = showNextMore;
      return array;
    },
    pageCountOffset() {
      return Number(this.pagerCount) >= 2 ? Number(this.pagerCount) - 2 : 2;
    }
  },
  watch: {
    showPrevMore(val) {
      if (!val) this.quickprevIconClass = 'h-icon-more_hori';
    },
    showNextMore(val) {
      if (!val) this.quicknextIconClass = 'h-icon-more_hori';
    }
  },
  methods: {
    onPagerClick(event) {
      const target = event.target;
      if (target.tagName === 'UL' || this.disabled) {
        return;
      }
      let newPage = Number(event.target.textContent);
      const pageCount = this.pageCount;
      const currentPage = this.currentPage;
      if (target.className.indexOf('more') !== -1) {
        if (target.className.indexOf('quickprev') !== -1) {
          newPage = currentPage - this.pageCountOffset;
        } else if (target.className.indexOf('quicknext') !== -1) {
          newPage = currentPage + this.pageCountOffset;
        }
      }

      /* istanbul ignore if */
      if (!isNaN(newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }
        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }
      if (newPage !== currentPage) {
        this.$emit('change', newPage);
      }
    },
    onMouseenter(direction) {
      if (this.disabled) return;
      if (direction === 'left') {
        this.quickprevIconClass = 'h-icon-angles_left_sm';
      } else {
        this.quicknextIconClass = 'h-icon-angles_right_sm';
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/pagination/src/pager.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_pagervue_type_script_lang_js_ = (pagervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./packages/pagination/src/pager.vue





/* normalize component */

var component = normalizeComponent(
  src_pagervue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var pager = (component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=template&id=4d0038c5&
var selectvue_type_template_id_4d0038c5_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],staticClass:"el-select",class:[_vm.kind ? 'el-select--' + _vm.kind : '']},[(_vm.multiple)?_c('div',{ref:"tags",staticClass:"el-select__tags",class:{
      'el-select__tags--nowrap': _vm.multipleNowrap,
      'el-select__tags--filterable-left': _vm.multipleNowrap && _vm.filterable
    },style:({ 'max-width': _vm.inputWidth - _vm.inputWidthMin + 'px' }),on:{"click":function($event){$event.stopPropagation();return _vm.toggleMenu.apply(null, arguments)}}},[(_vm.collapseTags && _vm.selected.length)?_c('span',[_c('el-tag',{class:[
          {
            'el-tag--disabled': _vm.disabled
          }
        ],attrs:{"closable":!_vm.selected[0].disabled,"size":_vm.collapseTagSize,"title":_vm.selected[0].currentLabel,"hit":_vm.selected[0].hitState,"max-width":"94px","type":"primary","close-transitions":""},on:{"close":function($event){return _vm.deleteTag($event, _vm.selected[0])}}},[_c('span',{staticClass:"el-select__tags-text"},[_vm._v(" "+_vm._s(_vm.selected[0].currentLabel)+" ")])]),(_vm.selected.length > 1)?_c('el-tag',{attrs:{"closable":false,"size":_vm.collapseTagSize,"type":"primary","close-transitions":""}},[_c('span',{staticClass:"el-select__tags-text"},[_vm._v("+ "+_vm._s(_vm.selected.length - 1))])]):_vm._e()],1):_vm._e(),(!_vm.collapseTags)?_c('transition-group',{on:{"after-leave":_vm.resetInputHeight}},_vm._l((_vm.selected),function(item){return _c('el-tag',{key:_vm.getValueKey(item),class:[
          {
            'el-tag--disabled': _vm.disabled
          }
        ],attrs:{"title":item.currentLabel,"closable":!item.disabled,"size":_vm.collapseTagSize,"hit":item.hitState,"max-width":"94px","type":"primary","close-transition":""},on:{"close":function($event){return _vm.deleteTag($event, item)}}},[_c('span',{staticClass:"el-select__tags-text"},[_vm._v(_vm._s(item.currentLabel))])])}),1):_vm._e(),(_vm.filterable)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.query),expression:"query"}],ref:"input",staticClass:"el-select__input",class:("is-" + _vm.size),style:({
        width: _vm.textWidth + 16 + 'px',
        'max-width': _vm.inputWidth - _vm.inputWidthMin + 'px',
        'flex-grow': 1
      }),attrs:{"disabled":_vm.disabled,"debounce":_vm.remote ? 300 : 0,"type":"text"},domProps:{"value":(_vm.query)},on:{"keyup":_vm.managePlaceholder,"keydown":[function($event){if($event.ctrlKey||$event.shiftKey||$event.altKey||$event.metaKey){ return null; }return _vm.resetInputState.apply(null, arguments)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.navigateOptions('next')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.navigateOptions('prev')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.selectOption.apply(null, arguments)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"])){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"delete",[8,46],$event.key,["Backspace","Delete","Del"])){ return null; }return _vm.deletePrevTag.apply(null, arguments)}],"input":function($event){if($event.target.composing){ return; }_vm.query=$event.target.value}}}):_c('div',{staticStyle:{"flex-grow":"1"}})],1):_vm._e(),_c('span',{ref:"text",staticClass:"el-select__text",domProps:{"textContent":_vm._s(_vm.query)}}),(_vm.isIE && !_vm.multiple && !_vm.filterable)?_c('div',{staticClass:"el-select__isIE",attrs:{"icon":_vm.iconClass},on:{"click":_vm.toggleMenu,"mouseenter":function($event){_vm.inputHovering = true},"mouseleave":function($event){_vm.inputHovering = false}}}):_vm._e(),_c('el-input',{ref:"reference",attrs:{"title":_vm.selectedLabel,"placeholder":_vm.currentPlaceholder,"select":_vm.inputClear,"name":_vm.name,"size":_vm.size,"disabled":_vm.disabled,"readonly":!_vm.filterable || _vm.multiple,"unselectable":_vm.isIE && !_vm.multiple && !_vm.filterable ? 'on' : 'off',"validate-event":false,"type":"text"},on:{"focus":_vm.handleFocus,"blur":_vm.handleBlur,"click":_vm.handleIconClick,"input":_vm.debouncedOnInputChange},nativeOn:{"mousedown":function($event){return _vm.handleMouseDown.apply(null, arguments)},"keyup":function($event){return _vm.debouncedOnInputChange.apply(null, arguments)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.navigateOptions('next')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.navigateOptions('prev')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.selectOption.apply(null, arguments)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"esc",27,$event.key,["Esc","Escape"])){ return null; }$event.stopPropagation();$event.preventDefault();_vm.visible = false},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"tab",9,$event.key,"Tab")){ return null; }_vm.visible = false}],"paste":function($event){return _vm.debouncedOnInputChange.apply(null, arguments)},"mouseenter":function($event){_vm.inputHovering = true},"mouseleave":function($event){_vm.inputHovering = false}},model:{value:(_vm.selectedLabel),callback:function ($$v) {_vm.selectedLabel=$$v},expression:"selectedLabel"}},[(_vm.$slots.prefix)?_c('template',{slot:"prefix"},[_vm._t("prefix")],2):_vm._e(),_c('i',{staticClass:"el-input__icon",class:_vm.iconClass,attrs:{"slot":"suffix"},on:{"click":_vm.handleIconClick},slot:"suffix"})],2),_c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"before-enter":_vm.handleMenuEnter,"after-enter":_vm.afterEnter,"after-leave":_vm.doDestroy}},[_c('el-select-menu',{directives:[{name:"show",rawName:"v-show",value:(_vm.showDropdown),expression:"showDropdown"}],ref:"popper",attrs:{"append-to-body":_vm.popperAppendToBody,"popper-options":_vm.popperOptions,"placement":_vm.placement}},[_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.options.length > 0 && !_vm.loading),expression:"options.length > 0 && !loading"}],ref:"scrollbar",class:{
          'is-empty': !_vm.allowCreate && _vm.filteredOptionsCount === 0
        },attrs:{"always-show":"","is-small":"","tag":"ul","wrap-class":"el-select-dropdown__wrap","view-class":"el-select-dropdown__list"},on:{"on-scrolling-x":_vm.onScrollingX,"on-scrolling-y":_vm.onScrollingY}},[_vm._t("default"),(_vm.showNewOption)?_c('el-option',{attrs:{"value":_vm.query,"created":""}}):_vm._e()],2),(_vm.isShowEmptyText)?_c('p',{staticClass:"el-select-dropdown__empty"},[_vm._v(" "+_vm._s(_vm.emptyText)+" ")]):_vm._e()],1)],1)],1)}
var selectvue_type_template_id_4d0038c5_staticRenderFns = []


// CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=template&id=4d0038c5&

// CONCATENATED MODULE: ./src/mixins/emitter.js
function broadcast(componentName, eventName, params) {
  this.$children.forEach(child => {
    var name = child.$options.componentName;
    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
/* harmony default export */ var emitter = ({
  methods: {
    /**
     * @desc 若存在指定的父控件，触发他的指定事件
     * @example Form中使用Input控件，Input失去焦点，触发Form的失去焦点事件
     * @param {String} componentName 父控件的名称
     * @param {String} eventName 需要触发的事件名称
     * @param {Object} params 事件参数
     */
    dispatch(componentName, eventName, params) {
      // 获取父组件，如果是根组件，则是$root
      var parent = this.$parent || this.$root;
      // 获取父节点的组件名
      var name = parent.$options.componentName;

      // 当父组件不是所需组件时继续向上寻找
      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;
        if (parent) {
          name = parent.$options.componentName;
        }
      }
      // 找到所需组件后调用$emit触发当前事件
      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    // 与dispatch相反
    broadcast(componentName, eventName, params) {
      broadcast.call(this, componentName, eventName, params);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=template&id=04d9a470&
var inputvue_type_template_id_04d9a470_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"wrapper",class:[
    _vm.type === 'textarea' ? 'el-textarea' : 'el-input',
    _vm.kind ? 'el-input--' + _vm.kind : '',
    _vm.size ? 'el-input--' + _vm.size : '',
    {
      'is-disabled': _vm.disabled,
      'is-count': _vm.count,
      'el-input-group': _vm.$slots.prepend || _vm.$slots.append,
      'el-input-group--append': _vm.$slots.append,
      'el-input-group--prepend': _vm.$slots.prepend,
      'el-input--prefix': _vm.$slots.prefix || _vm.prefixIcon,
      'el-input--suffix': _vm.$slots.suffix || _vm.suffixIcon,
      'is-hover': _vm.count && _vm.isHover,
      'is-focus': _vm.count && _vm.isFocus
    }
  ]},[(_vm.type !== 'textarea')?[(_vm.$slots.prepend)?_c('div',{staticClass:"el-input-group__prepend"},[_vm._t("prepend")],2):_vm._e(),_vm._t("icon",function(){return [(_vm.icon)?_c('i',{staticClass:"el-input__icon",class:[
          _vm.icon,
          _vm.onIconClick || _vm.onMousedownClick || _vm.onMouseupClick
            ? 'is-clickable'
            : ''
        ],style:(_vm.suffixOffset),on:{"click":_vm.handleIconClick,"mousedown":_vm.handleMousedownClick,"mouseup":_vm.handleMouseupClick}}):_vm._e()]}),(_vm.clearable && _vm.value && (String(_vm.value).length || _vm.select))?_c('i',{staticClass:"el-input__icon h-icon-close_f is-clickable",style:({
        right: _vm.$slots.suffix || _vm.suffixIcon ? 28 + 'px' : 4 + 'px',
        transform: _vm.suffixOffset ? _vm.suffixOffset.transform : 0,
        zIndex: 1
      }),on:{"click":_vm.handleClearClick}}):_vm._e(),(_vm.tips)?[_c('el-popover',{ref:"popoverInput",attrs:{"content":_vm.tips,"max-width":_vm.tipsMaxWidth,"placement":_vm.tipsPlacement,"trigger":_vm.tipsTrigger,"disabled":_vm.tipsDisabled,"show-html":true,"offset-placement":_vm.tipsOffset,"popper-class":("el-popover__for-input " + _vm.tipsClass + " el-popover__for-input-form"),"effect":"light"}},[_c('input',_vm._b({ref:"input",staticClass:"el-input__inner",style:(_vm.inputStyle),attrs:{"slot":"reference","autocomplete":_vm.autoComplete},domProps:{"value":_vm.nativeInputValue},on:{"input":_vm.debouncedOnInputChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur},slot:"reference"},'input',[_vm.$props, _vm.$attrs],false))])]:[_c('input',_vm._b({ref:"input",staticClass:"el-input__inner",style:(_vm.inputStyle),attrs:{"autocomplete":_vm.autoComplete},domProps:{"value":_vm.nativeInputValue},on:{"input":_vm.debouncedOnInputChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur}},'input',[_vm.$props, _vm.$attrs],false))],(_vm.$slots.prefix || _vm.prefixIcon)?_c('span',{ref:"prefix",staticClass:"el-input__prefix",style:(_vm.prefixOffset)},[_vm._t("prefix"),(_vm.prefixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.prefixIcon,on:{"click":_vm.handleIconClick}}):_vm._e()],2):_vm._e(),(_vm.$slots.suffix || _vm.suffixIcon)?_c('span',{ref:"suffix",staticClass:"el-input__suffix",style:(_vm.suffixOffset)},[_c('span',{staticClass:"el-input__suffix-inner"},[[_vm._t("suffix"),(_vm.suffixIcon)?_c('i',{staticClass:"el-input__icon",class:_vm.suffixIcon,on:{"click":_vm.handleIconClick}}):_vm._e()]],2)]):_vm._e(),(_vm.validating)?_c('i',{staticClass:"el-input__icon el-validate__icon el-icon-restart"}):_vm._e(),(_vm.$slots.append)?_c('div',{staticClass:"el-input-group__append"},[_vm._t("append")],2):_vm._e()]:[(_vm.tips)?[_c('el-popover',{ref:"popoverTextarea",attrs:{"content":_vm.tips,"max-width":_vm.tipsMaxWidth,"placement":_vm.tipsPlacement,"trigger":_vm.tipsTrigger,"disabled":_vm.tipsDisabled,"show-html":true,"offset-placement":_vm.tipsOffset,"popper-class":("el-popover__for-input " + _vm.tipsClass + " el-popover__for-input-form"),"effect":"light"}},[_c('textarea',_vm._b({ref:"textarea",staticClass:"el-textarea__inner",style:(_vm.textareaStyle),attrs:{"slot":"reference"},domProps:{"value":_vm.nativeInputValue},on:{"input":_vm.debouncedOnInputChange,"mouseenter":_vm.handleMouseenter,"mouseout":_vm.handleMouseout,"focus":_vm.handleFocus,"blur":_vm.handleBlur},slot:"reference"},'textarea',[_vm.$props, _vm.$attrs],false))]),(_vm.count)?_c('span',{staticClass:"el-textarea__count",domProps:{"textContent":_vm._s(_vm.total)}}):_vm._e()]:[_c('textarea',_vm._b({ref:"textarea",staticClass:"el-textarea__inner",style:(_vm.textareaStyle),domProps:{"value":_vm.nativeInputValue},on:{"mouseenter":_vm.handleMouseenter,"mouseout":_vm.handleMouseout,"input":_vm.debouncedOnInputChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur}},'textarea',[_vm.$props, _vm.$attrs],false)),_vm._v(" "),(_vm.count)?_c('span',{staticClass:"el-textarea__count",domProps:{"textContent":_vm._s(_vm.total)}}):_vm._e()]]],2)}
var inputvue_type_template_id_04d9a470_staticRenderFns = []


// CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=template&id=04d9a470&

// CONCATENATED MODULE: ./packages/input/src/calcTextareaHeight.js
let hiddenTextarea;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`;
const CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue('box-sizing');
  const paddingWidth = parseFloat(style.getPropertyValue('padding-left')) + parseFloat(style.getPropertyValue('padding-right'));
  const paddingHeight = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  const borderWidth = parseFloat(style.getPropertyValue('border-left-width')) + parseFloat(style.getPropertyValue('border-right-width'));
  const borderHeight = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  const lineHeight = parseFloat(style.getPropertyValue('line-height'));
  const contextStyle = CONTEXT_STYLE.map(name => `${name}:${style.getPropertyValue(name)}`).join(';');
  return {
    contextStyle,
    paddingWidth,
    paddingHeight,
    borderWidth,
    borderHeight,
    lineHeight,
    boxSizing
  };
}
function calcTextareaHeight(targetElement, rect, minRows = null, maxRows = null, maxWidth = null) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }
  const style = {};
  const {
    contextStyle,
    paddingHeight,
    borderHeight,
    boxSizing
  } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
  let height = hiddenTextarea.scrollHeight;
  if (boxSizing === 'border-box') {
    height = height + borderHeight;
  } else if (boxSizing === 'content-box') {
    height = height - paddingHeight;
  }
  hiddenTextarea.value = '';
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingHeight;
  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingHeight + borderHeight;
    }
    height = Math.max(minHeight, height);
    style.minHeight = `${minHeight}px`;
  }
  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingHeight + borderHeight;
    }
    height = Math.min(maxHeight, height);
    style.maxHeight = `${maxHeight}px`;
  }
  style.height = `${height}px`;
  if (maxWidth) {
    style.maxWidth = `${+maxWidth}px`;
  }
  return style;
}
// CONCATENATED MODULE: ./src/utils/util.js
const util_hasOwnProperty = Object.prototype.hasOwnProperty;
function noop() {}
function hasOwn(obj, key) {
  return util_hasOwnProperty.call(obj, key);
}
function extend(to, _from) {
  for (const key in _from) {
    to[key] = _from[key];
  }
  return to;
}
function toObject(arr) {
  var res = {};
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
const getValueByPath = function (object, prop) {
  prop = prop || '';
  const paths = prop.split('.');
  let current = object;
  let result = null;
  for (let i = 0, j = paths.length; i < j; i++) {
    const path = paths[i];
    if (!current) break;
    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};
function getPropByPath(obj, path, strict, keyIncludePoint = false) {
  let tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  let keyArr = path.split('.');
  let i = 0;
  if (keyIncludePoint) {
    keyArr = [path];
  }
  for (let len = keyArr.length; i < len - 1; ++i) {
    const key = keyArr[i];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj[keyArr[i]]
  };
}

/**
 * 原生ajax
 * add by zhangxiaogang 2017-09-27
 * @param {string} opt.method http连接的方式，包括POST和GET两种方式
 * @param {string} opt.url 发送请求的url
 * @param {boolean} opt.async 是否为异步请求，true为异步的，false为同步的
 * @param {object} opt.data 发送的参数，格式为对象类型
 * @param {object} opt.dataType 返回的数据格式，默认json，如果返回原生text格式请传入dataType:'text'

 * @param {function} opt.success ajax发送并接收成功调用的回调函数
 * @param {function} opt.error ajax请求失败的回调
 */
function ajax(opt) {
  opt = opt || {};
  opt.type = opt.method && opt.method.toUpperCase() || 'GET';
  opt.url = opt.url || '';
  opt.async = !!opt.async;
  opt.data = opt.data || opt.params || {};
  var xmlHttp = null;
  if (XMLHttpRequest) {
    xmlHttp = new XMLHttpRequest();
  } else {
    xmlHttp = new window.ActiveXObject('Microsoft.XMLHTTP');
  }
  var params = [];
  for (var key in opt.data) {
    params.push(key + '=' + opt.data[key]);
  }
  xmlHttp.onreadystatechange = function () {
    if (xmlHttp.readyState === 4) {
      if (xmlHttp.status === 200) {
        var resp = xmlHttp.responseText;
        if (opt.dataType !== 'text') {
          resp = JSON.parse(resp);
        }
        opt.success && opt.success(resp);
      } else {
        opt.error && opt.error(new Error(xmlHttp.statusText));
      }
    }
  };
  var postData = params.join('&');
  if (opt.type.toUpperCase() === 'POST') {
    xmlHttp.open(opt.type, opt.url, opt.async);
    xmlHttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
    if (opt.headers) {
      for (const c in opt.headers) {
        xmlHttp.setRequestHeader(c, opt.headers[c]);
      }
    }
    xmlHttp.send(postData);
  } else if (opt.type.toUpperCase() === 'GET') {
    var connector = ~opt.url.indexOf('?') ? '&' : '?';
    xmlHttp.open(opt.type, opt.url + (postData && connector) + postData, opt.async);
    xmlHttp.send(null);
  }
}

/**
 * 返回包含ajax功能的promise函数对象
 * add by zhangxiaogang 2017-09-27
 * @param {object} opt ajax请求传参
 */
function defaultPromise(opt) {
  if (Object.prototype.toString.call(opt) !== '[object Object]') return null;
  return new window.Promise((resolve, reject) => {
    opt.success = resolve;
    opt.error = reject;
    ajax(opt);
  });
}

/**
 * 深度合并对象
 * add by zhangxiaogang 2018-05-04
 */
function objectMerge(to, from) {
  for (var key in from) {
    to[key] = to[key] && to[key].toString() === '[object Object]' ? objectMerge(to[key], from[key]) : to[key] = from[key];
  }
  return to;
}

// TODO: use native Array.find, Array.findIndex when IE support is dropped
const arrayFindIndex = function (arr, pred) {
  for (let i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
};
const arrayFind = function (arr, pred) {
  const idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
};

// coerce truthy value to array
const coerceTruthyValueToArray = function (val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};
const generateId = function () {
  return Math.floor(Math.random() * 10000);
};

/**
 * @desc 找到子组件中的目标组件
 * @author chenguanbin
 * @param {Object} context 父组件
 * @param {String} componentName 子组件名称
 */
const findComponentsDownward = (context, componentName) => {
  return context.$children.reduce((components, child) => {
    if (child.$options.name === componentName) components.push(child);
    const foundChilds = findComponentsDownward(child, componentName);
    return components.concat(foundChilds);
  }, []);
};

/**
 * Check if the given variable is a function
 * @function
 * @author fanzhuohua
 * @argument {*} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
// CONCATENATED MODULE: ./src/utils/merge.js

/**
 * 合并对象
 * @param {Object} target 要合并到的对象
 * @returns {Object} 合并后的新对象
 */
/* harmony default export */ var merge = (function (target) {
  for (let i = 1, j = arguments.length; i < j; i++) {
    // 从第二个参数开始
    const source = arguments[i] || {}; // 获取该对象
    for (const prop in source) {
      if (hasOwn(source, prop)) {
        // 只处理不是从原型链上继承来的属性
        const value = source[prop];
        if (value !== undefined) {
          target[prop] = value; // 覆盖
        }
      }
    }
  }
  return target;
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=template&id=084ce9fc&
var mainvue_type_template_id_084ce9fc_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"el-popover-wrap"},[_c('transition',{attrs:{"name":_vm.transition},on:{"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.disabled && _vm.showPopper),expression:"!disabled && showPopper"}],ref:"popper",staticClass:"el-popover",class:[_vm.popperClass],style:(_vm.popoverStyle)},[(_vm.title)?_c('div',{staticClass:"el-popover__title",domProps:{"textContent":_vm._s(_vm.title)}}):_vm._e(),(_vm.showContent)?_vm._t("default",function(){return [_vm._v(_vm._s(_vm.content))]}):_vm._e()],2)]),_vm._t("reference")],2)}
var mainvue_type_template_id_084ce9fc_staticRenderFns = []


// CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=template&id=084ce9fc&

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__("8bbf");
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// CONCATENATED MODULE: ./src/utils/dom.js
/* istanbul ignore next */



const isServer = external_vue_default.a.prototype.$isServer;
const SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
const MOZ_HACK_REGEXP = /^moz([A-Z])/;
const ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
const trim = function (string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
const camelCase = function (name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
const on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
const off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
const once = function (el, event, fn) {
  var listener = function () {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) {
    throw new Error('className should not contain space.');
  }
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}

/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else {
      if (!hasClass(el, clsName)) {
        curClass += ' ' + clsName;
      }
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}

/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else {
      if (hasClass(el, clsName)) {
        curClass = curClass.replace(' ' + clsName + ' ', ' ');
      }
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
}

/* istanbul ignore next */
const getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;
  if (typeof styleName === 'object') {
    for (var prop in styleName) {
      if (hasOwn(styleName, prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
}

/**
 * 查找最近的符合条件的祖先元素
 * @param {被查询的元素} element
 * @param {选择器} selector
 */
function closest(element, selector) {
  if (!element || !selector) return;
  let targetNode = null;
  const traverse = function (element) {
    if (element === document) {
      return;
    }
    const nodes = element.parentNode.querySelectorAll(selector);
    if (nodes && nodes.length) {
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i] === element) {
          targetNode = element;
          return;
        }
      }
    }
    traverse(element.parentNode);
  };
  traverse(element);
  return targetNode;
}

/**
 * @desc 返回滚动条的滚动高度
 * @author chenguanbin
 * @param {Boolean} top 是否是获取顶部的左上角的Y坐标
 */
function getScroll(top) {
  var ret = window['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = window.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

/**
 * @desc 返回当前页面相对于窗口显示区左上角的 X ，Y 的位置
 * @author chenguanbin
 * @param {Document} el 需要获取位置的元素
 * @param {Document} container 容器元素
 */
function getOffset(el, container) {
  container = container || document.body;
  const elRect = el.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const clientTop = el.clientTop || container.clientTop || 0;
  const clientLeft = el.clientLeft || container.clientLeft || 0;
  let top, left;
  if (container === document.body) {
    top = getScroll(true);
    left = getScroll();
  } else {
    top = container.scrollTop - containerRect.top;
    left = container.scrollLeft - containerRect.left;
  }
  return {
    top: elRect.top + top - clientTop,
    left: elRect.left + left - clientLeft,
    right: elRect.right + left - clientLeft,
    bottom: elRect.bottom + top - clientTop
  };
}
// CONCATENATED MODULE: ./src/utils/popup/popup-manager.js


let hasModal = false;
const getModal = function (id, multiModal) {
  if (external_vue_default.a.prototype.$isServer) return;
  let modalDom;
  if (multiModal) {
    modalDom = PopupManager.multiModalDom[id];
  } else {
    modalDom = PopupManager.modalDom;
  }
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    if (multiModal) {
      PopupManager.multiModalDom[id] = modalDom;
    } else {
      PopupManager.modalDom = modalDom;
    }
    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    });
    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick(id);
    });
  }
  return modalDom;
};
const instances = {};
const PopupManager = {
  multiModalDom: {},
  zIndex: 2000,
  modalFade: true,
  getInstance: function (id) {
    return instances[id];
  },
  register: function (id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },
  deregister: function (id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },
  nextZIndex: function () {
    return PopupManager.zIndex++;
  },
  modalStack: [],
  multiModalStack: {},
  doOnModalClick: function (id) {
    let topItem;
    if (PopupManager.multiModalStack[id] !== undefined) {
      topItem = PopupManager.multiModalStack[id][PopupManager.multiModalStack[id].length - 1];
    } else {
      topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    }
    if (!topItem) return;
    const instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close(topItem.id);
    }
  },
  openModal: function (opts) {
    opts = Object.assign({
      multiModal: false
    }, opts);
    // id, zIndex, dom, modalClass, modalFade
    if (external_vue_default.a.prototype.$isServer) return;
    if (!opts.id || opts.zIndex === undefined) return;
    this.modalFade = opts.modalFade;
    let modalStack;
    if (opts.multiModal) {
      if (!this.multiModalStack[opts.id]) {
        this.multiModalStack[opts.id] = [];
      }
      modalStack = this.multiModalStack[opts.id];
    } else {
      modalStack = this.modalStack;
    }
    for (let i = 0, j = modalStack.length; i < j; i++) {
      const item = modalStack[i];
      if (item.id === opts.id) {
        return;
      }
    }
    const modalDom = getModal(opts.id, opts.multiModal);
    addClass(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      addClass(modalDom, 'v-modal-enter');
    }
    if (opts.modalClass) {
      const classArr = opts.modalClass.trim().split(/\s+/);
      classArr.forEach(item => addClass(modalDom, item));
    }
    setTimeout(() => {
      removeClass(modalDom, 'v-modal-enter');
    }, 200);
    if (opts.dom && opts.dom.parentNode && opts.dom.parentNode.nodeType !== 11) {
      opts.dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }
    if (opts.zIndex) {
      modalDom.style.zIndex = opts.zIndex;
    }
    modalDom.style.display = '';
    modalStack.push({
      id: opts.id,
      zIndex: opts.zIndex,
      modalClass: opts.modalClass
    });
  },
  closeModal: function (id) {
    let modalStack;
    if (this.multiModalStack[id] !== undefined) {
      modalStack = this.multiModalStack[id];
    } else {
      modalStack = this.modalStack;
    }
    const modalDom = getModal(id, PopupManager.multiModalStack[id] !== undefined);
    if (modalStack.length > 0) {
      const topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          const classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(item => removeClass(modalDom, item));
        }
        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (let i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }
    if (modalStack.length === 0) {
      if (this.modalFade) {
        addClass(modalDom, 'v-modal-leave');
      }
      setTimeout(() => {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          if (PopupManager.multiModalStack[id] !== undefined) {
            PopupManager.multiModalDom[id] = null;
          } else {
            PopupManager.modalDom = null;
          }
        }
        removeClass(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};
const getTopPopup = function () {
  if (external_vue_default.a.prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    const instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
};
if (!external_vue_default.a.prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function (event) {
    if (event.keyCode === 27) {
      const topPopup = getTopPopup();
      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
      }
    }
  });
}
/* harmony default export */ var popup_manager = (PopupManager);
// CONCATENATED MODULE: ./src/utils/scrollbar-width.js

let scrollBarWidth;
/* harmony default export */ var scrollbar_width = (function (isChange) {
  if (external_vue_default.a.prototype.$isServer) return 0;
  if (!isChange) {
    // 防止鼠标缩放浏览器时scrollBarWidth不变化
    if (scrollBarWidth !== undefined && scrollBarWidth !== 0) {
      return scrollBarWidth;
    }
  }
  const outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
});
// CONCATENATED MODULE: ./src/utils/popup/index.js





let idSeed = 1;
const transitions = [];
const hookTransition = transition => {
  if (transitions.indexOf(transition) !== -1) return;
  const getVueInstance = element => {
    let instance = element.__vue__;
    if (!instance) {
      const textNode = element.previousSibling;
      if (textNode.__vue__) {
        instance = textNode.__vue__;
      }
    }
    return instance;
  };
  external_vue_default.a.transition(transition, {
    afterEnter(el) {
      const instance = getVueInstance(el);
      if (instance) {
        instance.doAfterOpen && instance.doAfterOpen();
      }
    },
    afterLeave(el) {
      const instance = getVueInstance(el);
      if (instance) {
        instance.doAfterClose && instance.doAfterClose();
      }
    }
  });
};
let popup_scrollBarWidth;
const getDOM = function (dom) {
  if (dom.nodeType === 3) {
    dom = dom.nextElementSibling || dom.nextSibling;
    getDOM(dom);
  }
  return dom;
};
/* harmony default export */ var popup = ({
  model: {
    prop: 'visible',
    event: 'visible-change'
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    transition: {
      type: String,
      default: ''
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },
  inject: {
    configProvider: {
      default: () => ({})
    }
  },
  created() {
    if (this.transition) {
      hookTransition(this.transition);
    }
  },
  beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    popup_manager.register(this._popupId, this);
  },
  beforeDestroy() {
    popup_manager.deregister(this._popupId);
    popup_manager.closeModal(this._popupId);
    if (this.modal && this.bodyOverflow !== null && this.bodyOverflow !== 'hidden') {
      document.body.style.overflow = this.bodyOverflow;
      document.body.style.width = this.bodyPaddingRight;
    }
    if (this.modal && this.htmlOverflow !== null && this.htmlOverflow !== 'hidden') {
      document.getElementsByTagName('html')[0].style.overflow = this.htmlOverflow;
    }
    this.bodyOverflow = null;
    this.bodyPaddingRight = null;
    this.htmlOverflow = null;
  },
  data() {
    return {
      opened: false,
      bodyOverflow: null,
      bodyOverflowX: null,
      bodyOverflowY: null,
      htmlOverflow: null,
      bodyPaddingRight: null,
      rendered: false
    };
  },
  watch: {
    visible(val) {
      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          external_vue_default.a.nextTick(() => {
            this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },
  methods: {
    open(options) {
      if (!this.rendered) {
        this.rendered = true;
        this.$emit('visible-change', true);
      }
      const props = merge({}, this.$props || this, options);
      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);
      const openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(() => {
          this._openTimer = null;
          this.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },
    doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;
      this._opening = true;
      this.$emit('visible-change', true);
      const dom = getDOM(this.$el);
      const modal = props.modal;
      const zIndex = props.zIndex || this.configProvider.zIndex;
      if (zIndex) {
        popup_manager.zIndex = zIndex;
      }
      if (modal) {
        if (this._closing) {
          popup_manager.closeModal(this._popupId);
          this._closing = false;
        }
        popup_manager.openModal({
          id: this._popupId,
          zIndex: popup_manager.nextZIndex(),
          dom: this.modalAppendToBody ? undefined : dom,
          modalClass: props.modalClass,
          modalFade: props.modalFade
        });
        if (props.lockScroll) {
          if (!this.bodyOverflow) {
            this.bodyPaddingRight = document.body.style.width;
            this.bodyOverflow = document.body.style.overflow;
          }
          if (!this.htmlOverflow) {
            this.htmlOverflow = document.getElementsByTagName('html')[0].style.overflow;
          }
          popup_scrollBarWidth = scrollbar_width();
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, 'overflowY');
          if (popup_scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll')) {
            document.body.style.width = `calc(100% - ${popup_scrollBarWidth}px)`;
          }
          document.body.style.overflow = 'hidden';
        }
      }
      if (getComputedStyle(dom).position === 'static') {
        dom.style.position = 'absolute';
      }
      dom.style.zIndex = popup_manager.nextZIndex();
      this.opened = true;
      this.onOpen && this.onOpen();
      if (!this.transition) {
        this.doAfterOpen();
      }
    },
    doAfterOpen() {
      this._opening = false;
    },
    close() {
      if (this.willClose && !this.willClose()) return;
      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);
      const closeDelay = Number(this.closeDelay);
      if (closeDelay > 0) {
        this._closeTimer = setTimeout(() => {
          this._closeTimer = null;
          this.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },
    doClose() {
      this.$emit('visible-change', false);
      this._closing = true;
      this.onClose && this.onClose();
      if (this.lockScroll) {
        setTimeout(() => {
          if (this.modal && this.bodyOverflow !== 'hidden') {
            document.body.style.overflow = this.bodyOverflow;
            document.body.style.width = this.bodyPaddingRight;
          }
          if (this.modal && this.htmlOverflow !== 'hidden') {
            document.getElementsByTagName('html')[0].style.overflow = this.htmlOverflow;
          }
          this.bodyOverflow = null;
          this.bodyPaddingRight = null;
          this.htmlOverflow = null;
        }, 200);
      }
      this.opened = false;
      if (!this.transition) {
        this.doAfterClose();
      }
    },
    doAfterClose() {
      popup_manager.closeModal(this._popupId);
      this._closing = false;
    }
  }
});

// CONCATENATED MODULE: ./src/utils/popper.js
/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version {{version}}
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//
// Cross module loader
// Supported: Node, AMD, Browser globals
//
// (function (root, factory) {
//     if (typeof define === 'function' && define.amd) {
//         // AMDR. Register as an anonymous module.
//         define(factory);
//     } else if (typeof module === 'object' && module.exports) {
//         // Node. Does not work with strict CommonJS, but
//         // only CommonJS-like environments that support module.exports,
//         // like Node.
//         module.exports = factory();
//     } else {
//         // Browser globals (root is window)
//         root.Popper = factory();
//     }
// }(this, function () {



// var root = window;

// default options
var DEFAULTS = {
  // placement of the popper
  placement: 'bottom',
  gpuAcceleration: true,
  // shift popper from its origin by the given amount of pixels (can be negative)
  offset: 0,
  // the element which will act as boundary of the popper
  boundariesElement: 'viewport',
  // amount of pixel used to define a minimum distance between the boundaries and the popper
  boundariesPadding: 5,
  // popper will try to prevent overflow following this order,
  // by default, then, it could overflow on the left and on top of the boundariesElement
  preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
  // the behavior used by flip to change the placement of the popper
  flipBehavior: 'flip',
  arrowElement: '[x-arrow]',
  // list of functions used to modify the offsets before they are applied to the popper
  modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
  modifiersIgnored: [],
  forceAbsolute: false
};

/**
 * Create a new Popper.js instance
 * @constructor Popper
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement|Object} popper
 *      The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [popper.tagName='div'] The tag name of the generated popper.
 * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
 * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
 * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
 * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
 * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
 * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
 * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
 * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
 * @param {Object} options
 * @param {String} [options.placement=bottom]
 *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
 *      left(-start, -end)`
 *
 * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
 *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
 *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
 *      reference element.
 *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
 *
 * @param {Boolean} [options.gpuAcceleration=true]
 *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
 *      browser to use the GPU to accelerate the rendering.
 *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
 *
 * @param {Number} [options.offset=0]
 *      Amount of pixels the popper will be shifted (can be negative).
 *
 * @param {String|Element} [options.boundariesElement='viewport']
 *      The element which will define the boundaries of the popper position, the popper will never be placed outside
 *      of the defined boundaries (except if `keepTogether` is enabled)
 *
 * @param {Number} [options.boundariesPadding=5]
 *      Additional padding for the boundaries
 *
 * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
 *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
 *      this means that the last ones will never overflow
 *
 * @param {String|Array} [options.flipBehavior='flip']
 *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
 *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
 *      its axis (`right - left`, `top - bottom`).
 *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
 *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
 *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
 *
 * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
 *      List of functions used to modify the data before they are applied to the popper, add your custom functions
 *      to this array to edit the offsets and placement.
 *      The function should reflect the @params and @returns of preventOverflow
 *
 * @param {Array} [options.modifiersIgnored=[]]
 *      Put here any built-in modifier name you want to exclude from the modifiers list
 *      The function should reflect the @params and @returns of preventOverflow
 *
 * @param {Boolean} [options.removeOnDestroy=false]
 *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
 */
function Popper(reference, popper, options) {
  this._reference = reference.jquery ? reference[0] : reference;
  this.state = {};

  // if the popper variable is a configuration object, parse it to generate an HTMLElement
  // generate a default popper if is not defined
  var isNotDefined = typeof popper === 'undefined' || popper === null;
  var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
  if (isNotDefined || isConfig) {
    this._popper = this.parse(isConfig ? popper : {});
  }
  // otherwise, use the given HTMLElement as popper
  else {
    this._popper = popper.jquery ? popper[0] : popper;
  }

  // with {} we create a new object with the options inside it
  this._options = Object.assign({}, DEFAULTS, options);

  // refactoring modifiers' list
  this._options.modifiers = this._options.modifiers.map(function (modifier) {
    // remove ignored modifiers
    if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

    // set the x-placement attribute before everything else because it could be used to add margins to the popper
    // margins needs to be calculated to get the correct popper offsets
    if (modifier === 'applyStyle') {
      this._popper.setAttribute('x-placement', this._options.placement);
    }

    // return predefined modifier identified by string or keep the custom one
    return this.modifiers[modifier] || modifier;
  }.bind(this));

  // make sure to apply the popper position before any computation
  this.state.position = this._getPosition(this._popper, this._reference);
  popper_setStyle(this._popper, {
    position: this.state.position,
    top: 0
  });

  // fire the first update to position the popper in the right place
  this.update();

  // setup event listeners, they will take care of update the position in specific situations
  this._setupEventListeners();
  return this;
}

//
// Methods
//
/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
Popper.prototype.destroy = function () {
  this._popper.removeAttribute('x-placement');
  this._popper.style.left = '';
  this._popper.style.position = '';
  this._popper.style.top = '';
  this._popper.style[getSupportedPropertyName('transform')] = '';
  this._removeEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  if (this._options.removeOnDestroy) {
    this._popper.remove();
  }
  return this;
};

/**
 * Updates the position of the popper, computing the new offsets and applying the new style
 * @method
 * @memberof Popper
 */
Popper.prototype.update = function () {
  var data = {
    instance: this,
    styles: {}
  };

  // store placement inside the data object, modifiers will be able to edit `placement` if needed
  // and refer to _originalPlacement to know the original value
  data.placement = this._options.placement;
  data._originalPlacement = this._options.placement;

  // compute the popper and reference offsets and put them inside data.offsets
  data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

  // get boundaries
  data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
  data = this.runModifiers(data, this._options.modifiers);
  if (typeof this.state.updateCallback === 'function') {
    this.state.updateCallback(data);
  }
};

/**
 * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
 * @method
 * @memberof Popper
 * @param {Function} callback
 */
Popper.prototype.onCreate = function (callback) {
  // the createCallbacks return as first argument the popper instance
  callback(this);
  return this;
};

/**
 * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
 * used to style popper and its arrow.
 * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
 * @method
 * @memberof Popper
 * @param {Function} callback
 */
Popper.prototype.onUpdate = function (callback) {
  this.state.updateCallback = callback;
  return this;
};

/**
 * Helper used to generate poppers from a configuration file
 * @method
 * @memberof Popper
 * @param config {Object} configuration
 * @returns {HTMLElement} popper
 */
Popper.prototype.parse = function (config) {
  var defaultConfig = {
    tagName: 'div',
    classNames: ['popper'],
    attributes: [],
    parent: window.document.body,
    content: '',
    contentType: 'text',
    arrowTagName: 'div',
    arrowClassNames: ['popper__arrow'],
    arrowAttributes: ['x-arrow']
  };
  config = Object.assign({}, defaultConfig, config);
  var d = window.document;
  var popper = d.createElement(config.tagName);
  addClassNames(popper, config.classNames);
  addAttributes(popper, config.attributes);
  if (config.contentType === 'node') {
    popper.appendChild(config.content.jquery ? config.content[0] : config.content);
  } else if (config.contentType === 'html') {
    popper.innerHTML = config.content;
  } else {
    popper.textContent = config.content;
  }
  if (config.arrowTagName) {
    var arrow = d.createElement(config.arrowTagName);
    addClassNames(arrow, config.arrowClassNames);
    addAttributes(arrow, config.arrowAttributes);
    popper.appendChild(arrow);
  }
  var parent = config.parent.jquery ? config.parent[0] : config.parent;

  // if the given parent is a string, use it to match an element
  // if more than one element is matched, the first one will be used as parent
  // if no elements are matched, the script will throw an error
  if (typeof parent === 'string') {
    parent = d.querySelectorAll(config.parent);
    if (parent.length > 1) {
      console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
    }
    if (parent.length === 0) {
      throw "ERROR: the given `parent` doesn't exists!";
    }
    parent = parent[0];
  }
  // if the given parent is a DOM nodes list or an array of nodes with more than one element,
  // the first one will be used as parent
  if (parent.length > 1 && parent instanceof Element === false) {
    console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
    parent = parent[0];
  }

  // append the generated popper to its parent
  parent.appendChild(popper);
  return popper;

  /**
   * Adds class names to the given element
   * @function
   * @ignore
   * @param {HTMLElement} target
   * @param {Array} classes
   */
  function addClassNames(element, classNames) {
    classNames.forEach(function (className) {
      element.classList.add(className);
    });
  }

  /**
   * Adds attributes to the given element
   * @function
   * @ignore
   * @param {HTMLElement} target
   * @param {Array} attributes
   * @example
   * addAttributes(element, [ 'data-info:foobar' ]);
   */
  function addAttributes(element, attributes) {
    attributes.forEach(function (attribute) {
      element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
    });
  }
};

/**
 * Helper used to get the position which will be applied to the popper
 * @method
 * @memberof Popper
 * @param config {HTMLElement} popper element
 * @param reference {HTMLElement} reference element
 * @returns {String} position
 */
Popper.prototype._getPosition = function (popper, reference) {
  var container = getOffsetParent(reference);
  if (this._options.forceAbsolute) {
    return 'absolute';
  }

  // Decide if the popper will be fixed
  // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
  var isParentFixed = isFixed(reference, container);
  return isParentFixed ? 'fixed' : 'absolute';
};

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper
 * @access private
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
Popper.prototype._getOffsets = function (popper, reference, placement) {
  placement = placement.split('-')[0];
  var popperOffsets = {};
  popperOffsets.position = this.state.position;
  var isParentFixed = popperOffsets.position === 'fixed';

  //
  // Get reference element position
  //
  var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

  //
  // Get popper sizes
  //
  var popperRect = getOuterSizes(popper);

  //
  // Compute offsets of popper
  //

  // depending by the popper placement we have to compute its offsets slightly differently
  if (['right', 'left'].indexOf(placement) !== -1) {
    popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
    if (placement === 'left') {
      popperOffsets.left = referenceOffsets.left - popperRect.width;
    } else {
      popperOffsets.left = referenceOffsets.right;
    }
  } else {
    popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
    if (placement === 'top') {
      popperOffsets.top = referenceOffsets.top - popperRect.height;
    } else {
      popperOffsets.top = referenceOffsets.bottom;
    }
  }

  // Add width and height to our offsets object
  popperOffsets.width = popperRect.width;
  popperOffsets.height = popperRect.height;
  return {
    popper: popperOffsets,
    reference: referenceOffsets
  };
};

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper
 * @access private
 */
Popper.prototype._setupEventListeners = function () {
  // NOTE: 1 DOM access here
  this.state.updateBound = this.update.bind(this);
  window.addEventListener('resize', this.state.updateBound);
  // if the boundariesElement is window we don't need to listen for the scroll event
  if (this._options.boundariesElement !== 'window') {
    var target = getScrollParent(this._reference);
    // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
    if (target === window.document.body || target === window.document.documentElement) {
      target = window;
    }
    target.addEventListener('scroll', this.state.updateBound);
  }
};

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper
 * @access private
 */
Popper.prototype._removeEventListeners = function () {
  // NOTE: 1 DOM access here
  window.removeEventListener('resize', this.state.updateBound);
  if (this._options.boundariesElement !== 'window') {
    var target = getScrollParent(this._reference);
    // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
    if (target === window.document.body || target === window.document.documentElement) {
      target = window;
    }
    target.removeEventListener('scroll', this.state.updateBound);
  }
  this.state.updateBound = null;
};

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper
 * @access private
 * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
 * @param {Number} padding - Boundaries padding
 * @param {Element} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = {};
  var width, height;
  if (boundariesElement === 'window') {
    var body = window.document.body;
    var html = window.document.documentElement;
    height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
    width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
    boundaries = {
      top: 0,
      right: width,
      bottom: height,
      left: 0
    };
  } else if (boundariesElement === 'viewport') {
    var offsetParent = getOffsetParent(this._popper);
    var scrollParent = getScrollParent(this._popper);
    var offsetParentRect = getOffsetRect(offsetParent);

    // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
    var getScrollTopValue = function (element) {
      return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
    };
    var getScrollLeftValue = function (element) {
      return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
    };

    // if the popper is fixed we don't have to substract scrolling from the boundaries
    var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
    var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
    boundaries = {
      top: 0 - (offsetParentRect.top - scrollTop),
      right: window.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
      bottom: window.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
      left: 0 - (offsetParentRect.left - scrollLeft)
    };
  } else {
    if (getOffsetParent(this._popper) === boundariesElement) {
      boundaries = {
        top: 0,
        left: 0,
        right: boundariesElement.clientWidth,
        bottom: boundariesElement.clientHeight
      };
    } else {
      boundaries = getOffsetRect(boundariesElement);
    }
  }
  boundaries.left += padding;
  boundaries.right -= padding;
  boundaries.top = boundaries.top + padding;
  boundaries.bottom = boundaries.bottom - padding;
  return boundaries;
};

/**
 * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
 * @method
 * @memberof Popper
 * @access public
 * @param {Object} data
 * @param {Array} modifiers
 * @param {Function} ends
 */
Popper.prototype.runModifiers = function (data, modifiers, ends) {
  var modifiersToRun = modifiers.slice();
  if (ends !== undefined) {
    modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
  }
  modifiersToRun.forEach(function (modifier) {
    if (popper_isFunction(modifier)) {
      data = modifier.call(this, data);
    }
  }.bind(this));
  return data;
};

/**
 * Helper used to know if the given modifier depends from another one.
 * @method
 * @memberof Popper
 * @param {String} requesting - name of requesting modifier
 * @param {String} requested - name of requested modifier
 * @returns {Boolean}
 */
Popper.prototype.isModifierRequired = function (requesting, requested) {
  var index = getArrayKeyIndex(this._options.modifiers, requesting);
  return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
    return modifier === requested;
  }).length;
};

//
// Modifiers
//

/**
 * Modifiers list
 * @namespace Popper.modifiers
 * @memberof Popper
 * @type {Object}
 */
Popper.prototype.modifiers = {};

/**
 * Apply the computed styles to the popper element
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The same data object
 */
Popper.prototype.modifiers.applyStyle = function (data) {
  // apply the final offsets to the popper
  // NOTE: 1 DOM access here
  var styles = {
    position: data.offsets.popper.position
  };

  // round top and left to avoid blurry text
  var left = Math.round(data.offsets.popper.left);
  var top = Math.round(data.offsets.popper.top);

  // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
  // we automatically use the supported prefixed version if needed
  var prefixedProperty;
  if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles.top = 0;
    styles.left = 0;
  }
  // othwerise, we use the standard `left` and `top` properties
  else {
    styles.left = left;
    styles.top = top;
  }

  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  Object.assign(styles, data.styles);
  popper_setStyle(this._popper, styles);

  // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
  // NOTE: 1 DOM access here
  this._popper.setAttribute('x-placement', data.placement);

  // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
  if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
    popper_setStyle(data.arrowElement, data.offsets.arrow);
  }
  return data;
};

/**
 * Modifier used to shift the popper on the start or end of its reference element side
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.shift = function (data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftVariation = placement.split('-')[1];

  // if shift shiftVariation is specified, run the modifier
  if (shiftVariation) {
    var reference = data.offsets.reference;
    var popper = getPopperClientRect(data.offsets.popper);
    var shiftOffsets = {
      y: {
        start: {
          top: reference.top
        },
        end: {
          top: reference.top + reference.height - popper.height
        }
      },
      x: {
        start: {
          left: reference.left
        },
        end: {
          left: reference.left + reference.width - popper.width
        }
      }
    };
    var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
    data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
  }
  return data;
};

/**
 * Modifier used to make sure the popper does not overflows from it's boundaries
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.preventOverflow = function (data) {
  var order = this._options.preventOverflowOrder;
  var popper = getPopperClientRect(data.offsets.popper);
  var check = {
    left: function () {
      var left = popper.left;
      if (popper.left < data.boundaries.left) {
        left = Math.max(popper.left, data.boundaries.left);
      }
      return {
        left: left
      };
    },
    right: function () {
      var left = popper.left;
      if (popper.right > data.boundaries.right) {
        left = Math.min(popper.left, data.boundaries.right - popper.width);
      }
      return {
        left: left
      };
    },
    top: function () {
      var top = popper.top;
      if (popper.top < data.boundaries.top) {
        top = Math.max(popper.top, data.boundaries.top);
      }
      return {
        top: top
      };
    },
    bottom: function () {
      var top = popper.top;
      if (popper.bottom > data.boundaries.bottom) {
        top = Math.min(popper.top, data.boundaries.bottom - popper.height);
      }
      return {
        top: top
      };
    }
  };
  order.forEach(function (direction) {
    data.offsets.popper = Object.assign(popper, check[direction]());
  });
  return data;
};

/**
 * Modifier used to make sure the popper is always near its reference
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.keepTogether = function (data) {
  var popper = getPopperClientRect(data.offsets.popper);
  var reference = data.offsets.reference;
  var f = Math.floor;
  if (popper.right < f(reference.left)) {
    data.offsets.popper.left = f(reference.left) - popper.width;
  }
  if (popper.left > f(reference.right)) {
    data.offsets.popper.left = f(reference.right);
  }
  if (popper.bottom < f(reference.top)) {
    data.offsets.popper.top = f(reference.top) - popper.height;
  }
  if (popper.top > f(reference.bottom)) {
    data.offsets.popper.top = f(reference.bottom);
  }
  return data;
};

/**
 * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
 * Requires the `preventOverflow` modifier before it in order to work.
 * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.flip = function (data) {
  // check if preventOverflow is in the list of modifiers before the flip modifier.
  // otherwise flip would not work as expected.
  if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
    console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
    return data;
  }
  if (data.flipped && data.placement === data._originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];
  if (this._options.flipBehavior === 'flip') {
    flipOrder = [placement, placementOpposite];
  } else {
    flipOrder = this._options.flipBehavior;
  }
  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return;
    }
    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = getPopperClientRect(data.offsets.popper);

    // this boolean is used to distinguish right and bottom from top and left
    // they need different computations to get flipped
    var a = ['right', 'bottom'].indexOf(placement) !== -1;

    // using Math.floor because the reference offsets may contain decimals we are not going to consider here
    if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
      // we'll use this boolean to detect any flip loop
      data.flipped = true;
      data.placement = flipOrder[index + 1];
      if (variation) {
        data.placement += '-' + variation;
      }
      data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
      data = this.runModifiers(data, this._options.modifiers, this._flip);
    }
  }.bind(this));
  return data;
};

/**
 * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
 * The offsets will shift the popper on the side of its reference element.
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.offset = function (data) {
  var offset = this._options.offset;
  var popper = data.offsets.popper;
  if (data.placement.indexOf('left') !== -1) {
    popper.top -= offset;
  } else if (data.placement.indexOf('right') !== -1) {
    popper.top += offset;
  } else if (data.placement.indexOf('top') !== -1) {
    popper.left -= offset;
  } else if (data.placement.indexOf('bottom') !== -1) {
    popper.left += offset;
  }
  return data;
};

/**
 * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
 * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
Popper.prototype.modifiers.arrow = function (data) {
  var arrow = this._options.arrowElement;

  // if the arrowElement is a string, suppose it's a CSS selector
  if (typeof arrow === 'string') {
    arrow = this._popper.querySelector(arrow);
  }

  // if arrow element is not found, don't run the modifier
  if (!arrow) {
    return data;
  }

  // the arrow element must be child of its popper
  if (!this._popper.contains(arrow)) {
    console.warn('WARNING: `arrowElement` must be child of its popper element!');
    return data;
  }

  // arrow depends on keepTogether in order to work
  if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
    console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
    return data;
  }
  var arrowStyle = {};
  var placement = data.placement.split('-')[0];
  var popper = getPopperClientRect(data.offsets.popper);
  var reference = data.offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var side = isVertical ? 'top' : 'left';
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowSize = getOuterSizes(arrow)[len];

  //
  // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
  }
  // bottom/right side
  if (reference[side] + arrowSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
  }

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowSize / 2;
  var sideValue = center - popper[side];

  // zhuxiankang add at 2018/06/01
  // if placement is top or bottom,
  // poper's width is smaller than reference width
  // arrow's left is poper's center
  if (!isVertical && popper.width < reference.width) {
    // chenguanbin edit at 2019/06/18
    // 根据弹出框和响应元素的相对位置，决定尖角的位置
    // 左边对齐（top-start），右边对齐（top-end），否则（top）
    if (popper.left === reference.left) {
      sideValue = 24;
    } else if (popper.right === reference.right) {
      sideValue = popper.width - 56;
    } else {
      sideValue = (popper.width - arrowSize) / 2;
    }
  }

  // prevent arrow from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowSize - 3, sideValue), 3);
  arrowStyle[side] = sideValue;
  arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

  data.offsets.arrow = arrowStyle;
  data.arrowElement = arrow;
  return data;
};

//
// Helpers
//

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  // NOTE: 1 DOM access here
  var _display = element.style.display;
  var _visibility = element.style.visibility;
  element.style.display = 'block';
  element.style.visibility = 'hidden';
  var calcWidthToForceRepaint = element.offsetWidth;

  // original method
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };

  // reset element styles
  element.style.display = _display;
  element.style.visibility = _visibility;
  return result;
}

/**
 * Get the opposite placement of the given one/
 * @function
 * @ignore
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Given the popper offsets, generate an output similar to getBoundingClientRect
 * @function
 * @ignore
 * @argument {Object} popperOffsets
 * @returns {Object} ClientRect like output
 */
function getPopperClientRect(popperOffsets) {
  var offsets = Object.assign({}, popperOffsets);
  offsets.right = offsets.left + offsets.width;
  offsets.bottom = offsets.top + offsets.height;
  return offsets;
}

/**
 * Given an array and the key to find, returns its index
 * @function
 * @ignore
 * @argument {Array} arr
 * @argument keyToFind
 * @returns index or null
 */
function getArrayKeyIndex(arr, keyToFind) {
  var i = 0;
  var key;
  for (key in arr) {
    if (arr[key] === keyToFind) {
      return i;
    }
    i++;
  }
  return null;
}

/**
 * Get CSS computed property of the given element
 * @function
 * @ignore
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  // NOTE: 1 DOM access here
  var css = window.getComputedStyle(element, null);
  return css[property];
}

/**
 * Returns the offset parent of the given element
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  return offsetParent === window.document.body || !offsetParent ? window.document.documentElement : offsetParent;
}

/**
 * Returns the scrolling parent of the given element
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getScrollParent(element) {
  var parent = element.parentNode;
  if (!parent) {
    return element;
  }
  if (parent === window.document) {
    // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
    // greater than 0 and return the proper element
    if (window.document.body.scrollTop) {
      return window.document.body;
    } else {
      return window.document.documentElement;
    }
  }

  // Firefox want us to check `-x` and `-y` variations as well
  if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
    // If the detected scrollParent is body, we perform an additional check on its parentNode
    // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
    // fixes issue #65
    return parent;
  }
  return getScrollParent(element.parentNode);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @function
 * @ignore
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  if (element === window.document.body) {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return element.parentNode ? isFixed(element.parentNode) : element;
}

/**
 * Set the style to the given popper
 * @function
 * @ignore
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
 */
function popper_setStyle(element, styles) {
  function is_numeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Check if the given variable is a function
 * @function
 * @ignore
 * @argument {*} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function popper_isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get the position of the given element, relative to its offset parent
 * @function
 * @ignore
 * @param {Element} element
 * @return {Object} position - Coordinates of the element and its `scrollTop`
 */
function getOffsetRect(element) {
  var elementRect = {
    width: element.offsetWidth,
    height: element.offsetHeight,
    left: element.offsetLeft,
    top: element.offsetTop
  };
  elementRect.right = elementRect.left + elementRect.width;
  elementRect.bottom = elementRect.top + elementRect.height;

  // position
  return elementRect;
}

/**
 * Get bounding client rect of given element
 * @function
 * @ignore
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();

  // whether the IE version is lower than 11
  var isIE = navigator.userAgent.indexOf('MSIE') != -1;

  // fix ie document bounding top always 0 bug
  var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
  return {
    left: rect.left,
    top: rectTop,
    right: rect.right,
    bottom: rect.bottom,
    width: rect.right - rect.left,
    height: rect.bottom - rectTop
  };
}

/**
 * Given an element and one of its parents, return the offset
 * @function
 * @ignore
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @return {Object} rect
 */
function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
  var elementRect = getBoundingClientRect(element);
  var parentRect = getBoundingClientRect(parent);
  if (fixed) {
    var scrollParent = getScrollParent(parent);
    parentRect.top += scrollParent.scrollTop;
    parentRect.bottom += scrollParent.scrollTop;
    parentRect.left += scrollParent.scrollLeft;
    parentRect.right += scrollParent.scrollLeft;
  }
  var rect = {
    top: elementRect.top - parentRect.top,
    left: elementRect.left - parentRect.left,
    bottom: elementRect.top - parentRect.top + elementRect.height,
    right: elementRect.left - parentRect.left + elementRect.width,
    width: elementRect.width,
    height: elementRect.height
  };
  return rect;
}

/**
 * Get the prefixed supported property name
 * @function
 * @ignore
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase)
 */
function getSupportedPropertyName(property) {
  var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];
  for (var i = 0; i < prefixes.length; i++) {
    var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
    if (typeof window.document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
 * objects to a target object. It will return the target object.
 * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
 * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @function
 * @ignore
 */
if (!Object.assign) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);
        var keysArray = Object.keys(nextSource);
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

// return Popper;
/* harmony default export */ var utils_popper = (Popper);
// }));
// CONCATENATED MODULE: ./src/utils/vue-popper.js
// import Vue from 'vue';

// import Popper from './popper';
// 这里注意要写成这种形式，否则webpack打包不识别externals，会打包进去
// 不要使用相对路径
// zhuxiankang add at 2019/01/08

// const PopperJS = Vue.prototype.$isServer ? function () {} : popper;
const PopperJS = utils_popper;
const stop = e => e.stopPropagation();

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
/* harmony default export */ var vue_popper = ({
  props: {
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    transition: String,
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },
  data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },
  watch: {
    value: {
      immediate: true,
      handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },
    showPopper(val) {
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },
  methods: {
    createPopper() {
      // if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }
      const options = this.popperOptions;
      const popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      let reference = this.referenceElm || this.reference || this.$refs.reference;
      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.$slots.reference[0].elm;
      }
      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }
      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(() => {
        this.$emit('created', this);
        this.resetTransformOrigin();
        this.$nextTick(this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = popup_manager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper() {
      this.popperJS ? this.popperJS.update() : this.createPopper();
    },
    doDestroy() {
      /* istanbul ignore if */
      if (this.showPopper || !this.popperJS) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin() {
      const placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      const placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      const origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) > -1 ? `center ${origin}` : `${origin} center`;
    },
    appendArrow(element) {
      let hash;
      if (this.appended) {
        return;
      }
      this.appended = true;
      for (const item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }
      const arrow = document.createElement('div');
      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },
  beforeDestroy() {
    this.doDestroy();
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },
  // call destroy in keep-alive mode
  deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/popover/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var mainvue_type_script_lang_js_ = ({
  name: 'ElPopover',
  mixins: [vue_popper],
  props: {
    trigger: {
      type: String,
      default: 'click',
      validator: value => ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1
    },
    contentDelay: {
      type: Number,
      default: 0
    },
    openDelay: {
      type: Number,
      default: 0
    },
    title: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    content: {
      type: String,
      default: null
    },
    reference: {
      type: null,
      default: null
    },
    popperClass: {
      type: String,
      default: null
    },
    width: {
      type: null,
      default: null
    },
    maxWidth: {
      type: null,
      default: null
    },
    // 最大宽度
    showHtml: {
      // 是否直接显示HTML
      type: Boolean,
      default: false
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    transition: {
      type: String,
      default: 'fade-in-linear'
    },
    offsetPlacement: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      showContent: true
    };
  },
  computed: {
    popoverStyle() {
      const ret = {};
      ret.width = (this.width + 'px').replace(/pxpx/, 'px');
      ret.maxWidth = (this.maxWidth + 'px').replace(/pxpx/, 'px');
      const gutter = 10; // 控件与元素间默认间距
      if (this.placement.indexOf('top') !== -1) {
        ret.marginBottom = this.offsetPlacement + gutter + 'px';
      } else if (this.placement.indexOf('bottom') !== -1) {
        ret.marginTop = this.offsetPlacement + gutter + 'px';
      } else if (this.placement.indexOf('left') !== -1) {
        ret.marginRight = this.offsetPlacement + gutter + 'px';
      } else if (this.placement.indexOf('right') !== -1) {
        ret.marginLeft = this.offsetPlacement + gutter + 'px';
      }
      return ret;
    }
  },
  watch: {
    showPopper(newVal) {
      newVal ? this.$emit('show') : this.$emit('hide');
    }
  },
  created() {
    if (this.contentDelay) this.showContent = false;
    setTimeout(() => {
      this.showContent = true;
    }, this.contentDelay);
  },
  mounted() {
    let reference = this.reference || this.$refs.reference;
    const popper = this.popper || this.$refs.popper;
    if (!reference && this.$slots.reference && this.$slots.reference[0]) {
      reference = this.referenceElm = this.$slots.reference[0].elm;
    }
    if (this.trigger === 'click') {
      on(reference, 'click', this.doToggle);
      on(document, 'click', this.handleDocumentClick);
    } else if (this.trigger === 'hover') {
      on(reference, 'mouseenter', this.handleMouseEnter);
      on(popper, 'mouseenter', this.handleMouseEnter);
      on(reference, 'mouseleave', this.handleMouseLeave);
      on(popper, 'mouseleave', this.handleMouseLeave);
    } else if (this.trigger === 'focus') {
      let found = false;
      if ([].slice.call(reference.children).length) {
        const children = reference.childNodes;
        const len = children.length;
        for (let i = 0; i < len; i++) {
          if (children[i].nodeName === 'INPUT' || children[i].nodeName === 'TEXTAREA') {
            on(children[i], 'focus', this.doShow);
            on(children[i], 'blur', this.doClose);
            found = true;
            break;
          }
        }
      }
      if (found) return;
      if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
        on(reference, 'focus', this.doShow);
        on(reference, 'blur', this.doClose);
      } else {
        on(reference, 'mousedown', this.doShow);
        on(reference, 'mouseup', this.doClose);
      }
    }
  },
  destroyed() {
    const reference = this.reference;
    off(reference, 'click', this.doToggle);
    off(reference, 'mouseup', this.doClose);
    off(reference, 'mousedown', this.doShow);
    off(reference, 'focus', this.doShow);
    off(reference, 'blur', this.doClose);
    off(reference, 'mouseleave', this.handleMouseLeave);
    off(reference, 'mouseenter', this.handleMouseEnter);
    off(document, 'click', this.handleDocumentClick);
  },
  methods: {
    doToggle() {
      this.showPopper = !this.showPopper;
    },
    doShow() {
      this.showPopper = true;
    },
    doClose() {
      this.showPopper = false;
    },
    handleMouseEnter() {
      clearTimeout(this._timer);
      if (this.openDelay) {
        this._timer = setTimeout(() => {
          this.showPopper = true;
        }, this.openDelay);
      } else {
        this.showPopper = true;
      }
    },
    handleMouseLeave() {
      clearTimeout(this._timer);
      this._timer = setTimeout(() => {
        this.showPopper = false;
      }, 200);
    },
    handleDocumentClick(e) {
      let reference = this.reference || this.$refs.reference;
      const popper = this.popper || this.$refs.popper;
      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }
      if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target)) {
        return;
      }
      this.showPopper = false;
    }
  }
});
// CONCATENATED MODULE: ./packages/popover/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_mainvue_type_script_lang_js_ = (mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/popover/src/main.vue





/* normalize component */

var main_component = normalizeComponent(
  src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_084ce9fc_render,
  mainvue_type_template_id_084ce9fc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var main = (main_component.exports);
// CONCATENATED MODULE: ./packages/popover/src/directive.js
/* harmony default export */ var directive = ({
  bind(el, binding, vnode) {
    vnode.context.$refs[binding.arg].$refs.reference = el;
  }
});
// CONCATENATED MODULE: ./packages/popover/index.js



external_vue_default.a.directive('popover', directive);

/* istanbul ignore next */
main.install = function (Vue) {
  Vue.directive('popover', directive);
  Vue.component(main.name, main);
};
main.directive = directive;
/* harmony default export */ var popover = (main);
// EXTERNAL MODULE: external "throttle-debounce/debounce"
var debounce_ = __webpack_require__("7435");
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce_);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/input/src/input.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ var inputvue_type_script_lang_js_ = ({
  name: 'ElInput',
  components: {
    ElPopover: popover
  },
  mixins: [emitter],
  inheritAttrs: false,
  // 只有input/textrear支持原生属性

  componentName: 'ElInput',
  props: {
    value: {
      type: [String, Number],
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    kind: {
      type: String,
      default: null
    },
    resize: {
      type: String,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    autofocus: {
      type: Boolean,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    unselectable: {
      type: String,
      default: null
    },
    clearable: {
      type: Boolean,
      default: null
    },
    select: {
      type: Boolean,
      default: null
    },
    suffixIcon: {
      type: String,
      default: null
    },
    prefixIcon: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'text'
    },
    name: {
      type: String,
      default: null
    },
    count: {
      type: Number,
      default: null
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    rows: {
      type: Number,
      default: 2
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: {
      type: String,
      default: null
    },
    step: {
      type: null,
      default: null
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    onIconClick: {
      type: Function,
      default: null
    },
    onMousedownClick: {
      type: Function,
      default: null
    },
    onMouseupClick: {
      type: Function,
      default: null
    },
    clearIconClick: {
      type: Function,
      default: null
    },
    // 提示信息，设置了tips才能显示popover
    tips: {
      type: String,
      default: null
    },
    // popover的最大宽度
    tipsMaxWidth: {
      type: null,
      default: 480 // 交互规范表单项tip最大宽度480，超出换行
    },
    // popover出现的位置
    tipsPlacement: {
      type: String,
      default: 'top-start'
    },
    // 出现位置的偏移量
    tipsOffset: {
      type: Number,
      default: 0
    },
    // popover触发方式
    tipsTrigger: {
      type: String,
      default: 'focus'
    },
    // popover触发方式
    tipsClass: {
      type: String,
      default: ''
    },
    dataPicker: {
      type: Boolean,
      default: false
    },
    debounce: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      textareaRect: {},
      textareaCalcStyle: {},
      prefixOffset: null,
      suffixOffset: null,
      tipsDisabled: true,
      ie: {},
      // ie下的时间定时器
      ie9: false,
      // 判断是否是ie9
      isFormItem: false,
      // 是否为表单元素
      isFocus: false,
      isHover: false,
      prefixWidth: null,
      suffixWidth: null
    };
  },
  computed: {
    inputStyle() {
      return {
        paddingLeft: this.prefixWidth ? `${this.prefixWidth + 8}px` : null,
        paddingRight: this.suffixWidth ? `${this.suffixWidth + (this.clearable ? 28 : 8)}px` : this.clearable ? '28px' : null
      };
    },
    validating() {
      return this.$parent.validateState === 'validating';
    },
    textareaStyle() {
      return merge({}, this.textareaCalcStyle, {
        resize: this.resize === '' || this.autosize ? 'both' : this.resize
      });
    },
    isGroup() {
      return this.$slots.prepend || this.$slots.append;
    },
    valueLength() {
      if (this.value) {
        return this.value.length;
      }
      return 0;
    },
    nativeInputValue() {
      return this.value === null || this.value === undefined ? '' : this.value;
    },
    total() {
      const num = this.count - this.valueLength;
      if (num < 0) {
        return 0;
      }
      return this.count - this.valueLength || 0;
    }
  },
  watch: {
    value(val) {
      this.$nextTick(this.resizeTextarea);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', [val]);
      }
    }
  },
  created() {
    this.$on('inputSelect', this.inputSelect);
    this.debouncedOnInputChange = this.debounce > 0 ? debounce_default()(this.debounce, e => {
      this.handleInput(e);
    }) : this.handleInput;
  },
  mounted() {
    if (this.type === 'textarea') {
      this.textareaRect = this.$refs.wrapper ? this.$refs.wrapper.getBoundingClientRect() : {};
      this.resizeTextarea();
    }
    if (this.$refs.prefix) {
      this.prefixWidth = this.$refs.prefix.getBoundingClientRect().width;
    }
    if (this.$refs.suffix) {
      this.suffixWidth = this.$refs.suffix.getBoundingClientRect().width;
    }
    if (this.isGroup) {
      this.prefixOffset = this.calcIconOffset('pre');
      this.suffixOffset = this.calcIconOffset('suf');
    }
    // ie9兼容
    if (navigator.appName === 'Microsoft Internet Explorer' && navigator.appVersion.split(';')[1].replace(/[ ]/g, '') === 'MSIE9.0' && !this.dataPicker) {
      this.ie9 = true;
    }
    // 影响switch beforeChange 事件 placeholder 可以为空
    // if (this.placeholder === '') {
    //   console.error('input的placeholder属性不能传空');
    // }
    this.isFormItem = !!this.findComponentUpward(this, 'ElFormItem');
  },
  methods: {
    /**
     * @author xuzilong
     * @desc 找到指定的父组件
     */
    findComponentUpward(context, componentName) {
      let parent = context.$parent;
      let name = parent.$options.name;
      while (parent && (!name || [componentName].indexOf(name) < 0)) {
        parent = parent.$parent;
        if (parent) name = parent.$options.name;
      }
      return parent;
    },
    handleBlur(event) {
      this.isFocus = false;
      this.$emit('blur', event);
      if (this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.blur', [this.value]);
      }
      if (this.tipsTrigger === 'focus') {
        this.tipsDisabled = true;
      }
      if (this.ie9) {
        clearTimeout(this.ie); // ie9兼容
        // document.removeEventListener('selectionchange', this.handleInput, false);
      }
    },
    inputSelect() {
      // TODO 这里不知道干啥用的，没改，请检查一下这里是否会有问题
      this.$refs.input.select();
    },
    resizeTextarea() {
      if (this.$isServer) return;
      var {
        autosize,
        type
      } = this;
      if (!autosize || type !== 'textarea') return;
      const minRows = autosize.minRows;
      const maxRows = autosize.maxRows;
      const maxWidth = autosize.maxWidth;
      this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, this.textareaRect, minRows, maxRows, maxWidth);
    },
    handleMouseenter() {
      this.isHover = true;
    },
    handleMouseout() {
      this.isHover = false;
    },
    handleFocus(event) {
      if (this.readonly) {
        event.preventDefault();
      }
      this.isFocus = true;
      this.$emit('focus', event);
      if (this.tips && this.tipsTrigger === 'focus') {
        this.tipsDisabled = false;
      }
      if (this.ie9) {
        this.ie = setInterval(this.handleInput, 200); // ie9兼容
        // document.addEventListener('selectionchange', this.handleInput, false);
      }
    },
    handleInput(event) {
      const value = event.target.value;
      if (value === this.nativeInputValue) return;
      this.$emit('input', value);
      this.$emit('change', value);
    },
    handleIconClick(event) {
      if (this.onIconClick) {
        this.onIconClick(event);
      }
      this.$emit('click', event);
    },
    handleMousedownClick(event) {
      if (this.onMousedownClick) {
        this.onMousedownClick(event);
      }
    },
    handleMouseupClick(event) {
      if (this.onMouseupClick) {
        this.onMouseupClick(event);
      }
    },
    handleClearClick(event) {
      if (!this.disabled) {
        if (this.clearIconClick) {
          this.clearIconClick(event);
        }
        this.deleteSelected(event);
        this.$emit('delete');
        this.$nextTick(() => {
          this.$refs.input.focus();
        });
      }
    },
    deleteSelected(event) {
      event.stopPropagation();
      this.$emit('input', '');
      this.$emit('clear');
    },
    calcIconOffset(place) {
      const pendantMap = {
        suf: 'append',
        pre: 'prepend'
      };
      const pendant = pendantMap[place];
      if (this.$slots[pendant]) {
        return {
          transform: `translateX(${place === 'suf' ? '-' : ''}${this.$el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`
        };
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/input/src/input.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_inputvue_type_script_lang_js_ = (inputvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/input/src/input.vue





/* normalize component */

var input_component = normalizeComponent(
  src_inputvue_type_script_lang_js_,
  inputvue_type_template_id_04d9a470_render,
  inputvue_type_template_id_04d9a470_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var input = (input_component.exports);
// CONCATENATED MODULE: ./packages/input/index.js


/* istanbul ignore next */
input.install = function (Vue) {
  Vue.component(input.name, input);
};
/* harmony default export */ var packages_input = (input);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=template&id=7354a657&
var select_dropdownvue_type_template_id_7354a657_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-select-dropdown",class:[{ 'is-multiple': _vm.$parent.multiple }, _vm.popperClass],style:({ minWidth: _vm.minWidth, maxWidth: _vm.maxWidth })},[_vm._t("default")],2)}
var select_dropdownvue_type_template_id_7354a657_staticRenderFns = []


// CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=template&id=7354a657&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var select_dropdownvue_type_script_lang_js_ = ({
  name: 'ElSelectDropdown',
  componentName: 'ElSelectDropdown',
  mixins: [vue_popper],
  props: {
    placement: {
      type: String,
      default: 'bottom-start'
    },
    boundariesPadding: {
      type: null,
      default: 0
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: null,
      default() {
        return {
          forceAbsolute: true,
          gpuAcceleration: false
        };
      }
    }
  },
  data() {
    return {
      minWidth: '',
      maxWidth: ''
    };
  },
  computed: {
    popperClass() {
      return this.$parent.popperClass;
    }
  },
  watch: {
    '$parent.inputWidth'() {
      const inputWidth = this.$parent.$el.getBoundingClientRect().width;
      this.minWidth = inputWidth + 'px';
      this.maxWidth = (this.$parent.maxWidth || inputWidth) + 'px';
    }
  },
  mounted() {
    this.referenceElm = this.$parent.$refs.reference.$el;
    this.$parent.popperElm = this.popperElm = this.$el;
    this.$on('updatePopper', () => {
      if (this.$parent.visible) this.updatePopper();
    });
    this.$on('destroyPopper', this.destroyPopper);
  }
});
// CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_select_dropdownvue_type_script_lang_js_ = (select_dropdownvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/select/src/select-dropdown.vue





/* normalize component */

var select_dropdown_component = normalizeComponent(
  src_select_dropdownvue_type_script_lang_js_,
  select_dropdownvue_type_template_id_7354a657_render,
  select_dropdownvue_type_template_id_7354a657_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var select_dropdown = (select_dropdown_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=template&id=119ea472&
var optionvue_type_template_id_119ea472_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],ref:"dom",staticClass:"el-select-dropdown__item",class:{
    selected: _vm.itemSelected,
    'is-disabled': _vm.disabled || _vm.groupDisabled || _vm.limitReached,
    'brand-font': _vm.created,
    radio: !_vm.parent.multiple,
    hover: _vm.parent.hoverIndex === _vm.index
  },attrs:{"title":_vm.showTitle ? _vm.currentLabel : ''},on:{"mouseenter":_vm.hoverItem,"click":function($event){$event.stopPropagation();$event.preventDefault();return _vm.selectOptionClick.apply(null, arguments)}}},[(_vm.parent.multiple)?_c('span',{staticClass:"el-select_check-box-wrap"},[_c('el-checkbox',{ref:"checkbox",model:{value:(_vm.itemSelected),callback:function ($$v) {_vm.itemSelected=$$v},expression:"itemSelected"}})],1):_vm._e(),_vm._t("default",function(){return [(!_vm.showHtml)?_c('span',{class:{
        'brand-font': _vm.created
      }},[_vm._v(" "+_vm._s(_vm.currentLabel)+" ")]):_vm._e(),(_vm.showLabel && _vm.showHtml)?_c('span',{class:{
        'brand-font': _vm.created
      },domProps:{"innerHTML":_vm._s(_vm.showLabel)}}):_vm._e(),(!_vm.showLabel && _vm.showHtml)?_c('span',{class:{
        'brand-font': _vm.created
      },domProps:{"innerHTML":_vm._s(_vm.currentLabel)}}):_vm._e()]})],2)}
var optionvue_type_template_id_119ea472_staticRenderFns = []


// CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=template&id=119ea472&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=template&id=ae3647e8&
var checkboxvue_type_template_id_ae3647e8_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox",class:[
    _vm.border && _vm.checkboxSize ? 'el-checkbox--' + _vm.checkboxSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-bordered': _vm.border },
    { 'is-checked': _vm.isChecked }
  ],attrs:{"id":_vm.id,"aria-checked":_vm.indeterminate ? 'mixed' : _vm.isChecked,"aria-disabled":_vm.isDisabled,"role":"checkbox"}},[_c('span',{staticClass:"el-checkbox__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.isChecked && !_vm.indeterminate,
      'is-indeterminate': _vm.indeterminate,
      'is-focus': _vm.focus
    },attrs:{"aria-checked":"mixed"}},[_c('span',{staticClass:"el-checkbox__inner"},[(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel,"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"disabled":_vm.isDisabled,"name":_vm.name,"type":"checkbox"},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}),_c('h-svg-icon',{attrs:{"size":14,"svgs":_vm.ctrl_tick}})],1)]),(_vm.icon)?_c('span',{staticClass:"el-checkbox__icon"},[_c('i',{class:_vm.icon})]):_vm._e(),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox__label",attrs:{"title":_vm.titleLabel},on:{"mouseover":_vm.handleMouseover}},[_vm._t("default"),(!_vm.$slots.default && _vm.showLabel)?[_vm._v(" "+_vm._s(_vm.label)+" ")]:_vm._e()],2):_vm._e()])}
var checkboxvue_type_template_id_ae3647e8_staticRenderFns = []


// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=template&id=ae3647e8&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/svg-icon/src/svg-icon.vue?vue&type=template&id=71d85759&
var svg_iconvue_type_template_id_71d85759_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-svg-icon-wrapper",class:[_vm.offline && 'is-offline', _vm.active && 'is-active'],style:(_vm.wrapperStyle)},[(_vm.svgs || _vm.svgs.length)?_vm._l((_vm.icons),function(item,index){return _c('div',{key:index,staticClass:"h-svg-icon",class:[_vm.svgColors[index] && 'is-show-color', _vm.svgClasses[index]],style:({ color: _vm.svgColors[index] }),domProps:{"innerHTML":_vm._s(item)}})}):_vm._t("default")],2)}
var svg_iconvue_type_template_id_71d85759_staticRenderFns = []


// CONCATENATED MODULE: ./packages/svg-icon/src/svg-icon.vue?vue&type=template&id=71d85759&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/svg-icon/src/svg-icon.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var svg_iconvue_type_script_lang_js_ = ({
  name: 'HSvgIcon',
  props: {
    svgs: {
      type: [String, Array],
      default: ''
    },
    size: {
      type: [Number, String],
      default: null
    },
    offline: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    },
    colors: {
      type: [String, Array],
      default: ''
    },
    classes: {
      type: [String, Array],
      default: ''
    }
  },
  data() {
    return {
      icons: this.svgs || this.svgs.length ? this.getIcons() : [],
      svgColors: this.colors || this.colors.length ? this.getColors() : [],
      svgClasses: this.classes || this.classes.length ? this.getClasses() : []
    };
  },
  computed: {
    wrapperStyle() {
      if (this.size) return {
        'font-size': `${parseInt(this.size)}px`
      };else return {};
    }
  },
  watch: {
    svgs() {
      this.icons = this.getIcons();
    },
    colors() {
      this.svgColors = this.getColors();
    },
    classes() {
      this.svgClasses = this.getClasses();
    }
  },
  methods: {
    getIcons() {
      const iconsArray = [];
      if (Array.isArray(this.svgs)) {
        for (const icon of this.svgs) {
          iconsArray.push(this.judgeSVGType(icon));
        }
      } else {
        iconsArray.push(this.judgeSVGType(this.svgs));
      }
      return iconsArray;
    },
    judgeSVGType(icon) {
      if (icon.default) icon = icon.default;
      if (icon.includes('</svg>') || icon.includes('.svg')) {
        // 为svg文件
        return icon;
      } else {
        return icon;
      }
    },
    getColors() {
      const colorArray = [];
      if (Array.isArray(this.colors)) {
        for (const color of this.colors) {
          colorArray.push(color);
        }
      } else {
        colorArray.push(this.colors);
      }
      return colorArray;
    },
    getClasses() {
      const classArray = [];
      if (Array.isArray(this.classes)) {
        for (const className of this.classes) {
          classArray.push(className);
        }
      } else {
        classArray.push(this.classes);
      }
      return classArray;
    }
  }
});
// CONCATENATED MODULE: ./packages/svg-icon/src/svg-icon.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_svg_iconvue_type_script_lang_js_ = (svg_iconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/svg-icon/src/svg-icon.vue





/* normalize component */

var svg_icon_component = normalizeComponent(
  src_svg_iconvue_type_script_lang_js_,
  svg_iconvue_type_template_id_71d85759_render,
  svg_iconvue_type_template_id_71d85759_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var svg_icon = (svg_icon_component.exports);
// CONCATENATED MODULE: ./packages/svg-icon/index.js


/* istanbul ignore next */
svg_icon.install = function (Vue) {
  Vue.component(svg_icon.name, svg_icon);
};
/* harmony default export */ var packages_svg_icon = (svg_icon);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var checkboxvue_type_script_lang_js_ = ({
  name: 'ElCheckbox',
  components: {
    hSvgIcon: packages_svg_icon
  },
  mixins: [emitter],
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },
  componentName: 'ElCheckbox',
  props: {
    value: {
      type: [String, Number, Boolean],
      default: undefined
    },
    label: {
      type: [String, Number, Boolean],
      default: undefined
    },
    indeterminate: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    checked: {
      type: Boolean,
      default: null
    },
    name: {
      type: String,
      default: undefined
    },
    trueLabel: {
      type: [String, Number],
      default: undefined
    },
    falseLabel: {
      type: [String, Number],
      default: undefined
    },
    id: {
      type: String,
      default: undefined
    } /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */,
    controls: {
      type: String,
      default: undefined
    } /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */,
    border: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: 'medium'
    },
    icon: {
      type: String,
      default: undefined
    },
    showLabel: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false,
      titleLabel: '',
      ctrl_tick: `<?xml version="1.0" encoding="UTF-8"?>
        <svg viewBox="5 5 14 14" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <!-- Generator: Sketch 54.1 (76490) - https://sketchapp.com -->
            <desc>Created with Sketch.</desc>
            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                <g class="el-checkbox__tick">
                    <g transform="translate(5.000000, 5.000000)">
                        <rect fill-opacity="0" x="0" y="0" width="14" height="14" rx="1" ></rect>
                        <g transform="translate(2.000000, 3.000000)">
                            <path d="M3.8044344,5.5168557 L8.6780673,0.76615083 C8.9540622,0.44048717 9.4314325,0.40937065 9.7443038,0.69665013 C10.0571751,0.98392961 10.0870694,1.4808182 9.8110745,1.80648186 L4.3639727,7.2338586 C4.060806,7.591584 3.5239337,7.5881988 3.2249529,7.2266766 L0.18291667,4.5483022 C-0.08926753,4.2191821 -0.05359216,3.7227069 0.26259985,3.4393939 C0.57879185,3.156081 1.055765,3.193215 1.3279492,3.5223351 L3.8044344,5.5168557 Z"></path>
                        </g>
                    </g>
                </g>
            </g>
        </svg>`
    };
  },
  computed: {
    model: {
      get() {
        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set(val) {
        if (this.isGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);
          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);
          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
          this.selfModel = val;
        }
      }
    },
    isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
      return false;
    },
    isGroup() {
      let parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          this._checkboxGroup = parent; // eslint-disable-line
          return true;
        }
      }
      return false;
    },
    store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    isDisabled() {
      return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled || this._checkboxGroup.value.length === this._checkboxGroup.min && this._checkboxGroup.value.includes(this.label) || this._checkboxGroup.value.length === this._checkboxGroup.max && !this._checkboxGroup.value.includes(this.label) : this.disabled || (this.elForm || {}).disabled;
    },
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxSize() {
      const temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
    }
  },
  watch: {
    value(value) {
      this.dispatch('ElFormItem', 'el.form.change', value);
    }
  },
  created() {
    this.checked && this.addToStore();
  },
  mounted() {
    // 为indeterminate元素 添加aria-controls 属性
    if (this.indeterminate) {
      this.$el.setAttribute('aria-controls', this.controls);
    }
  },
  methods: {
    addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    // 鼠标悬停显示Lable
    // 移除过滤条件，个人认为比较多余，就直接做成悬浮展示 xx 2020/5/29
    handleMouseover(e) {
      const t = e.target;
      if (t.tagName === 'SPAN') {
        // if (t.scrollWidth >= t.offsetWidth) {
        this.titleLabel = t.innerText;
        // } else {
        //   this.titleLabel = '';
        // }
      }
    },
    handleChange(ev) {
      if (this.isLimitExceeded) {
        // 如果超出限制，重置下dom状态
        ev.target.checked = !ev.target.checked;
        return;
      }
      let value;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(() => {
        if (this.isGroup) {
          this.dispatch('ElCheckboxGroup', 'change', [this._checkboxGroup.value]);
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_checkboxvue_type_script_lang_js_ = (checkboxvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.vue





/* normalize component */

var checkbox_component = normalizeComponent(
  src_checkboxvue_type_script_lang_js_,
  checkboxvue_type_template_id_ae3647e8_render,
  checkboxvue_type_template_id_ae3647e8_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_checkbox = (checkbox_component.exports);
// CONCATENATED MODULE: ./packages/checkbox/index.js


/* istanbul ignore next */
src_checkbox.install = function (Vue) {
  Vue.component(src_checkbox.name, src_checkbox);
};
/* harmony default export */ var packages_checkbox = (src_checkbox);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


// import ElTooltip from 'hui/packages/tooltip';


/* harmony default export */ var optionvue_type_script_lang_js_ = ({
  name: 'ElOption',
  components: {
    ElCheckbox: packages_checkbox
  },
  mixins: [emitter],
  componentName: 'ElOption',
  props: {
    value: {
      type: null,
      required: true
    },
    label: {
      type: [String, Number],
      default: null
    },
    created: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    showHtml: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      showTitle: false,
      showLabel: null
    };
  },
  computed: {
    isObject() {
      return Object.prototype.toString.call(this.value).toLowerCase() === '[object object]';
    },
    currentLabel() {
      return this.label || (this.isObject ? '' : this.value);
    },
    currentValue() {
      return this.value || this.label || '';
    },
    parent() {
      let result = this.$parent;
      while (!result.isSelect) {
        result = result.$parent;
      }
      return result;
    },
    itemSelected: {
      get: function () {
        if (!this.parent.multiple) {
          return this.isEqual(this.value, this.parent.value);
        } else {
          return this.contains(this.parent.value, this.value);
        }
      },
      set: function () {}
    },
    limitReached() {
      if (this.parent.multiple) {
        return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
      } else {
        return false;
      }
    }
  },
  watch: {
    currentLabel() {
      if (!this.created && !this.parent.remote) {
        this.dispatch('ElSelect', 'setSelected');
      }
    },
    value() {
      if (!this.created && !this.parent.remote) {
        this.dispatch('ElSelect', 'setSelected');
      }
    }
  },
  created() {
    this.parent.options.push(this);
    this.parent.cachedOptions.push(this);
    this.parent.optionsCount++;
    this.parent.filteredOptionsCount++;
    this.index = this.parent.options.indexOf(this);
    this.$on('queryChange', this.queryChange);
    this.$on('handleGroupDisabled', this.handleGroupDisabled);
    this.$on('resetIndex', this.resetIndex);
  },
  beforeDestroy() {
    this.dispatch('ElSelect', 'onOptionDestroy', this);
  },
  methods: {
    isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        const valueKey = this.parent.valueKey;
        return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
      }
    },
    contains(arr = [], target) {
      if (!this.isObject) {
        return arr.indexOf(target) > -1;
      } else {
        const valueKey = this.parent.valueKey;
        return arr.some(item => {
          return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
        });
      }
    },
    handleGroupDisabled(val) {
      this.groupDisabled = val;
    },
    hoverItem() {
      this.showTitle = this.$refs.dom.clientWidth < this.$refs.dom.scrollWidth;
      if (!this.disabled && !this.groupDisabled) {
        this.parent.hoverIndex = this.parent.options.indexOf(this);
      }
      if (this.disabled) {
        this.parent.hoverIndex = -1;
      }
    },
    selectOptionClick() {
      if (this.disabled !== true && this.groupDisabled !== true) {
        this.dispatch('ElSelect', 'handleOptionClick', this);
      }
    },
    queryChange(query) {
      // query 里如果有正则中的特殊字符，需要先将这些字符转义
      const parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
      this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
      if (!this.visible) {
        this.parent.filteredOptionsCount--;
      } else {
        if (this.created) {
          this.showLabel = query;
          return;
        }
        if (parsedQuery) {
          this.showLabel = this.currentLabel.replace(new RegExp(parsedQuery, 'g'), "<font class='brand-font'>" + query + '</font>');
        } else {
          this.showLabel = null;
        }
      }
    },
    resetIndex() {
      this.$nextTick(() => {
        this.index = this.parent.options.indexOf(this);
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/select/src/option.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_optionvue_type_script_lang_js_ = (optionvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/select/src/option.vue





/* normalize component */

var option_component = normalizeComponent(
  src_optionvue_type_script_lang_js_,
  optionvue_type_template_id_119ea472_render,
  optionvue_type_template_id_119ea472_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_option = (option_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tag/src/tag.vue?vue&type=template&id=a1768916&
var tagvue_type_template_id_a1768916_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.disableTransitions ? '' : 'el-zoom-in-center'}},[_c('span',{staticClass:"el-tag",class:[
      _vm.type ? 'el-tag--' + _vm.type : '',
      _vm.size ? ("el-tag--" + _vm.size) : '',
      _vm.maxWidth ? "el-tag--maxwidth" : '',
      { 'is-hit': _vm.hit },
      _vm.color ? 'el-tag--custom--color' : '',
      _vm.closable ? 'el-tag--closable' : ''
    ],style:([{ backgroundColor: _vm.color }]),attrs:{"title":_vm.title}},[_c('span',{class:[_vm.maxWidth ? "el-tag--maxwidth" : ''],style:([
        _vm.maxWidth ? { 'max-width': _vm.maxWidth, display: 'inline-block' } : ''
      ])},[_vm._t("default")],2),(_vm.closable)?_c('i',{staticClass:"el-tag__close h-icon-close",on:{"click":_vm.handleClose}}):_vm._e()])])}
var tagvue_type_template_id_a1768916_staticRenderFns = []


// CONCATENATED MODULE: ./packages/tag/src/tag.vue?vue&type=template&id=a1768916&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tag/src/tag.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var tagvue_type_script_lang_js_ = ({
  name: 'ElTag',
  props: {
    text: {
      type: String,
      default: null
    },
    closable: {
      type: Boolean,
      default: null
    },
    type: {
      type: String,
      default: null
    },
    hit: {
      type: Boolean,
      default: null
    },
    disableTransitions: {
      type: Boolean,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: ''
    },
    maxWidth: {
      type: String,
      default: '200px'
    },
    title: {
      type: String,
      default: ''
    }
  },
  methods: {
    handleClose(event) {
      this.$emit('close', event);
    }
  }
});
// CONCATENATED MODULE: ./packages/tag/src/tag.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tagvue_type_script_lang_js_ = (tagvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tag/src/tag.vue





/* normalize component */

var tag_component = normalizeComponent(
  src_tagvue_type_script_lang_js_,
  tagvue_type_template_id_a1768916_render,
  tagvue_type_template_id_a1768916_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tag = (tag_component.exports);
// CONCATENATED MODULE: ./packages/tag/index.js


/* istanbul ignore next */
tag.install = function (Vue) {
  Vue.component(tag.name, tag);
};
/* harmony default export */ var packages_tag = (tag);
// EXTERNAL MODULE: external "resize-observer-polyfill"
var external_resize_observer_polyfill_ = __webpack_require__("a1cc");
var external_resize_observer_polyfill_default = /*#__PURE__*/__webpack_require__.n(external_resize_observer_polyfill_);

// CONCATENATED MODULE: ./src/utils/resize-event.js

const resize_event_isServer = typeof window === 'undefined';

/* istanbul ignore next */
const resizeHandler = function (entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach(fn => {
        fn();
      });
    }
  }
};

/* istanbul ignore next */
const addResizeListener = function (element, fn) {
  if (resize_event_isServer) return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new external_resize_observer_polyfill_default.a(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn);
};

/* istanbul ignore next */
const removeResizeListener = function (element, fn) {
  if (!element || !element.__resizeListeners__) return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
  if (!element.__resizeListeners__.length) {
    element.__ro__.disconnect();
  }
};
// CONCATENATED MODULE: ./packages/scrollbar/src/util.js
const BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    paddingPosition: 'paddingBottom',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top',
    clientSize: 'clientHeight'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    paddingPosition: 'paddingRight',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left',
    clientSize: 'clientWidth'
  }
};
function renderThumbStyle({
  size,
  bar,
  minLength,
  railSize,
  percent,
  wrap
}) {
  const style = {};
  let translate;
  const _size = typeof size !== 'number' ? +size.replace('%', '') : minLength;
  /**
   * el-time-picker使用el-scrollbar组件，
   * 当el-time-picker展开时，railSize === 0，导致计算出来的translate值不正确，
   * 所以这里单独对railSize === 0 时做处理，其实 else if 和 else 分支也可以直接使用这个逻辑
   */
  if (railSize === 0) {
    const {
      scrollTop = 0,
      scrollLeft = 0,
      clientHeight = 1,
      clientWidth = 1
    } = wrap || {};
    const val = bar.axis === 'Y' ? scrollTop * 100 / clientHeight : scrollLeft * 100 / clientWidth;
    translate = `translate${bar.axis}(${val}%)`;
    style[bar.size] = size;
  } else if (railSize * _size / 100 < minLength) {
    const barSize = minLength;
    translate = `translate${bar.axis}(${(railSize - barSize) * percent / barSize * 100}%)`;
    style[bar.size] = barSize + 'px';
  } else {
    const barSize = _size / 100 * railSize;
    translate = `translate${bar.axis}(${(railSize - barSize) * percent / barSize * 100}%)`;
    style[bar.size] = size;
  }
  style.transform = translate;
  style.msTransform = translate;
  style.webkitTransform = translate;
  return style;
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/scrollbar/src/bar.vue?vue&type=script&lang=js&



/* istanbul ignore next */
/* harmony default export */ var barvue_type_script_lang_js_ = ({
  name: 'Bar',
  props: {
    vertical: {
      type: Boolean,
      default: null
    },
    overflow: {
      type: String,
      default: 'auto'
    },
    overflowX: {
      type: String,
      default: 'auto'
    },
    overflowY: {
      type: String,
      default: 'auto'
    },
    size: {
      type: [String, Number],
      default: null
    },
    percent: {
      type: Number,
      default: null
    },
    width: {
      type: Number,
      default: null
    },
    opacity: {
      type: Number,
      default: null
    },
    pieceOpacity: {
      type: Number,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    pieceColor: {
      type: String,
      default: null
    },
    minLength: {
      type: Number,
      default: null
    }
  },
  data() {
    return {
      isMousewheel: false,
      timer: null,
      prevEvent: null
    };
  },
  computed: {
    bar() {
      return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
    },
    wrap() {
      return this.$parent.wrap;
    }
  },
  destroyed() {
    off(document, 'mouseup', this.mouseUpDocumentHandler);
  },
  methods: {
    handleMousewheel() {
      if (this.isMousewheel) {
        return;
      }
      this.isMousewheel = true;
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.isMousewheel = false;
      }, 500);
    },
    handleMouseleave() {
      this.isMousewheel = false;
    },
    clickThumbHandler(e) {
      this.prevEvent = e;
      this.startDrag(e);
      if (e.ctrlKey || e.button === 2) {
        return;
      }
      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
    },
    clickTrackHandler(e) {
      const offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
      const thumbHalf = this.$refs.thumb[this.bar.offset] / 2;

      // 计算 thumb 的 percent 时
      // 除数应当为 railSize - barSize
      const thumbPositionPercentage = (offset - thumbHalf) * 100 / (this.$refs.rail[this.bar.offset] - this.$refs.thumb[this.bar.offset]);
      this.wrap[this.bar.scroll] = thumbPositionPercentage * (this.wrap[this.bar.scrollSize] - this.wrap[this.bar.clientSize]) / 100;
    },
    startDrag(e) {
      e.stopImmediatePropagation();
      this.cursorDown = true;
      on(document, 'mousemove', this.mouseMoveDocumentHandler);
      on(document, 'mouseup', this.mouseUpDocumentHandler);
      document.onselectstart = () => false;
    },
    mouseMoveDocumentHandler(e) {
      if (this.prevEvent.clientX === e.clientX && this.prevEvent.clientY === e.clientY) {
        return;
      }
      if (this.cursorDown === false) return;
      // 防止选中滚动条的情况下拖动滚动条
      if (window.getSelection) {
        const selection = window.getSelection();
        if (selection.type === 'Range' && selection.getRangeAt(0).endContainer.className === 'el-scrollbar__thumb') {
          return;
        }
      }
      const prevPage = this[this.bar.axis];
      if (!prevPage) return;
      const offset = (this.$refs.rail.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;
      const thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;

      // 计算 thumb 的 percent 时
      // 除数应当为 railSize - barSize
      const thumbPositionPercentage = (offset - thumbClickPosition) * 100 / (this.$refs.rail[this.bar.offset] - this.$refs.thumb[this.bar.offset]);
      this.wrap[this.bar.scroll] = thumbPositionPercentage * (this.wrap[this.bar.scrollSize] - this.wrap[this.bar.clientSize]) / 100;
    },
    mouseUpDocumentHandler() {
      this.cursorDown = false;
      this[this.bar.axis] = 0;
      off(document, 'mousemove', this.mouseMoveDocumentHandler);
      document.onselectstart = null;
    },
    getBarStyle(type) {
      const style = {};
      const railSize = this.$refs.rail && this.$refs.rail.getBoundingClientRect()[this.bar.size];
      const setVisible = () => {
        style.visibility = 'visible';
      };
      if (type === 'bar') {
        const {
          bar,
          width,
          pieceColor,
          pieceOpacity,
          vertical,
          overflow,
          overflowX,
          overflowY
        } = this;
        if (pieceOpacity) {
          style.opacity = pieceOpacity;
        }
        if (vertical && (overflowY === 'scroll' || overflow === 'scroll')) {
          setVisible();
        } else if (overflowX === 'scroll' || overflow === 'scroll') {
          setVisible();
        }
        if (width) {
          style[bar.key === 'horizontal' ? 'height' : 'width'] = width + 'px';
        }
        if (pieceColor) {
          style['background-color'] = pieceColor;
        }
        // const { _sizeMinheight, minLength } = this;
        // if (_sizeMinheight && _sizeMinheight !== 1) {
        //   // 修补滚动条放大后的影响，需要补上原有的2px
        //   style[this.bar.paddingPosition] =
        //     minLength * (1 - _sizeMinheight) + 2 + 'px';
        // }
      } else {
        const {
          size,
          bar,
          color,
          opacity,
          percent,
          minLength
        } = this;
        if (opacity) style.opacity = opacity;
        if (color) style['background-color'] = color;
        Object.assign(style, renderThumbStyle.call(this, {
          size,
          bar,
          minLength,
          railSize,
          percent,
          wrap: this.wrap // 滚动容器
        }));
      }
      return style;
    }
  },
  render() {
    const h = arguments[0];
    const {
      bar
    } = this;
    return h("div", {
      "class": ['el-scrollbar__bar', 'is-' + bar.key, {
        'is-mousewheel': this.isMousewheel
      }],
      "on": {
        "mousewheel": this.handleMousewheel,
        "mouseleave": this.handleMouseleave,
        "mousedown": this.clickTrackHandler
      },
      "style": this.getBarStyle('bar')
    }, [h("div", {
      "ref": 'rail',
      "class": 'el-scrollbar__rail'
    }, [h("div", {
      "ref": 'thumb',
      "class": 'el-scrollbar__thumb',
      "on": {
        "mousedown": this.clickThumbHandler
      },
      "style": this.getBarStyle('thumb')
    })])]);
  }
});
// CONCATENATED MODULE: ./packages/scrollbar/src/bar.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_barvue_type_script_lang_js_ = (barvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/scrollbar/src/bar.vue
var bar_render, bar_staticRenderFns




/* normalize component */

var bar_component = normalizeComponent(
  src_barvue_type_script_lang_js_,
  bar_render,
  bar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_bar = (bar_component.exports);
// EXTERNAL MODULE: external "throttle-debounce/throttle"
var throttle_ = __webpack_require__("1e79");
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle_);

// CONCATENATED MODULE: ./src/utils/scroll-to.js
const scrollTo = (element, to, duration, isLeft = false) => {
  const requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
    return setTimeout(arguments[0], 10);
  };
  let scrollDirection;
  if (isLeft) {
    scrollDirection = 'scrollLeft';
  } else {
    scrollDirection = 'scrollTop';
  }
  // jump to target if duration zero
  if (duration <= 0) {
    element[scrollDirection] = to;
    return;
  }
  const difference = to - element[scrollDirection];
  const perTick = difference / duration * 10;
  requestAnimationFrame(() => {
    element[scrollDirection] += perTick;
    if (element[scrollDirection] === to) return;
    scrollTo(element, to, duration - 10, isLeft);
  });
};
/* harmony default export */ var scroll_to = (scrollTo);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/scrollbar/src/main.vue?vue&type=script&lang=js&
// reference https://github.com/noeldelgado/gemini-scrollbar/blob/master/index.js







/* istanbul ignore next */
/* harmony default export */ var scrollbar_src_mainvue_type_script_lang_js_ = ({
  name: 'ElScrollbar',
  components: {
    Bar: src_bar
  },
  props: {
    native: {
      type: Boolean,
      default: null
    },
    extrusion: {
      type: Boolean,
      default: false
    },
    overflow: {
      type: String,
      default: 'auto'
    },
    overflowX: {
      type: String,
      default: 'auto'
    },
    overflowY: {
      type: String,
      default: 'auto'
    },
    size: {
      type: Number,
      default: 4
    },
    // 滚动条的宽度
    opacity: {
      type: Number,
      default: 1
    },
    // 滚动条透明度
    pieceOpacity: {
      type: Number,
      default: 1
    },
    // 轨道透明度
    color: {
      type: String,
      default: null
    },
    // 滚动条颜色，支持16进制颜色、rgb和rgba
    pieceColor: {
      type: String,
      default: null
    },
    // 轨道颜色，默认透明即同容器背景色，支持16进制颜色、rgb和rgba
    wrapClass: {
      type: [Object, String],
      default: null
    },
    wrapStyle: {
      type: [Object, Array, String],
      default: () => {}
    },
    viewClass: {
      type: [Object, String],
      default: null
    },
    viewStyle: {
      type: [Object, Array, String],
      default: () => {}
    },
    noresize: {
      type: Boolean,
      default: false
    },
    // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
    tag: {
      type: String,
      default: 'div'
    },
    minLength: {
      // 滚动条最小长度
      type: Number,
      default: 24
    }
  },
  data() {
    return {
      sizeWidth: this.minLength,
      sizeHeight: this.minLength,
      percentX: 0,
      percentY: 0,
      gutter: 0,
      position: null
    };
  },
  computed: {
    wrap() {
      return this.$refs.wrap;
    },
    isDoubleScroll() {
      return this.showHorizontal && this.showVertical;
    },
    showHorizontal() {
      return this.overflow !== 'visible' && this.overflow !== 'hidden' && this.overflowX !== 'visible' && this.overflowX !== 'hidden' && this.sizeWidth !== this.minLength;
    },
    showVertical() {
      return this.overflow !== 'visible' && this.overflow !== 'hidden' && this.overflowY !== 'visible' && this.overflowY !== 'hidden' && this.sizeHeight !== this.minLength;
    }
  },
  mounted() {
    if (this.native) return;
    this.$nextTick(this.update);
    if (!this.noresize) {
      addResizeListener(this.$refs.wrap, this.throttleUpdate);
      addResizeListener(this.$refs.resize, this.throttleUpdate);
    }
    this.position = getStyle(this.wrap, 'position');
  },
  beforeDestroy() {
    if (this.native) return;
    if (!this.noresize) {
      removeResizeListener(this.$refs.wrap, this.throttleUpdate);
      removeResizeListener(this.$refs.resize, this.throttleUpdate);
    }
  },
  methods: {
    handleScroll() {
      const wrap = this.wrap;
      const percentX = wrap.scrollLeft / (wrap.scrollWidth - wrap.clientWidth);
      const percentY = wrap.scrollTop / (wrap.scrollHeight - wrap.clientHeight);
      this.percentX = percentX;
      this.percentY = percentY;
      const scrollValue = {
        scrollLeft: wrap.scrollLeft,
        scrollTop: wrap.scrollTop,
        percentX,
        percentY
      };
      this.$emit('on-scrolling-x', scrollValue);
      this.$emit('on-scrolling-y', scrollValue);
      this.$emit('on-scrolling', scrollValue);
    },
    throttleUpdate() {
      throttle_default()(500, () => this.update(true))();
    },
    update(isThrottle) {
      this.$nextTick(() => {
        const wrap = this.wrap;
        if (!wrap) return;
        // 重新计算滚动条宽度
        this.gutter = scrollbar_width(true);
        const heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
        const widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;
        this.sizeHeight = heightPercentage < 99 ? heightPercentage + '%' : this.minLength;
        this.sizeWidth = widthPercentage < 99 ? widthPercentage + '%' : this.minLength;
        this.$emit('on-scrollbar-x', this.showHorizontal);
        this.$emit('on-scrollbar-y', this.showVertical);
      });
    },
    setScroll(top = -1, left = -1, duration = 120) {
      if (top > -1) {
        scroll_to(this.wrap, top, duration);
      }
      if (left > -1) {
        scroll_to(this.wrap, left, duration, true);
      }
      this.update();
    }
  },
  render(h) {
    let style = this.wrapStyle || {}; // wrapStyle 可能是 undefined，附一个默认值

    if (this.gutter) {
      const gutterWidth = `-${this.gutter}px`;
      const gutterStyle = `margin-bottom: ${gutterWidth}; margin-right: ${gutterWidth};`;
      if (Array.isArray(this.wrapStyle)) {
        style = toObject(this.wrapStyle);
        style.marginRight = style.marginBottom = gutterWidth;
      } else if (typeof this.wrapStyle === 'string') {
        style += gutterStyle;
      } else {
        style = Object.keys(style).map(key => `${key}: ${style[key]};`).join('');
        style += gutterStyle;
      }
      if (this.extrusion) {
        style += 'padding-right: 12px;';
      }
    }
    const view = h(this.tag, {
      class: ['el-scrollbar__view', this.viewClass],
      style: this.viewStyle,
      ref: 'resize'
    }, this.$slots.default);
    const wrap = h("div", {
      "ref": 'wrap',
      "style": style,
      "on": {
        "scroll": this.handleScroll
      },
      "class": [this.wrapClass, 'el-scrollbar__wrap', this.gutter ? '' : 'el-scrollbar__wrap--hidden-default']
    }, [[view]]);
    let nodes;
    if (!this.native) {
      nodes = [wrap, h(src_bar, {
        "ref": 'horizontal',
        "directives": [{
          name: "show",
          value: this.showHorizontal
        }],
        "attrs": {
          "percent": this.percentX,
          "size": this.sizeWidth,
          "width": this.size + 8,
          "opacity": this.opacity,
          "pieceOpacity": this.pieceOpacity,
          "color": this.color,
          "pieceColor": this.pieceColor,
          "overflow": this.overflow,
          "overflowX": this.overflowX,
          "overflowY": this.overflowY,
          "minLength": this.minLength
        }
      }), h(src_bar, {
        "ref": 'vertical',
        "directives": [{
          name: "show",
          value: this.showVertical
        }],
        "attrs": {
          "vertical": true,
          "percent": this.percentY,
          "size": this.sizeHeight,
          "width": this.size + 8,
          "opacity": this.opacity,
          "pieceOpacity": this.pieceOpacity,
          "pieceColor": this.pieceColor,
          "color": this.color,
          "overflow": this.overflow,
          "overflowX": this.overflowX,
          "overflowY": this.overflowY,
          "minLength": this.minLength
        }
      })];
    } else {
      nodes = [h("div", {
        "ref": 'wrap',
        "class": [this.wrapClass, 'el-scrollbar__wrap'],
        "style": style
      }, [[view]])];
    }
    return h('div', {
      class: ['el-scrollbar', {
        'is-double': this.isDoubleScroll,
        'has-gutter': this.gutter
      }]
    }, nodes);
  }
});
// CONCATENATED MODULE: ./packages/scrollbar/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_scrollbar_src_mainvue_type_script_lang_js_ = (scrollbar_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/scrollbar/src/main.vue
var main_render, main_staticRenderFns




/* normalize component */

var src_main_component = normalizeComponent(
  packages_scrollbar_src_mainvue_type_script_lang_js_,
  main_render,
  main_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_main = (src_main_component.exports);
// CONCATENATED MODULE: ./packages/scrollbar/index.js


/* istanbul ignore next */
src_main.install = function (Vue) {
  Vue.component(src_main.name, src_main);
};
/* harmony default export */ var scrollbar = (src_main);
// CONCATENATED MODULE: ./src/utils/clickoutside.js


const nodeList = [];
const ctx = '@@clickoutsideContext';
let startClick;
let seed = 0;
!external_vue_default.a.prototype.$isServer && on(document, 'mousedown', e => startClick = e);
!external_vue_default.a.prototype.$isServer && on(document, 'mouseup', e => {
  nodeList.forEach(node => node[ctx].documentHandler(e, startClick));
});
function createDocumentHandler(el, binding, vnode, excludes) {
  return function (mouseup = {}, mousedown = {}) {
    if (!vnode || !vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || vnode.context.popperElm && (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target))) {
      return;
    }
    if (excludes && (excludes.includes(mousedown.target) || excludes.includes(mouseup.target))) {
      return;
    }
    if (binding.expression && el[ctx].methodName && vnode.context[el[ctx].methodName]) {
      vnode.context[el[ctx].methodName]();
    } else {
      el[ctx].bindingFn && el[ctx].bindingFn();
    }
  };
}

/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */
/* harmony default export */ var clickoutside = ({
  bind(el, binding, vnode) {
    nodeList.push(el);
    const id = seed++;
    el[ctx] = {
      id,
      documentHandler: createDocumentHandler(el, binding, vnode, binding.value.excludes),
      methodName: binding.expression,
      bindingFn: typeof binding.value === 'function' ? binding.value : binding.value.fn
    };
  },
  update(el, binding, vnode) {
    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode, binding.value.excludes);
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = typeof binding.value === 'function' ? binding.value : binding.value.fn;
  },
  unbind(el) {
    const len = nodeList.length;
    for (let i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }
    delete el[ctx];
  }
});
// CONCATENATED MODULE: ./src/utils/scroll-into-view.js

function scrollIntoView(container, selected, selfScroll) {
  if (external_vue_default.a.prototype.$isServer) return;
  if (!selected) {
    container.scrollTop = 0;
    return;
  }
  const top = selected.offsetTop;
  const bottom = selected.offsetTop + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;
  if (top < viewRectTop) {
    if (selfScroll) {
      selfScroll.setScroll(top);
    } else {
      container.scrollTop = top;
    }
  } else if (bottom > viewRectBottom) {
    if (selfScroll) {
      selfScroll.setScroll(bottom - container.clientHeight);
    } else {
      container.scrollTop = bottom - container.clientHeight;
    }
  }
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/select.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//















const sizeMap = {
  large: 42,
  small: 30,
  mini: 22
};
/* harmony default export */ var selectvue_type_script_lang_js_ = ({
  name: 'ElSelect',
  components: {
    ElInput: packages_input,
    ElSelectMenu: select_dropdown,
    ElOption: src_option,
    ElTag: packages_tag,
    ElScrollbar: scrollbar
  },
  directives: {
    Clickoutside: clickoutside
  },
  mixins: [emitter, locale],
  componentName: 'ElSelect',
  props: {
    name: {
      type: String,
      default: null
    },
    // eslint-disable-next-line
    value: {
      required: true
    },
    size: {
      type: String,
      default: null
    },
    clearable: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: null
    },
    reserveKeyword: {
      type: Boolean,
      default: null
    },
    clear: {
      type: Boolean,
      default: null
    },
    filterable: {
      type: Boolean,
      default: false
    },
    allowCreate: {
      type: Boolean,
      default: null
    },
    loading: {
      type: Boolean,
      default: null
    },
    popperClass: {
      type: String,
      default: null
    },
    remote: {
      type: Boolean,
      default: null
    },
    loadingText: {
      type: String,
      default: null
    },
    noMatchText: {
      type: String,
      default: null
    },
    kind: {
      type: String,
      default: null
    },
    noDataText: {
      type: String,
      default: null
    },
    remoteMethod: {
      type: Function,
      default: null
    },
    filterMethod: {
      type: Function,
      default: null
    },
    multiple: {
      type: Boolean,
      default: null
    },
    multipleNowrap: {
      type: Boolean,
      default: null
    },
    multipleLimit: {
      type: Number,
      default: 0
    },
    maxWidth: {
      type: Number,
      default: null
    },
    placeholder: {
      type: String,
      default() {
        return Object(locale_["t"])('el.select.placeholder');
      }
    },
    defaultFirstOption: {
      type: Boolean,
      default: null
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    collapseTags: {
      type: Boolean,
      default: null
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: null,
      default() {
        return {
          forceAbsolute: true,
          gpuAcceleration: false
        };
      }
    },
    placement: {
      type: String,
      default: 'bottom-start'
    }
  },
  data() {
    return {
      options: [],
      cachedOptions: [],
      createdLabel: null,
      createdSelected: false,
      selected: this.multiple ? [] : {},
      isSelect: true,
      isClick: false,
      textWidth: 0,
      inputWidth: 0,
      inputWidthMin: 0,
      inputClear: false,
      cachedPlaceHolder: '',
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      selectedLabel: '',
      hoverIndex: -1,
      query: '',
      optionsAllDisabled: false,
      inputHovering: false,
      currentPlaceholder: '',
      isIE: false // 判断是否是ie
    };
  },
  computed: {
    // 判断 暂无结果 是否展示
    isShowEmptyText() {
      if (!this.emptyText) {
        return false;
      }
      return this.options.length === 0 || this.filteredOptionsCount === 0;
    },
    showDropdown() {
      // if (!this.multiple && this.search && this.query === '') {
      //   return false;
      // }
      return this.visible && this.emptyText !== false;
    },
    search() {
      return this.filterable || this.remote;
    },
    criteria() {
      return !this.disabled && this.inputHovering && (
      // 单选清除 与 多选清除
      this.clear && !this.multiple && this.value !== undefined && this.value !== '' || this.clearable && this.multiple && Array.isArray(this.value) && this.value.length);
    },
    iconClass() {
      if (this.criteria) {
        return 'h-icon-close_f';
      } else {
        return 'h-icon-angle_down_sm';
      }
    },
    debounce() {
      return this.remote ? 300 : 0;
    },
    emptyText() {
      if (this.loading) {
        return this.loadingText || this.t('el.select.loading');
      } else {
        if (this.remote && this.query === '' && this.options.length === 0) {
          return false;
        }
        if (this.options.length === 0) {
          return this.noDataText || this.t('el.select.noData');
        } else if (this.filterable && this.options.length > 0 && this.filteredOptionsCount === 0) {
          return this.noMatchText || this.t('el.select.noMatch');
        }
      }
      return null;
    },
    showNewOption() {
      const hasExistingOption = this.options.filter(option => !option.created).some(option => option.currentLabel === this.query);
      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
    },
    selectSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    selectDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    },
    collapseTagSize() {
      return ['medium', 'small'].indexOf(this.selectSize) > -1 ? 'small' : 'medium';
    }
  },
  watch: {
    placeholder(val) {
      this.cachedPlaceHolder = this.currentPlaceholder = val;
    },
    value(val) {
      if (this.multiple) {
        // this.resetInputHeight();
        if (val.length > 0 || this.$refs.input && this.query !== '') {
          this.currentPlaceholder = '';
        } else {
          this.currentPlaceholder = this.cachedPlaceHolder;
        }
      }
      this.setSelected();
      // if (this.filterable && !this.multiple) {
      //   this.inputLength = 20;
      // }
      this.$emit('change', val, this);
      this.dispatch('ElFormItem', 'el.form.change', val);
    },
    query(val) {
      if (this.remote || this.allowCreate) {
        // const newValue = val.trim();
        const newValue = val || val === 0 ? val.toString().trim() : val.trim();
        if (newValue !== val) {
          this.query = newValue;
          return;
        }
      }
      this.$nextTick(() => {
        if (this.visible) this.broadcast('ElSelectDropdown', 'updatePopper');
        this.textWidth = this.$refs.text.getBoundingClientRect().width;
        this.resetInputHeight();
      });
      this.hoverIndex = -1;
      if (this.remote && typeof this.remoteMethod === 'function') {
        this.hoverIndex = -1;
        this.remoteMethod(val, this.isClick);
        this.isClick = false;
        this.broadcast('ElOption', 'resetIndex');
      } else if (typeof this.filterMethod === 'function') {
        this.filterMethod(val);
        this.broadcast('ElOptionGroup', 'queryChange');
      } else {
        this.filteredOptionsCount = this.optionsCount;
        this.broadcast('ElOption', 'queryChange', val);
        this.broadcast('ElOptionGroup', 'queryChange');
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    },
    visible(val) {
      if (!val) {
        this.$refs.reference.$el.querySelector('input').blur();
        if (!this.criteria) {
          this.handleIconHide();
        }
        this.broadcast('ElSelectDropdown', 'destroyPopper');
        if (this.$refs.input) {
          this.$refs.input.blur();
        }
        this.query = '';
        this.selectedLabel = '';
        // this.inputLength = 20;
        this.resetHoverIndex();
        this.$nextTick(() => {
          if (this.$refs.input && this.$refs.input.value === '' && this.selected.length === 0) {
            this.currentPlaceholder = this.cachedPlaceHolder;
          }
        });
        if (!this.multiple) {
          if (this.selected) {
            if (this.filterable && this.allowCreate && this.createdSelected && this.createdOption) {
              this.selectedLabel = this.createdLabel;
            } else {
              this.selectedLabel = this.selected.currentLabel;
            }
            if (this.filterable) this.query = this.selectedLabel;
          }
        }
      } else {
        if (!this.criteria) {
          this.handleIconShow();
        }
        this.broadcast('ElSelectDropdown', 'updatePopper');
        if (this.filterable) {
          this.query = this.selectedLabel;
          if (this.multiple) {
            this.$refs.input.focus();
          } else {
            if (!this.remote) {
              this.broadcast('ElOption', 'queryChange', '');
              this.broadcast('ElOptionGroup', 'queryChange');
            }
            this.broadcast('ElInput', 'inputSelect');
          }
        }
      }
      this.$emit('visible-change', val);
    },
    options(val) {
      if (this.$isServer) return;
      this.optionsAllDisabled = val.length === val.filter(item => item.disabled === true).length;
      if (this.multiple) {
        this.resetInputHeight();
      }
      const inputs = this.$el.querySelectorAll('input');
      if ([].indexOf.call(inputs, document.activeElement) === -1) {
        this.setSelected();
      }
      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    }
  },
  created() {
    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
    if (this.multiple && !Array.isArray(this.value)) {
      this.$emit('input', []);
    }
    if (!this.multiple && Array.isArray(this.value)) {
      this.$emit('input', '');
    }
    this.setSelected();
    this.debouncedOnInputChange = debounce_default()(this.debounce, () => {
      this.onInputChange();
    });
    this.$on('handleOptionClick', this.handleOptionSelect);
    this.$on('onOptionDestroy', this.onOptionDestroy);
    this.$on('setSelected', this.setSelected);
  },
  mounted() {
    if (this.multiple && Array.isArray(this.value) && this.value.length > 0) {
      this.currentPlaceholder = '';
    }
    addResizeListener(this.$el, this.handleResize);
    if (this.remote && this.multiple) {
      this.resetInputHeight();
    }
    this.$nextTick(() => {
      if (this.$refs.reference && this.$refs.reference.$el) {
        this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
        this.textWidth = this.$refs.text.getBoundingClientRect().width;
      }
    });
    // ie兼容
    if (!!window.ActiveXObject || 'ActiveXObject' in window) {
      this.isIE = true;
    }
    this.$on('popperHidden', this.handleClose);
  },
  beforeDestroy() {
    if (this.$el && this.handleResize) {
      removeResizeListener(this.$el, this.handleResize);
    }
  },
  methods: {
    handleIconHide() {
      const icon = this.$el.querySelector('.el-input__suffix');
      // if (icon && !this.search) {
      //   removeClass(icon, 'is-reverse');
      // }
      if (icon) {
        removeClass(icon, 'is-reverse');
      }
    },
    handleIconShow() {
      const icon = this.$el.querySelector('.el-input__suffix');
      // if (icon && !hasClass(icon, 'h-icon-close_f') && !this.search) {
      //   addClass(icon, 'is-reverse');
      // }
      if (icon && !hasClass(icon, 'h-icon-close_f')) {
        addClass(icon, 'is-reverse');
      }
    },
    scrollToOption(option) {
      const target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;
      if (this.$refs.popper && target) {
        const menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
        scrollIntoView(menu, target);
      }
    },
    handleMenuEnter() {
      this.$nextTick(() => this.scrollToOption(this.selected));
    },
    afterEnter() {
      this.$nextTick(() => this.$refs.scrollbar.throttleUpdate());
    },
    getOption(value) {
      let option;
      const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      for (let i = this.cachedOptions.length - 1; i >= 0; i--) {
        const cachedOption = this.cachedOptions[i];
        const isEqual = isObject ? getValueByPath(cachedOption.value, this.valueKey) === getValueByPath(value, this.valueKey) : cachedOption.value === value;
        if (isEqual) {
          option = cachedOption;
          break;
        }
      }
      if (option) return option;
      // 没匹配上就不显示了
      // const label = !isObject ? value : '';
      const label = '';
      const newOption = {
        value: value,
        currentLabel: label
      };
      if (this.multiple) {
        newOption.hitState = false;
      }
      return newOption;
    },
    setSelected() {
      if (!this.multiple) {
        const option = this.getOption(this.value);
        if (option.created) {
          this.createdLabel = option.currentLabel;
          this.createdSelected = true;
        } else {
          this.createdSelected = false;
        }
        this.selectedLabel = option.currentLabel;
        this.selected = option;
        if (this.filterable) this.query = this.selectedLabel;
        return;
      }
      const result = [];
      if (Array.isArray(this.value)) {
        this.value.forEach(value => {
          result.push(this.getOption(value));
        });
      }
      // 再对选中的项进行过滤如果没有label则不显示 xx
      this.selected = result.filter(val => val.currentLabel !== '');
      if (this.selected.length) {
        this.inputClear = true;
      } else {
        this.inputClear = false;
      }
      this.$nextTick(() => {
        this.resetInputHeight();
      });
    },
    handleFocus(event) {
      if (!this.readonly) {
        this.visible = true;
        this.$emit('focus', event);
      }
    },
    // blur() {
    //   this.visible = false;
    //   this.$refs.reference.blur();
    // },
    handleBlur(event) {
      this.$emit('blur', event);
    },
    handleSearchClick(event) {
      event.stopPropagation();
      this.$emit('search', this.value, this.query);
    },
    handleIconClick(event) {
      if (this.iconClass.indexOf('h-icon-search') > -1) {
        this.handleSearchClick(event);
      } else if (this.iconClass.indexOf('h-icon-close_f') > -1) {
        // this.deleteSelected(event);
        this.multiple && this.clearable ? this.deleteAllTag() : this.deleteSelected(event);
      } else {
        this.toggleMenu();
      }
    },
    handleMouseDown(event) {
      if (event.target.tagName !== 'INPUT') return;
      if (this.visible) {
        this.handleClose();
        event.preventDefault();
      }
    },
    doDestroy() {
      this.$refs.popper && this.$refs.popper.doDestroy();
      this.dropdownUl = null;
    },
    handleClose() {
      this.visible = false;
    },
    toggleLastOptionHitState(hit) {
      if (!Array.isArray(this.selected)) return;
      const option = this.selected[this.selected.length - 1];
      if (!option) return;
      if (hit === true || hit === false) {
        option.hitState = hit;
        return hit;
      }
      option.hitState = !option.hitState;
      return option.hitState;
    },
    deletePrevTag(e) {
      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
        const value = this.value.slice();
        value.pop();
        this.$emit('input', value);
      }
    },
    managePlaceholder() {
      if (this.currentPlaceholder !== '') {
        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
      }
    },
    resetInputState(e) {
      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
      // this.inputLength = this.$refs.input.value.length * 15 + 20;
      // this.resetInputHeight();
    },
    resetInputHeight() {
      if (!this.multiple) return;
      this.$nextTick(() => {
        if (!this.$refs.reference) return;
        const inputChildNodes = this.$refs.reference.$el.childNodes;
        const input = [].filter.call(inputChildNodes, item => item.tagName === 'INPUT')[0];
        const height = input.style.height;
        input.style.height = Math.max(this.$refs.tags.clientHeight, sizeMap[this.size] || 32) + 'px';
        if (this.isIE && height === input.style.height) {
          // ie下防止闪烁
          return;
        }
        if (this.visible && this.emptyText !== false) {
          this.broadcast('ElSelectDropdown', 'updatePopper');
        }
      });
    },
    resetHoverIndex() {
      setTimeout(() => {
        if (!this.multiple) {
          this.hoverIndex = this.options.indexOf(this.selected);
        } else {
          if (this.selected.length > 0) {
            this.hoverIndex = Math.min.apply(null, this.selected.map(item => this.options.indexOf(item)));
          } else {
            this.hoverIndex = -1;
          }
        }
      }, 300);
    },
    handleOptionSelect(option) {
      if (this.multiple) {
        const value = this.value.slice();
        const optionIndex = this.getValueIndex(value, option.value);
        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
          value.push(option.value);
        } else {
          return;
        }
        this.$emit('input', value);
        // if (!this.searchArray.length && !this.reserveKeyword) {
        //   this.query = '';
        // }
        // if (option.created) {
        //   this.query = '';
        // }
        if (this.filterable) {
          this.$refs.input.focus();
        }
      } else {
        this.$emit('input', option.value);
        this.visible = false;
      }
      this.isClick = true;
      this.$nextTick(() => this.scrollToOption(option));
    },
    getValueIndex(arr = [], value) {
      const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      if (!isObject) {
        return arr.indexOf(value);
      } else {
        const valueKey = this.valueKey;
        let index = -1;
        arr.some((item, i) => {
          if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {
            index = i;
            return true;
          }
          return false;
        });
        return index;
      }
    },
    toggleMenu() {
      // if (this.filterable && this.query === '' && this.visible) {
      //   return;
      // }
      if (!this.disabled && !this.readonly) {
        this.visible = !this.visible;
      }
    },
    hiddenMenu() {
      this.visible = false;
    },
    navigateOptions(direction) {
      if (!this.visible) {
        this.visible = true;
        return;
      }
      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;
      this.optionsAllDisabled = this.options.length === this.options.filter(item => item.disabled === true).length;
      if (!this.optionsAllDisabled) {
        if (direction === 'next') {
          this.hoverIndex++;
          if (this.hoverIndex === this.options.length) {
            this.hoverIndex = 0;
          }
          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
            this.navigateOptions('next');
          }
        }
        if (direction === 'prev') {
          this.hoverIndex--;
          if (this.hoverIndex < 0) {
            this.hoverIndex = this.options.length - 1;
          }
          if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
            this.navigateOptions('prev');
          }
        }
      }
      this.$nextTick(() => this.scrollToOption(this.options[this.hoverIndex]));
    },
    selectOption() {
      if (this.options[this.hoverIndex]) {
        this.handleOptionSelect(this.options[this.hoverIndex]);
      }
    },
    deleteSelected(event) {
      event.stopPropagation();
      this.$emit('input', '');
      this.visible = false;
      this.$emit('clear');
    },
    deleteAllTag() {
      this.value.splice(0, this.selected.length);
      this.$emit('input', this.value);
      for (let i = 0; i < this.selected.length; i++) {
        this.$emit('remove-tag', this.selected[i]);
      }
    },
    deleteTag(event, tag) {
      const index = this.selected.indexOf(tag);
      if (index > -1 && !this.disabled) {
        const value = this.value.slice();
        value.splice(index, 1);
        this.$emit('input', value);
        this.$emit('remove-tag', tag);
      }
      event.stopPropagation();
    },
    onInputChange() {
      if (this.filterable) {
        this.query = this.selectedLabel;
      }
    },
    onOptionDestroy(option) {
      const index = this.options.indexOf(option);
      if (index > -1) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        this.options.splice(index, 1);
      }
      this.broadcast('ElOption', 'resetIndex');
    },
    resetInputWidth() {
      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
    },
    resetInputWidthMin() {
      this.inputWidthMin = this.clearable ? 50 : 32;
    },
    handleResize() {
      this.resetInputWidth();
      this.resetInputWidthMin();
      if (this.multiple) this.resetInputHeight();
    },
    checkDefaultFirstOption() {
      this.hoverIndex = -1;
      for (let i = 0; i !== this.options.length; ++i) {
        const option = this.options[i];
        if (this.query) {
          // pick first options that passes the filter
          if (!option.disabled && !option.groupDisabled && option.visible) {
            this.hoverIndex = i;
            break;
          }
        } else {
          // pick currently selected option
          if (option.itemSelected) {
            this.hoverIndex = i;
            break;
          }
        }
      }
    },
    getValueKey(item) {
      const type = typeof item.value;
      if (type === 'number' || type === 'string') {
        return item.value;
      } else {
        return getValueByPath(item.value, this.valueKey);
      }
    },
    onScrollingX(s) {
      const {
        scrollLeft,
        percentX
      } = s;
      this.$emit('on-scrolling-x', {
        scrollLeft,
        percentX
      });
      this.$emit('on-scrolling', s);
    },
    onScrollingY(s) {
      const {
        scrollTop,
        percentY
      } = s;
      this.$emit('on-scrolling-y', {
        scrollTop,
        percentY
      });
      this.$emit('on-scrolling', s);
    }
  }
});
// CONCATENATED MODULE: ./packages/select/src/select.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_selectvue_type_script_lang_js_ = (selectvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/select/src/select.vue





/* normalize component */

var select_component = normalizeComponent(
  src_selectvue_type_script_lang_js_,
  selectvue_type_template_id_4d0038c5_render,
  selectvue_type_template_id_4d0038c5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_select = (select_component.exports);
// CONCATENATED MODULE: ./packages/select/index.js


/* istanbul ignore next */
src_select.install = function (Vue) {
  Vue.component(src_select.name, src_select);
};
/* harmony default export */ var packages_select = (src_select);
// CONCATENATED MODULE: ./packages/option/index.js


/* istanbul ignore next */
src_option.install = function (Vue) {
  Vue.component(src_option.name, src_option);
};
/* harmony default export */ var packages_option = (src_option);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=template&id=eca0b3fe&
var buttonvue_type_template_id_eca0b3fe_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"el-button",class:[
    _vm.type ? 'el-button--' + _vm.type : '',
    _vm.size ? 'el-button--' + _vm.size : '',
    {
      'is-disabled': _vm.buttonDisabled,
      'is-loading': _vm.loading,
      'is-plain': _vm.plain,
      'is-radius': _vm.radius,
      'is-icon': _vm.icon || _vm.iconBorder,
      'is-icon-border': _vm.iconBorder,
      'is-icon-text': _vm.$slots.default && _vm.icon
    }
  ],style:({
    minWidth: _vm.minWidth && (_vm.minWidth + "px"),
    maxWidth: _vm.maxWidth && (_vm.maxWidth + "px")
  }),attrs:{"disabled":_vm.buttonDisabled || _vm.loading,"autofocus":_vm.autofocus,"type":_vm.nativeType,"title":_vm.labelTitle},on:{"click":_vm.handleClick,"mouseover":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.handleMouseover.apply(null, arguments)}}},[(_vm.loading)?_c('el-load-icon',{staticClass:"h-icon-loading",on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.icon && !_vm.loading)?_c('i',{class:_vm.icon}):_vm._e(),(_vm.iconBorder && !_vm.loading)?_c('i',{class:_vm.iconBorder,on:{"click":_vm.handleInnerClick}}):_vm._e(),(_vm.$slots.default)?_c('span',{on:{"click":_vm.handleInnerClick}},[_vm._t("default")],2):_vm._e()],1)}
var buttonvue_type_template_id_eca0b3fe_staticRenderFns = []


// CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=template&id=eca0b3fe&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var buttonvue_type_script_lang_js_ = ({
  name: 'ElButton',
  props: {
    minWidth: {
      type: Number,
      default: null
    },
    maxWidth: {
      type: Number,
      default: null
    },
    type: {
      type: String,
      default: 'default'
    },
    size: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    iconBorder: {
      type: String,
      default: null
    },
    plain: {
      type: Boolean,
      default: null
    },
    autofocus: {
      type: Boolean,
      default: null
    },
    radius: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      labelTitle: ''
    };
  },
  computed: {
    buttonDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    }
  },
  methods: {
    handleInnerClick(e) {
      if (this.disabled) {
        e.stopPropagation();
      }
    },
    handleClick(evt) {
      this.$emit('click', evt);
    },
    handleMouseover(e) {
      const t = e.target;
      // 如果设置了默认的title就用默认的
      if (this.$attrs.title) return;
      this.labelTitle = t.scrollWidth >= t.offsetWidth ? t.innerText : '';
    }
  }
});
// CONCATENATED MODULE: ./packages/button/src/button.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_buttonvue_type_script_lang_js_ = (buttonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/button/src/button.vue





/* normalize component */

var button_component = normalizeComponent(
  src_buttonvue_type_script_lang_js_,
  buttonvue_type_template_id_eca0b3fe_render,
  buttonvue_type_template_id_eca0b3fe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_button = (button_component.exports);
// CONCATENATED MODULE: ./packages/button/index.js


/* istanbul ignore next */
src_button.install = function (Vue) {
  Vue.component(src_button.name, src_button);
};
/* harmony default export */ var packages_button = (src_button);
// CONCATENATED MODULE: ./packages/pagination/src/pagination.js







/* harmony default export */ var pagination = ({
  name: 'ElPagination',
  props: {
    pageSize: {
      type: Number,
      default: 10
    },
    small: Boolean,
    extraSmall: Boolean,
    total: Number,
    pageCount: Number,
    pagerCount: {
      type: Number,
      validator(value) {
        return (value | 0) === value && value > 2 && value < 22;
      },
      default: 7
    },
    currentPage: {
      type: Number,
      default: 1
    },
    layout: {
      default: 'prev, pager, next, jumper, ->, total'
    },
    pageSizes: {
      type: Array,
      default() {
        return [10, 20, 30, 40, 50, 100];
      }
    },
    /**
     * 每页显示条目个数变化发请求前的钩子
     * add by yangzhini 2018-06-29
     * @param {Number} val    改变后的值
     * @param {Number} oldVal 改变前的值
     * @return {Boolean} 是否继续发请求
     * @example (val, oldVal) => true
     */
    beforeSizeChange: {
      type: Function,
      default: () => true
    },
    /**
     * 分页跳转发请求前的钩子
     * add by yangzhini 2018-06-29
     * @param {Number} val    改变后的值
     * @param {Number} oldVal 改变前的值
     * @return {Boolean} 是否继续发请求
     * @example (val, oldVal) => true
     */
    beforeCurrentChange: {
      type: Function,
      default: () => true
    },
    /**
     * 设置禁用
     * add by yangzhini 2018-09-06
     */
    disabled: {
      type: Boolean,
      default: false
    },
    prevText: {
      type: String,
      default: ''
    },
    nextText: {
      type: String,
      default: ''
    },
    /**
     * 每页显示条数下拉框的类名
     * add by chenguanbin 2019-05-29
     */
    sizesPopperClass: {
      type: String,
      default: ''
    }
  },
  data() {
    return {
      internalCurrentPage: 1,
      internalPageSize: 0,
      popperClass: this.sizesPopperClass
    };
  },
  render() {
    const h = arguments[0];
    const template = h("div", {
      "class": 'el-pagination'
    });
    const templateInner = h("div", {
      "class": 'el-pagination-wrapper'
    });
    const layout = this.layout || '';
    if (!layout) return;
    const TEMPLATE_MAP = {
      prev: h("prev"),
      jumper: h("jumper"),
      pager: h("pager", {
        "attrs": {
          "currentPage": this.internalCurrentPage,
          "pageCount": this.internalPageCount,
          "disabled": this.disabled,
          "pagerCount": this.pagerCount
        },
        "on": {
          "change": this.handleCurrentChange
        }
      }),
      // 增加HUI的表格分页组件类型 add by zhangxiaogang 2017-09-27
      huiPager: h("huiPager", {
        "attrs": {
          "currentPage": this.internalCurrentPage,
          "pageCount": this.internalPageCount
        },
        "on": {
          "goto": this.handleCurrentChange
        }
      }),
      miniPager: h("miniPager"),
      next: h("next"),
      first: h("first"),
      last: h("last"),
      sizes: h("sizes", {
        "attrs": {
          "pageSizes": this.pageSizes
        }
      }),
      slot: h("my-slot"),
      total: h("total")
    };
    const components = layout.split(',').map(item => item.trim());
    const rightWrapper = h("div", {
      "class": 'el-pagination__rightwrapper'
    });
    let haveRightWrapper = false;
    if (this.small) {
      template.data.class += ' el-pagination--small';
    }
    let tableRightPageWrapper = null;
    // 如果是表格场景的分页，外层容器追加自定义class以便样式覆盖
    if (this.isForTable) {
      template.data.class += ' el-pagination--table';
      tableRightPageWrapper = h("div", {
        "class": 'el-pagination__tableRightPageWrapper'
      });
      tableRightPageWrapper.children = tableRightPageWrapper.children || [];
    }
    const insertTarget = this.isForTable ? templateInner : template;

    // https://github.com/vuejs/babel-plugin-transform-vue-jsx/issues/123
    insertTarget.children = insertTarget.children || [];
    template.children = template.children || [];
    rightWrapper.children = rightWrapper.children || [];
    components.forEach(compo => {
      if (compo === '->') {
        haveRightWrapper = true;
      } else {
        if (this.isForTable && ['jumper', 'huiPager', 'prev', 'pager', 'next'].indexOf(compo) > -1) {
          tableRightPageWrapper.children.push(TEMPLATE_MAP[compo]);
        } else if (!haveRightWrapper) {
          insertTarget.children.push(TEMPLATE_MAP[compo]);
        } else {
          rightWrapper.children.push(TEMPLATE_MAP[compo]);
        }
      }
    });
    if (haveRightWrapper) {
      insertTarget.children.unshift(rightWrapper);
    }
    if (this.isForTable) {
      insertTarget.children.push(tableRightPageWrapper);
      template.children.push(insertTarget);
    }
    return template;
  },
  components: {
    MySlot: {
      render() {
        return this.$parent.$slots.default ? this.$parent.$slots.default[0] : '';
      }
    },
    // 跳转到第一页
    First: {
      render() {
        const h = arguments[0];
        return h("button", {
          "attrs": {
            "type": 'button'
          },
          "class": ['btn-first', {
            disabled: this.$parent.disabled || this.$parent.internalCurrentPage <= 1
          }],
          "on": {
            "click": this.$parent.first
          }
        }, [h("i", {
          "class": 'el-icon h-icon-angle_line_left'
        })]);
      }
    },
    // 跳转到最后一页
    Last: {
      render() {
        const h = arguments[0];
        return h("button", {
          "attrs": {
            "type": 'button'
          },
          "class": ['btn-last', {
            disabled: this.$parent.disabled || this.$parent.internalCurrentPage === this.$parent.internalPageCount || this.$parent.internalPageCount === 0
          }],
          "on": {
            "click": this.$parent.last
          }
        }, [h("i", {
          "class": 'el-icon h-icon-angle_line_right'
        })]);
      }
    },
    Prev: {
      render() {
        const h = arguments[0];
        return h("button", {
          "attrs": {
            "type": 'button'
          },
          "class": ['btn-prev', {
            disabled: this.$parent.disabled || this.$parent.internalCurrentPage <= 1
          }],
          "on": {
            "click": this.$parent.prev
          }
        }, [this.$parent.prevText ? h("span", [this.$parent.prevText]) : h("i", {
          "class": 'el-icon h-icon-angle_left'
        })]);
      }
    },
    Next: {
      render() {
        const h = arguments[0];
        return h("button", {
          "attrs": {
            "type": 'button'
          },
          "class": ['btn-next', {
            disabled: this.$parent.disabled || this.$parent.internalCurrentPage === this.$parent.internalPageCount || this.$parent.internalPageCount === 0
          }],
          "on": {
            "click": this.$parent.next
          }
        }, [this.$parent.nextText ? h("span", [this.$parent.nextText]) : h("i", {
          "class": 'el-icon h-icon-angle_right'
        })]);
      }
    },
    Sizes: {
      mixins: [locale],
      props: {
        pageSizes: Array
      },
      watch: {
        pageSizes: {
          immediate: true,
          handler(value) {
            if (Array.isArray(value)) {
              this.$parent.internalPageSize = value.indexOf(this.$parent.pageSize) > -1 ? this.$parent.pageSize : this.pageSizes[0];
            }
          }
        }
      },
      render() {
        const h = arguments[0];
        const popperClass = `el-pagination__paged-select ${this.$parent.popperClass}`;
        return h("span", {
          "class": 'el-pagination__sizes'
        }, [h("el-select", {
          "attrs": {
            "popper-class": popperClass,
            "value": this.$parent.internalPageSize,
            "disabled": this.$parent.disabled
          },
          "on": {
            "input": this.handleChange
          }
        }, [this.pageSizes.map(item => h("el-option", {
          "attrs": {
            "value": item,
            "label": item + ' ' + this.t('el.pagination.pagesize')
          }
        }))])]);
      },
      components: {
        ElSelect: packages_select,
        ElOption: packages_option
      },
      methods: {
        handleChange(val) {
          if (val !== this.$parent.internalPageSize) {
            const oldPageSize = this.$parent.internalPageSize;
            Promise.resolve(this.$parent.beforeSizeChange(val, oldPageSize)).then(allowed => {
              if (allowed) {
                this.$parent.internalPageSize = val = parseInt(val, 10);
              }
            });
          }
        }
      }
    },
    Jumper: {
      mixins: [locale],
      components: {
        ElInput: packages_input
      },
      data() {
        return {
          oldValue: null,
          newValue: this.$parent.currentPage || 1
        };
      },
      watch: {
        '$parent.internalCurrentPage'(v) {
          if (v) {
            this.newValue = v;
          }
        }
      },
      methods: {
        handleFocus(event) {
          this.oldValue = +event.target.value;
        },
        handleBlur({
          target
        }) {
          if (!target.value) {
            this.newValue = this.oldValue;
            target.value = this.oldValue;
          }
          this.reassignMaxValue(target);
          // 触发before-current-change  yangzhini  2018-12-10
          if (this.newValue !== this.$parent.internalCurrentPage) {
            this.$parent.currentChangeValid(this.newValue).then(allowed => {
              if (!allowed) {
                this.newValue = this.$parent.internalCurrentPage;
              }
            });
          }
          this.oldValue = null;
        },
        handleKeyUp(event) {
          if (event.target.value === '') return;
          const val = +event.target.value;
          // 通过拖拽输入字符, 会出现'01'的情况
          event.target.value = val;
          // if (event.keyCode === 8 && !val) return;
          const key = event.key || '';
          const keyCode = event.keyCode || '';
          const isEnter = key && key === 'Enter' || keyCode && keyCode === 13;
          if (typeof val === 'number' && !isEnter) {
            if (val > this.$parent.internalPageCount) {
              this.newValue = this.$parent.internalPageCount;
            } else if (val < 1) {
              this.newValue = 1;
            } else {
              this.newValue = val;
            }
            event.target.value = this.newValue;
            this.oldValue = this.newValue;
          } else if (!isEnter) {
            this.newValue = this.oldValue;
            event.target.value = this.oldValue;
          }
          if (isEnter) {
            this.reassignMaxValue(event.target);
            this.goto();
          }
        },
        reassignMaxValue(target) {
          if (+target.value > this.$parent.internalPageCount) {
            target.value = this.$parent.internalPageCount;
            // 页码始终应大于0  zhangxiaogang  2017-12-21
            if (this.$parent.internalPageCount === 0) target.value = 1;
          }
        },
        goto() {
          const temp = this.$parent.internalCurrentPage;
          this.handleBlur({
            target: {
              value: temp
            }
          });
        },
        handleInput(event) {
          event.target.value = event.target.value.replace(/[^\d]/g, '');
        }
      },
      /**
       * 增加了HUI表格分页控件的相关按钮
       * modify by zhangxiaogang 2017-09-27
       */
      render() {
        const h = arguments[0];
        return h("span", {
          "class": 'el-pagination__jump'
        }, [!this.$parent.isForTable && this.t('el.pagination.goto'), h("el-input", {
          "class": 'el-pagination__editor',
          "attrs": {
            "min": 1,
            "disabled": this.$parent.disabled
          },
          "on": {
            "focus": this.handleFocus,
            "blur": this.handleBlur
          },
          "nativeOn": {
            "keyup": this.handleKeyUp,
            "input": this.handleInput
          },
          "model": {
            value: this.newValue,
            callback: $$v => {
              this.newValue = $$v;
            }
          }
        }), this.$parent.isForTable && h("span", ["/\xA0", this.$parent.internalPageCount || 1, this.t('el.pagination.pageClassifier')]), !this.$parent.isForTable && this.t('el.pagination.pageClassifier'), this.$parent.isForTable && h("el-button", {
          "on": {
            "click": this.goto
          }
        }, [this.t('el.pagination.gotoBtn')])]);
      }
    },
    Total: {
      mixins: [locale],
      render() {
        const h = arguments[0];
        return typeof this.$parent.total === 'number' ? h("span", {
          "class": 'el-pagination__total'
        }, [this.t('el.pagination.total', {
          total: this.$parent.total
        })]) : '';
      }
    },
    miniPager: {
      render() {
        const h = arguments[0];
        return h("div", {
          "class": 'el-pagination__mini-pager'
        }, [h("div", {
          "class": 'el-pagination__mini-pager-num'
        }, [this.$parent.internalCurrentPage]), h("div", {
          "class": 'el-pagination__mini-pager-slash'
        }, [" / "]), h("div", {
          "class": 'el-pagination__mini-pager-max-num'
        }, [this.$parent.internalPageCount])]);
      }
    },
    /**
     * 增加HUI的表格分页组件
     * add by zhangxiaogang 2017-09-27
     */
    HuiPager: {
      mixins: [locale],
      render() {
        const h = arguments[0];
        const vm = this;
        return this.pageCount > 1 ? h("ul", {
          "class": 'el-pagination__pager'
        }, [h("li", {
          "class": [this.preDisabled ? 'is-disabled' : '', 'h-icon-angle_line_left'],
          "on": {
            "click": function () {
              vm.go('first');
            }
          }
        }), h("li", {
          "class": [this.preDisabled ? 'is-disabled' : '', 'h-icon-angle_left'],
          "on": {
            "click": function () {
              vm.go(-1);
            }
          }
        }), h("li", {
          "class": [this.nexDisabled ? 'is-disabled' : '', 'h-icon-angle_right'],
          "on": {
            "click": function () {
              vm.go(1);
            }
          }
        }), h("li", {
          "class": [this.nexDisabled ? 'is-disabled' : '', 'h-icon-angle_line_right'],
          "on": {
            "click": function () {
              vm.go('last');
            }
          }
        })]) : '';
      },
      methods: {
        go(val) {
          if (this.$parent.disabled) return;
          // 如果进行暴力测试极快速点击翻页可能会导致IE下input输入框中的数字持续变化，哪怕是松开了鼠标
          throttle_default()(100, () => {
            const {
              currentPage,
              pageCount
            } = this;
            if (currentPage === 1 && val === -1 || currentPage === pageCount && val === 1) {
              return;
            }
            // this.$parent.internalCurrentPage = val;
            let postVal = null;
            if (val === 'first') postVal = 1;else if (val === 'last') postVal = pageCount;else postVal = currentPage + val;
            // this.$parent.internalCurrentPage = postVal;
            this.$parent.currentChangeValid(postVal);
          })();
        }
      },
      computed: {
        preDisabled() {
          return this.$parent.disabled || this.currentPage === 1;
        },
        nexDisabled() {
          return this.$parent.disabled || this.currentPage === this.pageCount;
        }
      },
      props: {
        currentPage: Number,
        pageCount: Number
      }
    },
    Pager: pager,
    ElButton: packages_button
  },
  methods: {
    handleCurrentChange(val) {
      this.currentChangeValid(val);
    },
    first() {
      if (this.disabled) return;
      this.currentChangeValid(1);
    },
    last() {
      if (this.disabled) return;
      this.currentChangeValid(this.internalPageCount);
    },
    prev() {
      if (this.disabled) return;
      const newVal = this.internalCurrentPage - 1;
      this.currentChangeValid(newVal);
    },
    next() {
      if (this.disabled) return;
      const newVal = this.internalCurrentPage + 1;
      this.currentChangeValid(newVal);
    },
    currentChangeValid(val) {
      return Promise.resolve(this.beforeCurrentChange(val, this.internalCurrentPage)).then(allowed => {
        if (allowed) {
          this.internalCurrentPage = this.getValidCurrentPage(val);
        }
        return allowed;
      });
    },
    getValidCurrentPage(value) {
      value = parseInt(value, 10);
      const havePageCount = typeof this.internalPageCount === 'number';
      let resetValue;
      if (!havePageCount) {
        if (isNaN(value) || value < 1) resetValue = 1;
      } else {
        if (value < 1) {
          resetValue = 1;
        } else if (value > this.internalPageCount) {
          resetValue = this.internalPageCount;
        }
      }
      if (resetValue === undefined && isNaN(value)) {
        resetValue = 1;
      } else if (resetValue === 0) {
        resetValue = 1;
      }
      return resetValue === undefined ? value : resetValue;
    }
  },
  computed: {
    internalPageCount() {
      if (typeof this.total === 'number') {
        return Math.max(1, Math.ceil(this.total / this.internalPageSize));
      } else if (typeof this.pageCount === 'number') {
        return Math.max(1, this.pageCount);
      }
      return null;
    },
    // 标记是否是表格场景中的分页,以v1.2.0为界分前后两个版本
    isForTable() {
      const layoutNewTable = ['total', 'sizes', 'prev', 'pager', 'next', 'jumper'].join();
      const layout = this.layout.split(',').map(l => {
        return l.trim();
      });
      return layout.join() === layoutNewTable || this.layout.indexOf('huiPager') !== -1;
    }
  },
  watch: {
    currentPage: {
      immediate: true,
      handler(val) {
        this.internalCurrentPage = val;
      }
    },
    pageSize: {
      immediate: true,
      handler(val) {
        this.internalPageSize = val;
      }
    },
    internalPageSize(newVal, oldVal) {
      if (oldVal !== newVal) {
        this.$emit('size-change', newVal, oldVal);
      }
    },
    internalCurrentPage(newVal, oldVal) {
      newVal = parseInt(newVal, 10);

      /* istanbul ignore if */
      if (isNaN(newVal)) {
        newVal = oldVal || 1;
      } else {
        newVal = this.getValidCurrentPage(newVal);
      }
      if (newVal !== undefined) {
        this.$nextTick(() => {
          this.internalCurrentPage = newVal;
          if (oldVal !== newVal) {
            this.$emit('update:currentPage', newVal);
            this.$emit('current-change', this.internalCurrentPage, oldVal);
          }
        });
      } else {
        this.$emit('update:currentPage', newVal);
        this.$emit('current-change', this.internalCurrentPage, oldVal);
      }
    },
    internalPageCount(newVal) {
      /* istanbul ignore if */
      const oldPage = this.internalCurrentPage;
      if (newVal > 0 && oldPage === 0) {
        this.internalCurrentPage = 1;
      } else if (oldPage > newVal) {
        this.internalCurrentPage = newVal === 0 ? 1 : newVal;
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/pagination/index.js


/* istanbul ignore next */
pagination.install = function (Vue) {
  Vue.component(pagination.name, pagination);
};
/* harmony default export */ var packages_pagination = (pagination);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=template&id=3eb6bf41&
var componentvue_type_template_id_3eb6bf41_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"dialog-fade"},on:{"after-enter":_vm.afterEnter,"after-leave":_vm.afterLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],ref:"dialog",staticClass:"el-dialog__wrapper",on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.handleWrapperClick.apply(null, arguments)}}},[_c('div',{staticClass:"el-dialog",class:[_vm.sizeClass, _vm.customClass],style:(_vm.style)},[_c('div',{staticClass:"el-dialog__header"},[_vm._t("title",function(){return [_c('span',{staticClass:"el-dialog__title"},[_vm._v(_vm._s(_vm.title))])]}),(_vm.showClose)?_c('button',{staticClass:"el-dialog__headerbtn",attrs:{"type":"button","aria-label":"Close"},on:{"click":_vm.handleClose}},[_c('i',{staticClass:"el-dialog__close el-icon h-icon-close"})]):_vm._e()],2),(_vm.rendered)?_c('div',{staticClass:"el-dialog__body"},[(_vm.areaIsArray && !_vm.noScrollbar)?_c('el-scrollbar',{ref:"scrollbar",attrs:{"wrap-class":"el-dialog-scrollbar__wrap"}},[_c('div',{staticClass:"el-dialog__body-wrapper"},[_vm._t("default")],2)]):_c('div',{staticClass:"el-dialog__body-wrapper"},[_vm._t("default")],2)],1):_vm._e(),(_vm.$slots.footer)?_c('div',{staticClass:"el-dialog__footer"},[_vm._t("footer")],2):_vm._e()])])])}
var componentvue_type_template_id_3eb6bf41_staticRenderFns = []


// CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=template&id=3eb6bf41&

// CONCATENATED MODULE: ./src/utils/drag.js

// 用来获取 css 相关属性值 IE下获取的是属性字符串如 50%,100px;FF下是计算后的值
const getAttr = (obj, key) => obj.currentStyle ? obj.currentStyle[key] : window.getComputedStyle(obj, false)[key];
// 限流函数
const throttle = function (fn, interval) {
  let s = 0;
  return function () {
    const ctx = this;
    const e = Date.now();
    if (e - s >= interval) {
      fn.apply(ctx, arguments);
      // console.error('do something');
      s = e;
    }
  };
};
const fps = 1 / 60; // 刷新帧率
const drag_interval = parseInt(fps * 1000); // ms
const vDrag = {
  bind(el) {
    /**
     * target: dialog 组件的容器元素
     * header：dialog 组件的头部区域，也是就是拖拽的区域
     * 如果需要封装move指令，可基于此做简单改造
     */
    const target = el.children[0];
    const header = target.children[0];
    // header 鼠标手型
    header.style.cursor = 'move';
    const onmousedown = e => {
      // dialog面板el的宽高,用于适配IE下获取是%的情况，计算真实px
      const pWidth = el.offsetWidth;
      const pHeight = el.offsetHeight;
      const marginLStr = getAttr(target, 'margin-left');
      const marginTStr = getAttr(target, 'margin-top');
      // 处理IE下获取是百分比margin的情况
      const marginL = (marginLStr.includes('%') ? pWidth * parseFloat(marginLStr) / 100 : parseFloat(marginLStr)) || 0;
      const marginT = (marginTStr.includes('%') ? pHeight * parseFloat(marginTStr) / 100 : parseFloat(marginTStr)) || 0;
      // 记录按下时鼠标的坐标和目标元素的 left、top 值
      const currentX = e.clientX;
      const currentY = e.clientY;
      const offsetLeft = target.offsetLeft;
      const offsetTop = target.offsetTop;
      // offsetLeft = marginLeft + left; so => left = offsetLeft - marginLeft;
      const oLeft = offsetLeft - marginL; // 初始的left和top值
      const oTop = offsetTop - marginT;

      // 存到this.onmousemove 中，用于解绑
      const onmousemove = throttle(event => {
        // 鼠标移动时计算每次移动的距离，并改变拖拽元素的定位
        const deltaX = event.clientX - currentX; // x偏移
        const deltaY = event.clientY - currentY; // y偏移
        target.style.left = `${oLeft + deltaX}px`;
        target.style.top = `${oTop + deltaY}px`;
        const browserWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const browserHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const {
          left,
          top,
          right,
          bottom,
          height,
          width
        } = target.getBoundingClientRect(); // 获取浏览器视口的位置

        // 修正dialog 的margin导致的边界控制问题;
        if (left <= 0) {
          // 控制左侧不出边界 marginLeft：修正由于marginLeft存在，left=0时候依旧存在不靠最左边或者超出边界的问题；最右边同理
          target.style.left = `${0 - marginL}px`;
        }
        if (right >= browserWidth) {
          // 控制右侧不出边界
          target.style.left = `${browserWidth - width - marginL}px`;
        }
        if (top <= 0) {
          // 控制顶部不出边界 marginTop：修正由于marginTop存在，top=0时候依旧存在不靠最顶边或者超出边界的问题，最底边同理
          target.style.top = `${0 - marginT}px`;
        }
        if (bottom >= browserHeight) {
          target.style.top = `${browserHeight - height - marginT}px`;
        }
        // 阻止事件的默认行为，可以解决选中文本的时候拖不动
        e.preventDefault();
        return false;
      }, drag_interval);
      on(document, 'mousemove', onmousemove);

      // 鼠标松开时，拖拽结束
      once(document, 'mouseup', () => {
        off(document, 'mousemove', onmousemove);
      });
    };
    on(header, 'mousedown', onmousedown);
    el.$$onmousedown = onmousedown; // 引用持有
  },
  // 最后卸载时，清除事件绑定
  unbind(el) {
    const header = el && el.children[0] && el.children[0].children[0];
    if (header) {
      off(header, 'mousedown', el.$$onmousedown);
      el.$$onmousedown = null;
    }
  }
};
/* harmony default export */ var utils_drag = (vDrag);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dialog/src/component.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var componentvue_type_script_lang_js_ = ({
  name: 'ElDialog',
  components: {
    ElScrollbar: scrollbar
  },
  mixins: [popup, emitter],
  props: {
    title: {
      type: String,
      default: ''
    },
    modal: {
      type: Boolean,
      default: true
    },
    modalAppendToBody: {
      type: Boolean,
      default: true
    },
    /**
     * 弹窗嵌套时需传入参数
     * add by yinzhixing  2018-03-09
     */
    appendToBody: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    showClose: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: 'small'
    },
    customClass: {
      type: String,
      default: ''
    },
    top: {
      type: String,
      default: '15%'
    },
    draggable: {
      type: Boolean,
      default: false
    },
    /**
     * 传入数组则表示指定宽高，传入一个数值则表示只指定宽度,
     * 且传入了该参数则自动忽略size
     * add by zhangxiaogang  2017-09-28
     */
    area: {
      type: [Array, Number],
      default: null
    },
    noScrollbar: {
      type: Boolean,
      default: false
    },
    beforeClose: {
      type: Function,
      default: null
    },
    destroyOnClose: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      closed: false,
      rendered: false
    };
  },
  computed: {
    sizeClass() {
      return this.area ? '' : `el-dialog--${this.size}`;
    },
    areaIsArray() {
      return Array.isArray(this.area);
    },
    style() {
      const {
        area,
        areaIsArray
      } = this;
      let {
        top
      } = this;
      const styleArr = [];
      if (top === 'middle') {
        top = '50%';
      }
      styleArr.push(this.size === 'full' ? '' : `top: ${top}`);
      if (areaIsArray) {
        if (area.length === 2) {
          styleArr.push(`width: ${area[0]}px;height: ${area[1]}px;`);
          styleArr.push(`margin-left: ${-area[0] / 2}px`);
        } else {
          throw new Error('The area parameter passed to the dialog component must be 2! If it is an array.');
        }
      } else if (area) {
        styleArr.push(`width: ${area}px`);
        styleArr.push(`margin-left: ${-area / 2}px`);
      } else {
        switch (this.size) {
          case 'tiny':
            styleArr.push('margin-left: -15%');
            break;
          case 'small':
            styleArr.push('margin-left: -25%');
            break;
          case 'large':
            styleArr.push('margin-left: -45%');
            break;
          case 'full':
            styleArr.push('margin-left: -50%');
            break;
        }
      }
      return styleArr.join(';');
    }
  },
  watch: {
    visible(val) {
      this.$emit('update:visible', val);
      if (val) {
        this.closed = false;
        this.$emit('open');
        this.rendered = true;
        this.$el.addEventListener('scroll', this.updatePopper);
        window.addEventListener('resize', this.setStyle);
        this.$nextTick(() => {
          // 替换之前hui的打开dialog调整scrollTop的方法，调整为修改自定义滚动条 xx
          if (this.$refs.scrollbar) this.$refs.scrollbar.setScroll(0, 0);
          // this.$refs.dialog.scrollTop = 0;
          this.setStyle();
        });
        if (this.appendToBody) {
          document.body.appendChild(this.$el);
        }
      } else {
        this.$el.removeEventListener('scroll', this.updatePopper);
        window.removeEventListener('resize', this.setStyle);
        if (!this.closed) this.$emit('close');
        if (this.destroyOnClose) this.rendered = false;
      }
    }
  },
  mounted() {
    if (this.draggable) {
      utils_drag.bind(this.$refs.dialog);
    }
    if (this.visible) {
      this.rendered = true;
      this.open();
      if (this.appendToBody) {
        document.body.appendChild(this.$el);
      }
      this.$nextTick(() => {
        this.setStyle();
      });
    }
  },
  beforeDestroy() {
    if (this.draggable) {
      utils_drag.unbind(this.$refs.dialog); // 取消事件
    }
  },
  destroyed() {
    // if appendToBody is true, remove DOM node after destroy
    if (this.appendToBody && this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
  },
  methods: {
    afterLeave() {
      this.$emit('closed');
      if (this.destroyOnClose) this.rendered = false;
    },
    afterEnter() {
      this.$emit('opened');
    },
    handleWrapperClick() {
      if (!this.closeOnClickModal) return;
      this.handleClose();
    },
    handleClose() {
      if (typeof this.beforeClose === 'function') {
        this.beforeClose(this.hide);
      } else {
        this.hide();
      }
    },
    hide(cancel) {
      if (cancel !== false) {
        this.$emit('update:visible', false);
        this.$emit('visible-change', false);
        this.$emit('close');
        this.closed = true;
      }
    },
    updatePopper() {
      this.broadcast('ElSelectDropdown', 'updatePopper');
      this.broadcast('ElDropdownMenu', 'updatePopper');
    },
    setStyle() {
      const elDialog = this.$el.querySelector('.el-dialog');
      const h = Number(window.getComputedStyle(elDialog).getPropertyValue('height').replace('px', ''));
      const hw = Number(window.getComputedStyle(this.$el).getPropertyValue('height').replace('px', ''));
      if (h) {
        if (this.top === 'middle') {
          if (hw < h) {
            // 56px 由 dialog.scss margin-bottom 得到
            elDialog.style.marginTop = `${-h / 2 + (h - hw) / 2 + 56}px`;
          } else {
            elDialog.style.marginTop = `${-h / 2}px`;
          }
        }
        if (this.areaIsArray) {
          // 设置内容区高度
          const dialogBody = this.$el.querySelector('.el-dialog__body');
          let dialogFooterLength = 56;
          if (!this.$el.querySelector('.el-dialog__footer')) {
            dialogFooterLength = 0;
          }
          dialogBody.style.cssText = `height: ${h - 36 - dialogFooterLength}px;box-sizing: border-box`;
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/dialog/src/component.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_componentvue_type_script_lang_js_ = (componentvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/dialog/src/component.vue





/* normalize component */

var component_component = normalizeComponent(
  src_componentvue_type_script_lang_js_,
  componentvue_type_template_id_3eb6bf41_render,
  componentvue_type_template_id_3eb6bf41_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_component = (component_component.exports);
// CONCATENATED MODULE: ./packages/dialog/index.js


/* istanbul ignore next */
src_component.install = function (Vue) {
  Vue.component(src_component.name, src_component);
};
/* harmony default export */ var dialog = (src_component);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete.vue?vue&type=template&id=c067d538&
var autocompletevue_type_template_id_c067d538_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.close),expression:"close"}],staticClass:"el-autocomplete",class:[_vm.kind ? 'el-input--' + _vm.kind : '']},[_c('el-input',_vm._b({ref:"input",attrs:{"clearable":_vm.clearable,"maxlength":_vm.maxlength,"minlength":_vm.minlength,"tips":_vm.tips,"tips-max-width":_vm.tipsMaxWidth,"tips-placement":_vm.tipsPlacement,"tips-offset":_vm.tipsOffset,"tips-trigger":_vm.tipsTrigger,"tips-class":_vm.tipsClass},on:{"clear":_vm.clearValue,"change":_vm.handleChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur},nativeOn:{"compositionstart":function($event){return _vm.handleComposition.apply(null, arguments)},"compositionupdate":function($event){return _vm.handleComposition.apply(null, arguments)},"compositionend":function($event){return _vm.handleComposition.apply(null, arguments)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.highlight(_vm.highlightedIndex - 1)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.highlight(_vm.highlightedIndex + 1)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.handleKeyEnter.apply(null, arguments)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"tab",9,$event.key,"Tab")){ return null; }return _vm.close.apply(null, arguments)}]}},'el-input',_vm.$props,false),[(_vm.$slots.prefix)?_c('template',{slot:"prefix"},[_vm._t("prefix")],2):_vm._e(),(_vm.$slots.suffix)?_c('template',{slot:"suffix"},[_vm._t("suffix")],2):_vm._e(),(_vm.$slots.prepend)?_c('template',{slot:"prepend"},[_vm._t("prepend")],2):_vm._e(),(_vm.$slots.append)?_c('template',{slot:"append"},[_vm._t("append")],2):_vm._e()],2),_c('el-autocomplete-suggestions',{ref:"suggestions",class:[_vm.popperClass ? _vm.popperClass : ''],attrs:{"props":_vm.props,"suggestions":_vm.suggestions,"loading":_vm.loading,"append-to-body":_vm.popperAppendToBody,"placement":"bottom-start"}},[(_vm.$slots.content)?_c('template',{slot:"content"},[_vm._t("content")],2):_vm._e(),(_vm.$slots.bottom)?_c('template',{slot:"bottom"},[_vm._t("bottom")],2):_vm._e()],2)],1)}
var autocompletevue_type_template_id_c067d538_staticRenderFns = []


// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue?vue&type=template&id=c067d538&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=template&id=52aea0d6&
var autocomplete_suggestionsvue_type_template_id_52aea0d6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-enter":_vm.afterEnter,"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-autocomplete-suggestion",class:{ 'is-loading': _vm.parent.loading },style:({ width: _vm.dropdownWidth })},[_c('el-scrollbar',{ref:"scrollbar",attrs:{"is-small":true,"tag":"ul","wrap-class":"el-autocomplete-suggestion__wrap","view-class":"el-autocomplete-suggestion__list"}},[(_vm.parent.loading)?_c('li',{staticClass:"el-autocomplete__nodata"},[_c('el-load-icon')],1):(_vm.showNoMatch)?_c('div',{class:{ 'el-autocomplete__nodata': _vm.showNoMatch }},[_vm._v(" "+_vm._s(_vm.noMatch)+" ")]):(_vm.$slots.content)?[_vm._t("content")]:_c('div',[_vm._l((_vm.suggestions),function(item,index){return [(!_vm.parent.customItem)?_c('li',{key:index,staticClass:"el-autocomplete-suggestion__item",class:{ highlighted: _vm.itemSelected(item) },on:{"click":function($event){return _vm.select(item)}}},[_vm._v(" "+_vm._s(item[_vm.props.value] || item)+" ")]):_c(_vm.parent.customItem,{key:index,tag:"component",staticClass:"el-autocomplete-suggestion__item",attrs:{"select":_vm.select,"item":item,"index":index},on:{"click":function($event){return _vm.select(item)}}})]})],2)],2),(_vm.$slots.bottom)?[_vm._t("bottom")]:_vm._e()],2)])}
var autocomplete_suggestionsvue_type_template_id_52aea0d6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=template&id=52aea0d6&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ var autocomplete_suggestionsvue_type_script_lang_js_ = ({
  components: {
    ElScrollbar: scrollbar
  },
  mixins: [vue_popper, emitter],
  componentName: 'ElAutocompleteSuggestions',
  props: {
    props: {
      type: Object,
      default() {
        return {
          label: 'value',
          value: 'value'
        };
      }
    },
    suggestions: {
      type: Array,
      default: null
    }
  },
  data() {
    return {
      parent: this.$parent,
      dropdownWidth: '',
      noMatch: Object(locale_["t"])('el.cascader.noMatch'),
      showNoMatch: false
    };
  },
  watch: {
    suggestions(newValue, oldValue) {
      this.$nextTick(this.updatePopper);
      if (newValue.length) {
        this.showNoMatch = false;
      } else {
        if (this.parent.suggestionVisible) {
          this.showNoMatch = true;
        }
      }
    }
  },
  mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$refs.input.$refs.input;
  },
  created() {
    this.$on('visible', (val, inputWidth) => {
      this.dropdownWidth = inputWidth + 'px';
      this.showPopper = val;
    });
  },
  methods: {
    isEqual(a, b) {
      if (!this.isObject) {
        return a === b;
      } else {
        const valueKey = this.parent.valueKey;
        return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
      }
    },
    itemSelected(value) {
      return this.isEqual(value, this.parent.lastValue);
    },
    select(item) {
      this.dispatch('ElAutocomplete', 'item-click', item);
    },
    afterEnter() {
      this.$nextTick(() => this.$refs.scrollbar.throttleUpdate());
    }
  }
});
// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_autocomplete_suggestionsvue_type_script_lang_js_ = (autocomplete_suggestionsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete-suggestions.vue





/* normalize component */

var autocomplete_suggestions_component = normalizeComponent(
  src_autocomplete_suggestionsvue_type_script_lang_js_,
  autocomplete_suggestionsvue_type_template_id_52aea0d6_render,
  autocomplete_suggestionsvue_type_template_id_52aea0d6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var autocomplete_suggestions = (autocomplete_suggestions_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/autocomplete/src/autocomplete.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var autocompletevue_type_script_lang_js_ = ({
  name: 'ElAutocomplete',
  components: {
    ElInput: packages_input,
    ElAutocompleteSuggestions: autocomplete_suggestions
  },
  directives: {
    Clickoutside: clickoutside
  },
  mixins: [emitter],
  componentName: 'ElAutocomplete',
  props: {
    props: {
      type: Object,
      default() {
        return {
          value: 'value',
          label: 'value'
        };
      }
    },
    popperClass: {
      type: String,
      default: ''
    },
    placeholder: {
      type: String,
      default: ''
    },
    clearable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: ''
    },
    kind: {
      type: String,
      default: ''
    },
    clearIconClick: {
      type: Function,
      default: null
    },
    size: {
      type: String,
      default: ''
    },
    value: {
      type: String,
      default: ''
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    fetchSuggestions: {
      type: Function,
      default: null
    },
    triggerOnFocus: {
      type: Boolean,
      default: true
    },
    customItem: {
      type: String,
      default: ''
    },
    icon: {
      type: String,
      default: ''
    },
    onIconClick: {
      type: Function,
      default: null
    },
    debounce: {
      type: Number,
      default: 100
    },
    maxlength: {
      type: Number,
      default: null
    },
    minlength: {
      type: Number,
      default: null
    },
    // 提示信息，设置了tips才能显示popover
    tips: {
      type: String,
      default: null
    },
    // popover的最大宽度
    tipsMaxWidth: {
      type: null,
      default: null
    },
    // popover出现的位置
    tipsPlacement: {
      type: String,
      default: 'top-start'
    },
    // 出现位置的偏移量
    tipsOffset: {
      type: Number,
      default: 0
    },
    // popover触发方式
    tipsTrigger: {
      type: String,
      default: 'focus'
    },
    // popover触发方式
    tipsClass: {
      type: String,
      default: ''
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      activated: false,
      isOnComposition: false,
      suggestions: [],
      lastValue: {
        type: String,
        default: ''
      },
      loading: false,
      highlightedIndex: -1,
      ie: false // 判断是否是ie
    };
  },
  computed: {
    suggestionVisible() {
      const suggestions = this.suggestions;
      const isValidData = Array.isArray(suggestions);
      // 非激活情况下且suggestions为空数组时不显示建议
      const noSuggestion = !this.value.length && !this.suggestions.length && !this.triggerOnFocus;
      return !noSuggestion && isValidData && this.activated;
    }
  },
  watch: {
    suggestionVisible(val) {
      if (val) {
        this.$refs.suggestions.showNoMatch = false;
      }
      this.$emit('visible', this.suggestionVisible);
      this.broadcast('ElAutocompleteSuggestions', 'visible', [val, this.$refs.input.$refs.input.offsetWidth]);
    }
  },
  mounted() {
    // ie兼容
    if (!!window.ActiveXObject || 'ActiveXObject' in window) {
      this.ie = true;
    }
    this.$on('item-click', item => {
      this.select(item);
    });
  },
  beforeDestroy() {
    this.$refs.suggestions.$destroy();
  },
  methods: {
    clearValue() {
      if (!this.disabled) {
        // if (this.clearIconClick) {
        //   this.clearIconClick(event);
        // }
        this.$emit('input', '');
        this.activated = false;
        this.suggestions = [];
      }
    },
    getData(queryString) {
      this.loading = true;
      // this.activated = true;
      this.fetchSuggestions(queryString, suggestions => {
        if (Array.isArray(suggestions)) {
          this.suggestions = suggestions;
        } else {
          console.error('autocomplete suggestions must be an array');
        }
        this.loading = false;
      });
    },
    handleComposition(event) {
      if (event.type === 'compositionend') {
        this.isOnComposition = false;
        this.handleChange(event.target.value);
      } else {
        this.isOnComposition = true;
      }
    },
    handleChange(value, fromWrap) {
      this.activated = true;
      this.$emit('input', value);
      this.getData(value);
      this.index++;
      this.lastValue = value;
      if (this.isOnComposition || !this.triggerOnFocus && !value) {
        this.suggestions = [];
      }
    },
    handleFocus(event) {
      if (this.triggerOnFocus) {
        this.activated = true;
      }
      if (this.triggerOnFocus || this.value) {
        this.getData(this.value);
      }
      this.$emit('focus', event);
    },
    handleBlur(event) {
      this.$emit('blur', event);
    },
    close(e) {
      this.activated = false;
      this.suggestions = [];
    },
    handleKeyEnter(e) {
      if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
        e.preventDefault();
        this.select(this.suggestions[this.highlightedIndex]);
      }
    },
    select(item, index) {
      const selected = item[this.props.value] || item;
      // 如果选中的不是字符串则不做处理
      if (typeof selected !== 'string' && typeof selected !== 'number') return;
      this.lastValue = item;
      this.activated = false;
      this.$emit('input', selected);
      this.$emit('select', item);
      this.$nextTick(_ => {
        this.suggestions = [];
      });
    },
    highlight(index) {
      if (!this.suggestionVisible || this.loading) {
        return;
      }
      if (index < 0) index = 0;
      if (index >= this.suggestions.length) {
        index = this.suggestions.length - 1;
      }
      const suggestion = this.$refs.suggestions.$el.querySelector('.el-autocomplete-suggestion__wrap');
      const suggestionList = suggestion.querySelectorAll('.el-autocomplete-suggestion__list li');
      const highlightItem = suggestionList[index];
      const scrollTop = suggestion.scrollTop;
      const offsetTop = highlightItem.offsetTop;
      if (offsetTop + highlightItem.scrollHeight > scrollTop + suggestion.clientHeight) {
        suggestion.scrollTop += highlightItem.scrollHeight;
      }
      if (offsetTop < scrollTop) {
        suggestion.scrollTop -= highlightItem.scrollHeight;
      }
      this.highlightedIndex = index;
    }
  }
});
// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_autocompletevue_type_script_lang_js_ = (autocompletevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/autocomplete/src/autocomplete.vue





/* normalize component */

var autocomplete_component = normalizeComponent(
  src_autocompletevue_type_script_lang_js_,
  autocompletevue_type_template_id_c067d538_render,
  autocompletevue_type_template_id_c067d538_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var autocomplete = (autocomplete_component.exports);
// CONCATENATED MODULE: ./packages/autocomplete/index.js


/* istanbul ignore next */
autocomplete.install = function (Vue) {
  Vue.component(autocomplete.name, autocomplete);
};
/* harmony default export */ var packages_autocomplete = (autocomplete);
// CONCATENATED MODULE: ./src/mixins/migrating.js
/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */

/* harmony default export */ var migrating = ({
  mounted() {
    if (true) return;
    if (!this.$vnode) return;
    const {
      props = {},
      events = {}
    } = this.getMigratingConfig();
    const {
      data,
      componentOptions
    } = this.$vnode;
    const definedProps = data.attrs || {};
    const definedEvents = componentOptions.listeners || {};
    for (const propName in definedProps) {
      if (hasOwn(definedProps, propName) && props[propName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Attribute]: ${props[propName]}`);
      }
    }
    for (const eventName in definedEvents) {
      if (hasOwn(definedEvents, eventName) && events[eventName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Event]: ${events[eventName]}`);
      }
    }
  },
  methods: {
    getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=template&id=cd3e904a&
var button_groupvue_type_template_id_cd3e904a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-button-group"},[_vm._t("default")],2)}
var button_groupvue_type_template_id_cd3e904a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=template&id=cd3e904a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/button/src/button-group.vue?vue&type=script&lang=js&
//
//
//
//
//

/**
 * button
 * @module components/basic/menu
 * @desc 用于按钮组
 * @param {string} label - 名称
 */
/* harmony default export */ var button_groupvue_type_script_lang_js_ = ({
  name: 'ElButtonGroup'
});
// CONCATENATED MODULE: ./packages/button/src/button-group.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_button_groupvue_type_script_lang_js_ = (button_groupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/button/src/button-group.vue





/* normalize component */

var button_group_component = normalizeComponent(
  src_button_groupvue_type_script_lang_js_,
  button_groupvue_type_template_id_cd3e904a_render,
  button_groupvue_type_template_id_cd3e904a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var button_group = (button_group_component.exports);
// CONCATENATED MODULE: ./packages/button-group/index.js


/* istanbul ignore next */
button_group.install = function (Vue) {
  Vue.component(button_group.name, button_group);
};
/* harmony default export */ var packages_button_group = (button_group);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown.vue?vue&type=script&lang=js&






/* harmony default export */ var dropdownvue_type_script_lang_js_ = ({
  name: 'ElDropdown',
  componentName: 'ElDropdown',
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    ElButton: packages_button,
    ElButtonGroup: packages_button_group
  },
  mixins: [emitter, migrating],
  provide() {
    return {
      dropdown: this
    };
  },
  props: {
    trigger: {
      type: String,
      default: 'hover'
    },
    type: {
      type: String,
      default: ''
    },
    size: {
      type: String,
      default: ''
    },
    splitButton: {
      type: Boolean,
      default: null
    },
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'bottom-end'
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    showTimeout: {
      type: Number,
      default: 250
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    hideOnClickOutside: {
      type: Boolean,
      default: true
    },
    isItemKeyEnterShow: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      timeout: null,
      visible: false,
      triggerElm: null,
      menuItems: null,
      menuItemsArray: null,
      dropdownElm: null,
      focusing: false,
      listId: `dropdown-menu-${generateId()}`
    };
  },
  computed: {
    dropdownSize() {
      return this.size || (this.$ELEMENT || {}).size;
    }
  },
  watch: {
    visible(val) {
      this.broadcast('ElDropdownMenu', 'visible', val);
      this.$emit('visible-change', val);
    },
    focusing(val) {
      const selfDefine = this.$el.querySelector('.el-dropdown-selfdefine');
      if (selfDefine) {
        // 自定义
        if (val) {
          selfDefine.className += ' focusing';
        } else {
          selfDefine.className = selfDefine.className.replace('focusing', '');
        }
      }
    }
  },
  mounted() {
    this.$on('menu-item-click', this.handleMenuItemClick);
    this.initEvent();
    this.initAria();
  },
  methods: {
    getMigratingConfig() {
      return {
        props: {
          'menu-align': 'menu-align is renamed to placement.'
        }
      };
    },
    show() {
      if (this.triggerElm.disabled) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => {
        this.visible = true;
      }, this.trigger === 'click' ? 0 : this.showTimeout);
    },
    hide() {
      if (this.triggerElm.disabled) return;
      this.removeTabindex();
      this.resetTabindex(this.triggerElm);
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => {
        this.visible = false;
      }, this.trigger === 'click' ? 0 : this.hideTimeout);
    },
    handleClick() {
      if (this.triggerElm.disabled) return;
      if (this.visible) {
        this.hide();
      } else {
        this.show();
      }
    },
    clickOutside() {
      if (this.hideOnClickOutside) {
        this.hide();
      }
    },
    handleTriggerKeyDown(ev) {
      const keyCode = ev.keyCode;
      if ([38, 40].indexOf(keyCode) > -1) {
        // up/down
        this.removeTabindex();
        this.resetTabindex(this.menuItems[0]);
        this.menuItems[0].focus();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (keyCode === 13) {
        // space enter选中
        this.handleClick();
      } else if ([9, 27].indexOf(keyCode) > -1) {
        // tab || esc
        this.hide();
      }
    },
    handleItemKeyDown(ev) {
      const keyCode = ev.keyCode;
      const target = ev.target;
      const currentIndex = this.menuItemsArray.indexOf(target);
      const max = this.menuItemsArray.length - 1;
      let nextIndex;
      if ([38, 40].indexOf(keyCode) > -1) {
        // up/down
        if (keyCode === 38) {
          // up
          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
        } else {
          // down
          nextIndex = currentIndex < max ? currentIndex + 1 : max;
        }
        this.removeTabindex();
        this.resetTabindex(this.menuItems[nextIndex]);
        this.menuItems[nextIndex].focus();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (keyCode === 13) {
        // enter选中
        this.triggerElm.focus();
        target.click();
        // item回车是否隐藏，默认false
        if (this.hideOnClick && !this.isItemKeyEnterShow) {
          // click关闭
          this.visible = false;
        }
      } else if ([9, 27].indexOf(keyCode) > -1) {
        // tab // esc
        this.hide();
        this.triggerElm.focus();
      }
    },
    resetTabindex(ele) {
      // 下次tab时组件聚焦元素
      this.removeTabindex();
      ele.setAttribute('tabindex', '0'); // 下次期望的聚焦元素
    },
    removeTabindex() {
      this.triggerElm.setAttribute('tabindex', '-1');
      this.menuItemsArray.forEach(item => {
        item.setAttribute('tabindex', '-1');
      });
    },
    initAria() {
      this.dropdownElm.setAttribute('id', this.listId);
      this.triggerElm.setAttribute('aria-haspopup', 'list');
      this.triggerElm.setAttribute('aria-controls', this.listId);
      this.menuItems = this.dropdownElm.querySelectorAll("[tabindex='-1']");
      this.menuItemsArray = Array.prototype.slice.call(this.menuItems);
      if (!this.splitButton) {
        // 自定义
        this.triggerElm.setAttribute('role', 'button');
        this.triggerElm.setAttribute('tabindex', '0');
        this.triggerElm.setAttribute('class', (this.triggerElm.getAttribute('class') || '') + ' el-dropdown-selfdefine'); // 控制
      }
    },
    initEvent() {
      const {
        trigger,
        show,
        hide,
        handleClick,
        splitButton,
        handleTriggerKeyDown,
        handleItemKeyDown
      } = this;
      this.triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;
      const dropdownElm = this.dropdownElm = this.$slots.dropdown[0].elm;
      this.triggerElm.addEventListener('keydown', handleTriggerKeyDown); // triggerElm keydown
      dropdownElm.addEventListener('keydown', handleItemKeyDown, true); // item keydown
      // 控制自定义元素的样式
      if (!splitButton) {
        this.triggerElm.addEventListener('focus', () => {
          this.focusing = true;
        });
        this.triggerElm.addEventListener('blur', () => {
          this.focusing = false;
        });
        this.triggerElm.addEventListener('click', () => {
          this.focusing = false;
        });
      }
      if (trigger === 'hover') {
        this.triggerElm.addEventListener('mouseenter', show);
        this.triggerElm.addEventListener('mouseleave', hide);
        dropdownElm.addEventListener('mouseenter', show);
        dropdownElm.addEventListener('mouseleave', hide);
      } else if (trigger === 'click') {
        this.triggerElm.addEventListener('click', handleClick);
      }
    },
    handleMenuItemClick(command, instance) {
      if (this.hideOnClick) {
        this.visible = false;
      }
      this.$emit('command', command, instance);
    },
    focus() {
      this.triggerElm.focus && this.triggerElm.focus();
    }
  },
  render() {
    const h = arguments[0];
    const {
      hide,
      clickOutside,
      splitButton,
      type,
      dropdownSize
    } = this;
    const handleMainButtonClick = event => {
      this.$emit('click', event);
      hide();
    };
    const triggerElm = !splitButton ? this.$slots.default : h("el-button-group", [h("el-button", {
      "attrs": {
        "type": type,
        "size": dropdownSize
      },
      "nativeOn": {
        "click": handleMainButtonClick
      }
    }, [this.$slots.default]), h("el-button", {
      "ref": 'trigger',
      "attrs": {
        "type": type,
        "size": dropdownSize
      },
      "class": 'el-dropdown__caret-button'
    }, [h("i", {
      "class": 'el-dropdown__icon h-icon-angle_down_sm'
    })])]);
    return h("div", {
      "class": 'el-dropdown',
      "directives": [{
        name: "clickoutside",
        value: clickOutside
      }]
    }, [triggerElm, this.$slots.dropdown]);
  }
});
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_dropdownvue_type_script_lang_js_ = (dropdownvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown.vue
var dropdown_render, dropdown_staticRenderFns




/* normalize component */

var dropdown_component = normalizeComponent(
  src_dropdownvue_type_script_lang_js_,
  dropdown_render,
  dropdown_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var dropdown = (dropdown_component.exports);
// CONCATENATED MODULE: ./packages/dropdown/index.js


/* istanbul ignore next */
dropdown.install = function (Vue) {
  Vue.component(dropdown.name, dropdown);
};
/* harmony default export */ var packages_dropdown = (dropdown);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=7cb22fe0&
var dropdown_menuvue_type_template_id_7cb22fe0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":_vm.doDestroy}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-dropdown-menu el-popper",class:[_vm.size && ("el-dropdown-menu--" + _vm.size)]},[_vm._t("default")],2)])}
var dropdown_menuvue_type_template_id_7cb22fe0_staticRenderFns = []


// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=7cb22fe0&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var dropdown_menuvue_type_script_lang_js_ = ({
  name: 'ElDropdownMenu',
  componentName: 'ElDropdownMenu',
  mixins: [vue_popper],
  props: {
    visibleArrow: {
      type: Boolean,
      default: false
    },
    offset: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      size: this.dropdown.dropdownSize
    };
  },
  inject: ['dropdown'],
  watch: {
    'dropdown.placement': {
      immediate: true,
      handler(val) {
        this.currentPlacement = val;
      }
    }
  },
  created() {
    this.$on('updatePopper', () => {
      if (this.showPopper) this.updatePopper();
    });
    this.$on('visible', val => {
      this.showPopper = val;
    });
  },
  mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$el;
  }
});
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_dropdown_menuvue_type_script_lang_js_ = (dropdown_menuvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue





/* normalize component */

var dropdown_menu_component = normalizeComponent(
  src_dropdown_menuvue_type_script_lang_js_,
  dropdown_menuvue_type_template_id_7cb22fe0_render,
  dropdown_menuvue_type_template_id_7cb22fe0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var dropdown_menu = (dropdown_menu_component.exports);
// CONCATENATED MODULE: ./packages/dropdown-menu/index.js


/* istanbul ignore next */
dropdown_menu.install = function (Vue) {
  Vue.component(dropdown_menu.name, dropdown_menu);
};
/* harmony default export */ var packages_dropdown_menu = (dropdown_menu);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-item.vue?vue&type=template&id=634e0f7e&
var dropdown_itemvue_type_template_id_634e0f7e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-dropdown-menu__item",class:{
    'is-disabled': _vm.disabled,
    'el-dropdown-menu__item--divided': _vm.divided
  },attrs:{"aria-disabled":_vm.disabled,"tabindex":_vm.disabled ? null : -1},on:{"click":_vm.handleClick}},[_vm._t("default")],2)}
var dropdown_itemvue_type_template_id_634e0f7e_staticRenderFns = []


// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue?vue&type=template&id=634e0f7e&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var dropdown_itemvue_type_script_lang_js_ = ({
  name: 'ElDropdownItem',
  mixins: [emitter],
  props: {
    command: {
      type: null,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    divided: {
      type: Boolean,
      default: null
    }
  },
  methods: {
    handleClick() {
      this.dispatch('ElDropdown', 'menu-item-click', [this.command, this]);
    }
  }
});
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_dropdown_itemvue_type_script_lang_js_ = (dropdown_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/dropdown/src/dropdown-item.vue





/* normalize component */

var dropdown_item_component = normalizeComponent(
  src_dropdown_itemvue_type_script_lang_js_,
  dropdown_itemvue_type_template_id_634e0f7e_render,
  dropdown_itemvue_type_template_id_634e0f7e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var dropdown_item = (dropdown_item_component.exports);
// CONCATENATED MODULE: ./packages/dropdown-item/index.js


/* istanbul ignore next */
dropdown_item.install = function (Vue) {
  Vue.component(dropdown_item.name, dropdown_item);
};
/* harmony default export */ var packages_dropdown_item = (dropdown_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu.vue?vue&type=template&id=7e6aa5a4&
var menuvue_type_template_id_7e6aa5a4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-menu-collapse-transition',[_c('ul',{key:+_vm.collapse,staticClass:"el-menu",class:{
      'el-menu--horizontal': _vm.mode === 'horizontal',
      'el-menu--collapse': _vm.collapse
    }},[_vm._t("menu-top"),(_vm.collapseBtn)?_c('li',{staticClass:"el-menu--colloase-btn",on:{"click":_vm.collapseMenu}},[_c('div',{staticClass:"el-submenu__title"},[_c('i',{staticClass:"el-menu-icon h-icon-menu_leftbar"})])]):_vm._e(),_vm._t("default")],2)])}
var menuvue_type_template_id_7e6aa5a4_staticRenderFns = []


// CONCATENATED MODULE: ./packages/menu/src/menu.vue?vue&type=template&id=7e6aa5a4&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var menuvue_type_script_lang_js_ = ({
  name: 'ElMenu',
  componentName: 'ElMenu',
  components: {
    'el-menu-collapse-transition': {
      functional: true,
      render(createElement, context) {
        const data = {
          props: {
            mode: 'out-in'
          },
          on: {
            beforeEnter(el) {
              el.style.opacity = 0.2;
            },
            enter(el) {
              addClass(el, 'el-opacity-transition');
              el.style.opacity = 1;
            },
            afterEnter(el) {
              removeClass(el, 'el-opacity-transition');
              el.style.opacity = '';
            },
            beforeLeave(el) {
              if (!el.dataset) el.dataset = {};
              if (hasClass(el, 'el-menu--collapse')) {
                removeClass(el, 'el-menu--collapse');
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.scrollWidth;
                addClass(el, 'el-menu--collapse');
              }
              el.style.width = el.scrollWidth + 'px';
              el.style.overflow = 'hidden';
            },
            leave(el) {
              if (!hasClass(el, 'el-menu--collapse')) {
                addClass(el, 'horizontal-collapse-transition');
                el.style.width = '48px';
              } else {
                addClass(el, 'horizontal-collapse-transition');
                el.style.width = el.dataset.scrollWidth + 'px';
              }
            },
            afterLeave(el) {
              removeClass(el, 'horizontal-collapse-transition');
              if (hasClass(el, 'el-menu--collapse')) {
                el.style.width = el.dataset.scrollWidth + 'px';
              } else {
                el.style.width = '48px';
              }
              el.style.overflow = el.dataset.oldOverflow;
            }
          }
        };
        return createElement('transition', data, context.children);
      }
    }
  },
  mixins: [emitter],
  provide() {
    return {
      rootMenu: this
    };
  },
  props: {
    mode: {
      type: String,
      default: 'vertical'
    },
    defaultActive: {
      type: String,
      default: ''
    },
    defaultOpeneds: {
      type: Array,
      default: null
    },
    // theme: {
    //   type: String,
    //   default: 'light'
    // },
    uniqueOpened: {
      type: Boolean,
      default: null
    },
    router: {
      type: Boolean,
      default: null
    },
    menuTrigger: {
      type: String,
      default: 'hover'
    },
    collapse: {
      type: Boolean,
      default: null
    },
    collapseBtn: {
      type: Boolean,
      default: null
    },
    collapseBtnClick: {
      type: Function,
      default: null
    },
    noIcon: {
      type: Boolean,
      default: false
    },
    wrapScroll: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      activeIndex: this.defaultActive,
      openedMenus: this.defaultOpeneds ? this.defaultOpeneds.slice(0) : [],
      openedCollapseMenus: [],
      // 打开的子菜单
      items: {},
      submenus: {}
    };
  },
  watch: {
    defaultActive(value) {
      const item = this.items[value];
      if (item) {
        this.activeIndex = item.index;
        this.initOpenedMenu();
      } else {
        this.activeIndex = '';
      }
    },
    defaultOpeneds(value) {
      this.openedMenus = value;
    },
    collapse(value) {
      if (value) {
        this.openedMenus = [];
        this.openedCollapseMenus = [];
        this.$emit('fold');
      } else {
        this.$emit('unfold');
      }
    }
  },
  mounted() {
    this.initOpenedMenu();
    this.$on('item-click', this.handleItemClick);
    this.$on('submenu-click', this.handleSubmenuClick);
  },
  methods: {
    addItem(item) {
      this.$set(this.items, item.index, item);
    },
    removeItem(item) {
      delete this.items[item.index];
    },
    addSubmenu(item) {
      this.$set(this.submenus, item.index, item);
    },
    removeSubmenu(item) {
      delete this.submenus[item.index];
    },
    openMenu(index, indexPath) {
      const openedMenus = this.openedMenus;
      if (openedMenus.indexOf(index) !== -1) return;
      // 将不在该菜单路径下的其余菜单收起
      if (this.uniqueOpened) {
        this.openedMenus = openedMenus.filter(index => {
          return indexPath.indexOf(index) !== -1;
        });
      }
      this.openedMenus.push(index);
    },
    closeMenu(index) {
      const i = this.openedMenus.indexOf(index);
      if (i !== -1) {
        this.openedMenus.splice(i, 1);
      }
    },
    // 关闭所有展开的子菜单
    closeCollapseMenu() {
      this.openedCollapseMenus.forEach(index => {
        const i = this.openedMenus.indexOf(index);
        if (i !== -1) {
          this.openedMenus.splice(i, 1);
        }
      });
      this.openedCollapseMenus.length = 0;
    },
    handleSubmenuClick(submenu) {
      const {
        index,
        indexPath
      } = submenu;
      const isOpened = this.openedMenus.indexOf(index) !== -1;
      if (isOpened) {
        this.closeMenu(index);
        this.$emit('close', index, indexPath);
      } else {
        this.openMenu(index, indexPath);
        this.$emit('open', index, indexPath);
      }
    },
    handleItemClick(item) {
      const {
        index,
        indexPath
      } = item;
      this.activeIndex = item.index;
      this.$emit('select', index, indexPath, item);
      if (this.mode === 'horizontal' || this.collapse) {
        this.openedMenus = [];
      }
      if (this.router) {
        this.routeToItem(item, error => {
          if (error) {
            // vue-router 3.1.0+ push/replace cause NavigationDuplicated error
            if (error.name === 'NavigationDuplicated') return;
            console.error(error);
          }
        });
      }
    },
    // 初始化展开菜单
    initOpenedMenu() {
      const index = this.activeIndex;
      const activeItem = this.items[index];
      if (!activeItem || this.mode === 'horizontal' || this.collapse) return;
      const indexPath = activeItem.indexPath;

      // 展开该菜单项的路径上所有子菜单
      indexPath.forEach(index => {
        const submenu = this.submenus[index];
        submenu && this.openMenu(index, submenu.indexPath);
      });
    },
    routeToItem(item, onError) {
      const route = item.route || item.index;
      try {
        this.$router.push(route, () => {}, onError);
      } catch (e) {
        console.error(e);
      }
    },
    collapseMenu() {
      // 由于 prop 是单向绑定的，需要通过调用外部事件来完成
      this.$emit('click-collapse');
      if (this.wrapScroll) {
        this.closeCollapseMenu();
      }
    },
    open(index) {
      const {
        indexPath
      } = this.submenus[index.toString()];
      indexPath.forEach(i => this.openMenu(i, indexPath));
    },
    close(index) {
      this.closeMenu(index.toString());
    }
  }
});
// CONCATENATED MODULE: ./packages/menu/src/menu.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_menuvue_type_script_lang_js_ = (menuvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/menu/src/menu.vue





/* normalize component */

var menu_component = normalizeComponent(
  src_menuvue_type_script_lang_js_,
  menuvue_type_template_id_7e6aa5a4_render,
  menuvue_type_template_id_7e6aa5a4_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_menu = (menu_component.exports);
// CONCATENATED MODULE: ./packages/menu/index.js


/* istanbul ignore next */
src_menu.install = function (Vue) {
  Vue.component(src_menu.name, src_menu);
};
/* harmony default export */ var packages_menu = (src_menu);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/submenu.vue?vue&type=template&id=5bf95ff7&
var submenuvue_type_template_id_5bf95ff7_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{class:{
    'el-submenu': true,
    'is-active': _vm.active,
    'is-opened': _vm.opened,
    'is-disabled': _vm.disabled
  },on:{"mouseenter":_vm.handleMouseenter,"mouseleave":_vm.handleMouseleave}},[_c('div',{ref:"submenu-title",staticClass:"el-submenu__title",style:(_vm.paddingStyle),attrs:{"title":!_vm.rootMenu.collapse && !_vm.disabled && (_vm.isIe || _vm.textEllipsis) && _vm.title},on:{"click":_vm.handleClick}},[(_vm.$slots.icon)?_c('i',{staticClass:"el-menu-icon is-slot"},[_vm._t("icon")],2):(_vm.icon)?_c('i',{staticClass:"el-menu-icon",class:_vm.icon}):_vm._e(),(_vm.$slots.title)?_c('span',{staticClass:"el-submenu__title--text"},[_vm._t("title")],2):_c('span',{staticClass:"el-submenu__title--text"},[_vm._v(_vm._s(_vm.title))]),_c('i',{class:{
        'el-submenu__icon-arrow': true,
        'h-icon-angle_down_sm':
          _vm.rootMenu.mode === 'horizontal' ||
          (_vm.rootMenu.mode === 'vertical' && !_vm.rootMenu.collapse),
        'h-icon-angle_right_sm':
          _vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse
      }})]),(_vm.rootMenu.mode === 'horizontal')?[_c('transition',{attrs:{"name":_vm.menuTransitionName}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],staticClass:"el-menu"},[_vm._t("default")],2)])]:(_vm.rootMenu.mode === 'vertical' && _vm.rootMenu.collapse)?[_c('transition',{attrs:{"name":_vm.menuTransitionName}},[(!_vm.rootMenu.wrapScroll)?_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],staticClass:"el-menu"},[(_vm.title && _vm.level === 1)?_c('li',{staticClass:"el-submenu__collpase-title"},[_vm._v(" "+_vm._s(_vm.title)+" ")]):_vm._e(),_vm._t("default")],2):_c('el-menu-collapse',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],ref:"collapseMenu",attrs:{"root-menu":_vm.rootMenu},on:{"mouse-enter":_vm.handleMouseenter,"leave-collapse":_vm.leaveCollapse}},[(_vm.title && _vm.level === 1)?_c('li',{staticClass:"el-submenu__collpase-title"},[_vm._v(" "+_vm._s(_vm.title)+" ")]):_vm._e(),_vm._t("default")],2)],1)]:_c('el-collapse-transition',[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.opened),expression:"opened"}],staticClass:"el-menu"},[_vm._t("default")],2)])],2)}
var submenuvue_type_template_id_5bf95ff7_staticRenderFns = []


// CONCATENATED MODULE: ./packages/menu/src/submenu.vue?vue&type=template&id=5bf95ff7&

// CONCATENATED MODULE: ./src/transitions/collapse-transition.js

/* harmony default export */ var collapse_transition = ({
  name: 'ElCollapseTransition',
  functional: true,
  render(h, {
    children
  }) {
    const data = {
      on: {
        beforeEnter(el) {
          addClass(el, 'collapse-transition');
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.height = '0';
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter(el) {
          el.dataset.oldOverflow = el.style.overflow;
          if (el.scrollHeight !== 0) {
            el.style.height = el.scrollHeight + 'px';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = '';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
          el.style.overflow = 'hidden';
        },
        afterEnter(el) {
          // for safari: remove class then reset height is necessary
          removeClass(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave(el) {
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.height = el.scrollHeight + 'px';
          el.style.overflow = 'hidden';
        },
        leave(el) {
          if (el.scrollHeight !== 0) {
            // for safari: add class after set height, or it will jump to zero height suddenly, weired
            addClass(el, 'collapse-transition');
            el.style.height = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave(el) {
          removeClass(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      }
    };
    return h('transition', data, children);
  }
});
// CONCATENATED MODULE: ./packages/menu/src/menu-mixin.js
/* harmony default export */ var menu_mixin = ({
  computed: {
    indexPath() {
      var path = [this.index];
      var parent = this.$parent;
      while (parent.$options.componentName !== 'ElMenu') {
        if (parent.index) {
          path.unshift(parent.index);
        }
        parent = parent.$parent;
      }
      return path;
    },
    rootMenu() {
      var parent = this.$parent;
      while (parent && parent.$options.componentName !== 'ElMenu') {
        parent = parent.$parent;
      }
      return parent;
    },
    parentMenu() {
      let parent = this.$parent;
      while (parent && ['ElMenu', 'ElSubmenu'].indexOf(parent.$options.componentName) === -1) {
        parent = parent.$parent;
      }
      return parent;
    },
    paddingStyle() {
      if (this.rootMenu.mode !== 'vertical') return {};
      let gutter = 12;
      let parent = this.$parent;
      if (this.rootMenu.collapse || !parent) {
        return {};
      } else {
        if (parent.$options.componentName === 'ElSubmenu') {
          gutter = 48; // 第一层子菜单左侧间距，和第一层菜单齐平
          parent = parent.$parent;
          while (parent && parent.$options.componentName !== 'ElMenu') {
            // 子菜单每层缩进 16px
            if (parent.$options.componentName === 'ElSubmenu') {
              gutter += 16;
            }
            parent = parent.$parent;
          }
        } else {
          gutter = this.icon || this.$slots.icon ? 12 : 24; // 第一层菜单左侧间距
        }
        return {
          paddingLeft: gutter + 'px'
        };
      }
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/submenu.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






const HIDE_TIME = 20;
/* harmony default export */ var submenuvue_type_script_lang_js_ = ({
  name: 'ElSubmenu',
  componentName: 'ElSubmenu',
  components: {
    ElCollapseTransition: collapse_transition
  },
  mixins: [menu_mixin, emitter],
  props: {
    index: {
      type: String,
      required: true
    },
    icon: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      isIe: false,
      timeout: null,
      items: {},
      submenus: {},
      collapseEl: null,
      // 折叠元素
      textEllipsis: false,
      level: 1,
      hideTimer: null
    };
  },
  computed: {
    menuTransitionName() {
      return this.rootMenu.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
    },
    opened() {
      return this.rootMenu.openedMenus.indexOf(this.index) > -1;
    },
    active: {
      cache: false,
      get() {
        let isActive = false;
        const submenus = this.submenus;
        const items = this.items;
        Object.keys(items).forEach(index => {
          if (items[index].active) {
            isActive = true;
          }
        });
        Object.keys(submenus).forEach(index => {
          if (submenus[index].active) {
            isActive = true;
          }
        });
        return isActive;
      }
    }
  },
  watch: {
    opened(val) {
      const {
        rootMenu
      } = this;
      if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal') {
        const {
          index,
          indexPath
        } = this;
        val ? rootMenu.$emit('open', index, indexPath) : rootMenu.$emit('close', index, indexPath);
      }
    }
  },
  created() {
    // 获取上级子菜单
    const $subMenu = this.rootMenu.wrapScroll ? this.$parent.$parent : this.$parent;
    // 第一个子菜单level为1，嵌套子菜单递增
    this.level = $subMenu.level ? $subMenu.level + 1 : 1;
    this.parentMenu.addSubmenu(this);
    this.rootMenu.addSubmenu(this);
  },
  mounted() {
    addResizeListener(this.$el, this.setTextEllipsis);
    if (!!window.ActiveXObject || 'ActiveXObject' in window) {
      this.isIe = true;
    }
  },
  beforeDestroy() {
    this.parentMenu.removeSubmenu(this);
    this.rootMenu.removeSubmenu(this);
    removeResizeListener(this.$el, this.setTextEllipsis);
  },
  methods: {
    addItem(item) {
      this.$set(this.items, item.index, item);
    },
    removeItem(item) {
      delete this.items[item.index];
    },
    addSubmenu(item) {
      this.$set(this.submenus, item.index, item);
    },
    removeSubmenu(item) {
      delete this.submenus[item.index];
    },
    handleClick() {
      const {
        rootMenu
      } = this;
      if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical' || this.disabled) {
        return;
      }
      this.dispatch('ElMenu', 'submenu-click', this);
    },
    handleMouseenter(event) {
      const {
        rootMenu
      } = this;
      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical' || this.disabled) {
        return;
      }
      const fromElement = event.fromElement || event.originalTarget;
      // 若从滚动条移动到菜单（菜单使用滚动条控件的情况）
      if (closest(fromElement, '.el-scrollbar__bar') || closest(fromElement, '.el-scrollbar__thumb')) {
        this.rootMenu.closeCollapseMenu();
      }

      // 打开菜单
      clearTimeout(this.hideTimer);
      this.rootMenu.openMenu(this.index, this.indexPath);

      // 属性 wrapScroll 为 true，且不存在 collapseEl
      // 或者存在 collapseEl，但收缩菜单未打开（解决菜单会重叠问题）
      if (rootMenu.wrapScroll && this.$refs.collapseMenu && !this.collapseEl || this.collapseEl && this.rootMenu.openedCollapseMenus.indexOf(this.index) === -1) {
        // 加载收缩菜单
        this.collapseEl = this.$refs.collapseMenu.loadCollapseMenu();
        if (this.rootMenu.openedCollapseMenus.indexOf(this.index) === -1) {
          // 将index加入到子菜单数组中
          this.rootMenu.openedCollapseMenus.push(this.index);
        }
      }
    },
    handleMouseleave(event) {
      const {
        rootMenu
      } = this;
      const activeIndex = this.index;
      if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
        return;
      }

      // 关闭菜单
      this.hideTimer = setTimeout(() => {
        this.rootMenu.closeMenu(activeIndex);
      }, HIDE_TIME);
      if (rootMenu.wrapScroll) {
        // 处理firefox兼容性（chrome 为 toElement，firefox 为 relatedTarget）
        const toElement = event.toElement || event.relatedTarget;

        // 若移动到自身的子菜单上
        if (this.$refs.collapseMenu && closest(toElement, '.el-menu-collapse-wrap') === this.$refs.collapseMenu.$el) {
          return;
        }

        // 若移动到滚动条上（菜单使用滚动条控件的情况）
        if (closest(toElement, '.el-scrollbar__bar') || closest(toElement, '.el-scrollbar__thumb')) {
          return;
        }
      }

      // 关闭收缩菜单
      if (rootMenu.wrapScroll) this.emitHideCollapse();
    },
    // 鼠标离开子菜单后
    leaveCollapse(event) {
      const toElement = event.toElement || event.relatedTarget;
      const activeIndex = this.index;
      // 若鼠标没有回到菜单，则关闭所有子菜单
      if (closest(toElement, '.el-menu') == null && closest(toElement, '.el-menu-collapse-wrap') === null) {
        this.rootMenu.closeCollapseMenu();
      }
      // 若鼠标没回到父菜单，则关闭当前子菜单
      if (closest(toElement, '.el-submenu') !== this.$el) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          this.rootMenu.closeMenu(activeIndex);
          this.emitHideCollapse();
        }, 100);
      }
    },
    // 触发隐藏折叠菜单事件
    emitHideCollapse() {
      this.rootMenu.$emit('hide-collapse', this.collapseEl);
      this.collapseEl = null;
    },
    /**
     * @desc 判断文本是否超长，超长则显示省略号
     * @author chenguanbin
     */
    setTextEllipsis() {
      const $text = this.$el.querySelector('.el-submenu__title--text');
      if (!$text || !$text.parentNode) return;
      const gutter = 84; // 菜单项左右的间距
      this.textEllipsis = $text.offsetWidth > $text.parentNode.offsetWidth - gutter;
    }
  }
});
// CONCATENATED MODULE: ./packages/menu/src/submenu.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_submenuvue_type_script_lang_js_ = (submenuvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/menu/src/submenu.vue





/* normalize component */

var submenu_component = normalizeComponent(
  src_submenuvue_type_script_lang_js_,
  submenuvue_type_template_id_5bf95ff7_render,
  submenuvue_type_template_id_5bf95ff7_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var submenu = (submenu_component.exports);
// CONCATENATED MODULE: ./packages/submenu/index.js


/* istanbul ignore next */
submenu.install = function (Vue) {
  Vue.component(submenu.name, submenu);
};
/* harmony default export */ var packages_submenu = (submenu);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item.vue?vue&type=template&id=7d955dd8&
var menu_itemvue_type_template_id_7d955dd8_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-menu-item",class:{
    'is-active': _vm.active,
    'is-disabled': _vm.disabled
  },style:(_vm.paddingStyle),attrs:{"title":_vm.rootMenu.mode === 'vertical' &&
      !_vm.rootMenu.collapse &&
      !_vm.disabled &&
      (_vm.isIe || _vm.textEllipsis) &&
      _vm.$slots.default &&
      _vm.$slots.default[0].text},on:{"click":_vm.handleClick}},[(_vm.parentMenu === _vm.rootMenu && _vm.rootMenu.collapse)?_c('el-tooltip',{attrs:{"effect":"dark","placement":"right","popper-class":"tooltip-for-menu-item"}},[_c('div',{attrs:{"slot":"content"},slot:"content"},[_vm._v(" "+_vm._s(_vm.$slots.default[0].text)+" ")]),_c('div',{staticClass:"el-menu-item__collapse"},[(_vm.$slots.icon)?_c('i',{staticClass:"el-menu-icon is-slot"},[_vm._t("icon")],2):(_vm.icon)?_c('i',{staticClass:"el-menu-icon",class:_vm.icon}):_vm._e(),_c('span',{staticClass:"el-menu-item--text"},[_vm._t("default")],2)])]):[(_vm.$slots.icon)?_c('i',{staticClass:"el-menu-icon is-slot"},[_vm._t("icon")],2):(_vm.icon)?_c('i',{staticClass:"el-menu-icon",class:_vm.icon}):_vm._e(),_c('span',{staticClass:"el-menu-item--text"},[_vm._t("default")],2)]],2)}
var menu_itemvue_type_template_id_7d955dd8_staticRenderFns = []


// CONCATENATED MODULE: ./packages/menu/src/menu-item.vue?vue&type=template&id=7d955dd8&

// CONCATENATED MODULE: ./packages/tooltip/src/main.js




/* harmony default export */ var tooltip_src_main = ({
  name: 'ElTooltip',
  mixins: [vue_popper],
  props: {
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    manual: {
      type: Boolean,
      default: null
    },
    effect: {
      type: String,
      default: 'light'
    },
    popperClass: {
      type: String,
      default: null
    },
    content: {
      type: String,
      default: null
    },
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default() {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        };
      }
    },
    enterable: {
      type: Boolean,
      default: false
    },
    debounceClosable: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      focusing: false
    };
  },
  watch: {
    disabled(val) {
      if (!val) return;
      this.showPopper = false;
    },
    focusing(val) {
      if (val) {
        addClass(this.referenceElm, 'focusing');
      } else {
        removeClass(this.referenceElm, 'focusing');
      }
    }
  },
  beforeCreate() {
    if (this.$isServer) return;
    this.popperVM = new external_vue_default.a({
      data: {
        node: ''
      },
      render() {
        return this.node;
      }
    }).$mount();
    this.debounceClose = debounce_default()(200, () => this.handleClosePopper());
  },
  render() {
    const h = arguments[0];
    if (this.popperVM) {
      this.popperVM.node = h("transition", {
        "attrs": {
          "name": this.transition
        },
        "on": {
          "afterLeave": this.doDestroy
        }
      }, [h("div", {
        "on": {
          "mouseleave": () => {
            this.setExpectedState(false);
            this.debounceClosable ? this.debounceClose() : this.handleClosePopper();
            // this.hide();
          },
          "mouseenter": () => {
            this.setExpectedState(true);
          }
        },
        "ref": 'popper',
        "directives": [{
          name: "show",
          value: !this.disabled && this.showPopper
        }],
        "class": ['el-tooltip__popper', 'is-' + this.effect, this.popperClass]
      }, [this.$slots.content || this.content])]);
    }
    if (!this.$slots.default || !this.$slots.default.length) {
      return this.$slots.default;
    }
    this.firstElement = this.getFirstElement();
    if (!this.firstElement) return null;
    const data = this.firstElement.data = this.firstElement.data || {};
    data.staticClass = this.addTooltipClass(data.staticClass);
    return this.firstElement;
  },
  mounted() {
    this.referenceElm = this.$el;
    if (!this.firstElement) return this.firstElement;
    this.referenceElm = this.$el;
    if (this.$el.nodeType === 1) {
      this.$el.setAttribute('aria-describedby', this.tooltipId);
      this.$el.setAttribute('tabindex', this.tabindex);
      on(this.referenceElm, 'mouseenter', this.show);
      on(this.referenceElm, 'mouseleave', this.hide);
      on(this.referenceElm, 'focus', () => {
        if (!this.$slots.default || !this.$slots.default.length) {
          this.handleFocus();
          return;
        }
        const instance = this.$slots.default[0].componentInstance;
        if (instance && instance.focus) {
          instance.focus();
        } else {
          this.handleFocus();
        }
      });
      on(this.referenceElm, 'blur', this.handleBlur);
      on(this.referenceElm, 'click', this.removeFocusing);
    }
    // fix issue https://github.com/ElemeFE/element/issues/14424
    if (this.value && this.popperVM) {
      this.popperVM.$nextTick(() => {
        if (this.value) {
          this.updatePopper();
        }
      });
    }
  },
  destroyed() {
    const reference = this.referenceElm;
    if (reference.nodeType === 1) {
      off(reference, 'mouseenter', this.show);
      off(reference, 'mouseleave', this.hide);
      off(reference, 'focus', this.handleFocus);
      off(reference, 'blur', this.handleBlur);
      off(reference, 'click', this.removeFocusing);
    }
  },
  methods: {
    show() {
      this.setExpectedState(true);
      this.handleShowPopper();
    },
    hide() {
      this.setExpectedState(false);
      this.debounceClosable ? this.debounceClose() : this.handleClosePopper();
    },
    handleFocus() {
      this.focusing = true;
      this.show();
    },
    handleBlur() {
      this.focusing = false;
      this.hide();
    },
    removeFocusing() {
      this.focusing = false;
    },
    addTooltipClass(prev) {
      if (!prev) {
        return 'el-tooltip';
      } else {
        return 'el-tooltip ' + prev.replace('el-tooltip', '');
      }
    },
    concatClass(a, b) {
      if (a && a.indexOf(b) > -1) return a;
      return a ? b ? a + ' ' + b : a : b || '';
    },
    handleShowPopper() {
      if (!this.expectedState || this.manual) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => {
        this.showPopper = true;
      }, this.openDelay);
    },
    handleClosePopper() {
      if (this.enterable && this.expectedState || this.manual) return;
      clearTimeout(this.timeout);
      this.showPopper = false;
    },
    setExpectedState(expectedState) {
      this.expectedState = expectedState;
    },
    getFirstElement() {
      const slots = this.$slots.default;
      if (!Array.isArray(slots)) return null;
      let element = null;
      for (let index = 0; index < slots.length; index++) {
        if (slots[index] && slots[index].tag) {
          element = slots[index];
        }
      }
      return element;
    }
  }
});
// CONCATENATED MODULE: ./packages/tooltip/index.js


/* istanbul ignore next */
tooltip_src_main.install = function (Vue) {
  Vue.component(tooltip_src_main.name, tooltip_src_main);
};
/* harmony default export */ var packages_tooltip = (tooltip_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var menu_itemvue_type_script_lang_js_ = ({
  name: 'ElMenuItem',
  componentName: 'ElMenuItem',
  components: {
    ElTooltip: packages_tooltip
  },
  mixins: [menu_mixin, emitter],
  props: {
    index: {
      type: String,
      required: true
    },
    route: {
      type: Object,
      required: false,
      default: null
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    icon: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      isIe: false,
      textEllipsis: false
    };
  },
  computed: {
    active() {
      return this.index === this.rootMenu.activeIndex;
    }
  },
  created() {
    this.parentMenu.addItem(this);
    this.rootMenu.addItem(this);
  },
  mounted() {
    addResizeListener(this.$el, this.setTextEllipsis);
    if (!!window.ActiveXObject || 'ActiveXObject' in window) {
      this.isIe = true;
    }
  },
  beforeDestroy() {
    this.parentMenu.removeItem(this);
    this.rootMenu.removeItem(this);
    removeResizeListener(this.$el, this.setTextEllipsis);
  },
  methods: {
    handleClick() {
      if (!this.disabled) {
        this.dispatch('ElMenu', 'item-click', this);
        this.$emit('click', this);
      }
    },
    setTextEllipsis() {
      const $text = this.$el.querySelector('.el-menu-item--text');
      if (!$text || !$text.parentNode) return;
      const gutter = 60; // 菜单项左右的间距
      this.textEllipsis = $text.offsetWidth >= $text.parentNode.offsetWidth - gutter;
    }
  }
});
// CONCATENATED MODULE: ./packages/menu/src/menu-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_menu_itemvue_type_script_lang_js_ = (menu_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/menu/src/menu-item.vue





/* normalize component */

var menu_item_component = normalizeComponent(
  src_menu_itemvue_type_script_lang_js_,
  menu_itemvue_type_template_id_7d955dd8_render,
  menu_itemvue_type_template_id_7d955dd8_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var menu_item = (menu_item_component.exports);
// CONCATENATED MODULE: ./packages/menu-item/index.js


/* istanbul ignore next */
menu_item.install = function (Vue) {
  Vue.component(menu_item.name, menu_item);
};
/* harmony default export */ var packages_menu_item = (menu_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item-group.vue?vue&type=template&id=5aa50268&
var menu_item_groupvue_type_template_id_5aa50268_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{staticClass:"el-menu-item-group"},[_c('div',{staticClass:"el-menu-item-group__title",style:({ paddingLeft: _vm.levelPadding + 'px' })},[(!_vm.$slots.title)?[_vm._v(" "+_vm._s(_vm.title)+" ")]:_vm._t("title")],2),_c('ul',[_vm._t("default")],2)])}
var menu_item_groupvue_type_template_id_5aa50268_staticRenderFns = []


// CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue?vue&type=template&id=5aa50268&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-item-group.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var menu_item_groupvue_type_script_lang_js_ = ({
  name: 'ElMenuItemGroup',
  componentName: 'ElMenuItemGroup',
  inject: ['rootMenu'],
  props: {
    title: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      paddingLeft: 10
    };
  },
  computed: {
    levelPadding() {
      let padding = 10;
      let subPadding = 26; // 子菜单额外缩进距离
      let parent = this.$parent;

      // 无图标
      if (!this.icon) {
        padding = 22;
        subPadding = 0;
      }
      if (this.rootMenu.collapse) return 16;
      while (parent && parent.$options.componentName !== 'ElMenu') {
        if (parent.$options.componentName === 'ElSubmenu') {
          padding += 10;
        }
        parent = parent.$parent;
        // 增加子菜单的缩进距离
        if (parent && parent.$options.componentName === 'ElMenu') {
          padding += subPadding;
        }
      }
      padding === 10 && (padding = 10);
      return padding;
    }
  }
});
// CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_menu_item_groupvue_type_script_lang_js_ = (menu_item_groupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/menu/src/menu-item-group.vue





/* normalize component */

var menu_item_group_component = normalizeComponent(
  src_menu_item_groupvue_type_script_lang_js_,
  menu_item_groupvue_type_template_id_5aa50268_render,
  menu_item_groupvue_type_template_id_5aa50268_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var menu_item_group = (menu_item_group_component.exports);
// CONCATENATED MODULE: ./packages/menu-item-group/index.js


/* istanbul ignore next */
menu_item_group.install = function (Vue) {
  Vue.component(menu_item_group.name, menu_item_group);
};
/* harmony default export */ var packages_menu_item_group = (menu_item_group);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-collapse.vue?vue&type=template&id=644c54df&
var menu_collapsevue_type_template_id_644c54df_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-menu-collapse-wrap",staticStyle:{"transition":"all .2s"},on:{"mouseenter":_vm.handleMouseenter,"mouseleave":_vm.handleMouseleave}},[_c('ul',{staticClass:"el-menu",class:{ 'el-menu--dark': _vm.rootMenu.theme === 'dark' }},[_vm._t("default")],2)])}
var menu_collapsevue_type_template_id_644c54df_staticRenderFns = []


// CONCATENATED MODULE: ./packages/menu/src/menu-collapse.vue?vue&type=template&id=644c54df&

// CONCATENATED MODULE: ./packages/menu/src/util.js
/**
 * 返回当前页面相对于窗口显示区左上角的 X ，Y 的位置
 * @author chenguanbin
 * @param {boolean} [top] 是否是获取顶部的左上角的Y坐标
 */
const util_getScroll = function (top) {
  var ret = window['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = window.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
};

/**
 * 返回目标节点在容器中的位置
 * @author chenguanbin
 * @param {HTMLElement} [element] 需要获取位置的元素
 * @param {HTMLElement} [container = document.body] 容器元素
 */
const util_getOffset = function (element, container = document.body) {
  const elRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const clientTop = element.clientTop || container.clientTop || 0;
  const clientLeft = element.clientLeft || container.clientLeft || 0;
  let top, left;
  if (container === document.body) {
    top = util_getScroll(true);
    left = util_getScroll();
  } else {
    top = container.scrollTop - containerRect.top;
    left = container.scrollLeft - containerRect.left;
  }
  return {
    top: elRect.top + top - clientTop,
    left: elRect.left + left - clientLeft,
    right: elRect.right + left - clientLeft,
    bottom: elRect.bottom + top - clientTop
  };
};

/**
 * 获取折叠子菜单的高度
 * @param {HTMLElement} submenu 子菜单
 */
const getCollapseHeight = function (submenu) {
  let cHeight = 0;
  const traverse = el => {
    const childNodes = Array.prototype.slice.call(el.childNodes);
    childNodes.forEach(node => {
      const nodeName = node.nodeName;
      const className = node.className;
      if (nodeName === 'LI' && className.indexOf('el-menu-item-group') !== -1) {
        cHeight += 32;
        traverse(node);
      } else if (nodeName === 'LI' && (className.indexOf('el-menu-item') !== -1 || className.indexOf('el-submenu') !== -1)) {
        cHeight += 40;
      } else if (nodeName === 'UL') {
        traverse(node);
      }
    });
  };
  traverse(submenu);
  return cHeight;
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/menu/src/menu-collapse.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var menu_collapsevue_type_script_lang_js_ = ({
  name: 'ElMenuCollapse',
  componentName: 'ElMenuCollapse',
  props: {
    rootMenu: {
      type: Object,
      default: null
    }
  },
  data() {
    return {
      open: false
    };
  },
  mounted() {},
  methods: {
    handleMouseenter(event) {
      this.$emit('mouse-enter', event);
    },
    handleMouseleave(event) {
      const toElement = event.toElement || event.relatedTarget;
      // 若鼠标未移动到子菜单上，则触发事件
      if (closest(toElement, '.el-menu-collapse-wrap') === null) {
        this.$emit('leave-collapse', event);
      }
    },
    loadCollapseMenu() {
      let isExistNode = false;
      const nodes = Array.prototype.slice.call(document.body.childNodes);
      // 判断节点是否已经添加到body下
      if (nodes && nodes.length) {
        nodes.forEach(node => {
          if (node === this.$el) {
            isExistNode = true;
          }
        });
      }
      // 若节点未添加到body下
      if (!isExistNode) {
        document.body.appendChild(this.$el);
      }

      // 每次打开重新计算位置
      const parent = this.$parent.$el;
      const parentOffset = util_getOffset(parent); // 父节点距离页面顶部的距离
      const parentClientTop = parent.getBoundingClientRect().top; // 父节点相对于浏览器左上角的距离

      const collapseHeight = getCollapseHeight(this.$el.childNodes[0]); // 折叠菜单高度
      const clientHeight = document.body.clientHeight; // 页面的可视高度

      const wrapScrollTop = document.getElementsByTagName('html')[0].scrollTop || document.body.scrollTop; // 外层滚动条的滚动距离（html/body）(在HUIdemo网站上该值会过大)

      let gutter = 0; // top值偏移量

      // 若底部控件不足，则向上偏移
      if (parentClientTop + collapseHeight >= clientHeight) {
        gutter = parentClientTop + collapseHeight - clientHeight + wrapScrollTop + 2;
      }

      // 计算折叠子菜单的 top/left 值
      this.$el.style.top = parentOffset.top - gutter + 'px';
      this.$el.style.left = parentOffset.left + parent.offsetWidth + 'px';
      setTimeout(() => {
        this.rootMenu.$emit('show-collapse', this.$el);
      }, 300);
      return this.$el;
    }
  }
});
// CONCATENATED MODULE: ./packages/menu/src/menu-collapse.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_menu_collapsevue_type_script_lang_js_ = (menu_collapsevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/menu/src/menu-collapse.vue





/* normalize component */

var menu_collapse_component = normalizeComponent(
  src_menu_collapsevue_type_script_lang_js_,
  menu_collapsevue_type_template_id_644c54df_render,
  menu_collapsevue_type_template_id_644c54df_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var menu_collapse = (menu_collapse_component.exports);
// CONCATENATED MODULE: ./packages/menu-collapse/index.js


/* istanbul ignore next */
menu_collapse.install = function (Vue) {
  Vue.component(menu_collapse.name, menu_collapse);
};
/* harmony default export */ var packages_menu_collapse = (menu_collapse);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=template&id=660b01ee&
var input_numbervue_type_template_id_660b01ee_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:[
    'el-input-number',
    _vm.inputNumberSize ? 'el-input-number--' + _vm.inputNumberSize : '',
    { 'is-disabled': _vm.inputNumberDisabled },
    { 'is-without-controls': !_vm.controls },
    { 'is-controls-right': _vm.controlsAtRight }
  ],on:{"dragstart":function($event){$event.preventDefault();}}},[(_vm.controls)?_c('el-button',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-decrease  el-input-number__decrease ",class:{ 'is-disabled': _vm.minDisabled },attrs:{"disabled":_vm.disabled,"icon":"h-icon-angle_down","size":"mini"},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.decrease.apply(null, arguments)}}}):_vm._e(),(_vm.controls)?_c('el-button',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-increase el-input-number__increase",class:{ 'is-disabled': _vm.maxDisabled },attrs:{"disabled":_vm.disabled,"icon":"h-icon-angle_up","size":"mini"},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.increase.apply(null, arguments)}}}):_vm._e(),_c('el-input',_vm._b({ref:"input",attrs:{"value":_vm.displayValue,"placeholder":_vm.placeholder,"disabled":_vm.inputNumberDisabled,"size":_vm.inputNumberSize,"name":_vm.name,"label":_vm.label},on:{"blur":_vm.handleBlur,"focus":_vm.handleFocus,"input":_vm.handleInput,"change":_vm.handleInputChange},nativeOn:{"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.increase.apply(null, arguments)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.decrease.apply(null, arguments)}]}},'el-input',_vm.$attrs,false),[(_vm.$slots.suffix)?_c('template',{slot:"suffix"},[_vm._t("suffix")],2):_vm._e()],2)],1)}
var input_numbervue_type_template_id_660b01ee_staticRenderFns = []


// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=template&id=660b01ee&

// CONCATENATED MODULE: ./src/directives/repeat-click.js

/* harmony default export */ var repeat_click = ({
  bind(el, binding, vnode) {
    let interval = null;
    let startTime;
    // 判断handler是否已执行；setInterval调度延时导致handler没有被执行时，需要保证至少handler至少执行一次。
    let executed = false;
    const handler = () => {
      vnode.context[binding.expression].apply();
      executed = true;
    };
    const clear = () => {
      clearInterval(interval);
      interval = null;
      if (new Date() - startTime < 100 || !executed) {
        handler();
      }
    };
    on(el, 'mousedown', e => {
      if (e.button !== 0) return;
      executed = false;
      startTime = new Date();
      once(document, 'mouseup', clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var input_numbervue_type_script_lang_js_ = ({
  name: 'ElInputNumber',
  directives: {
    repeatClick: repeat_click
  },
  components: {
    ElInput: packages_input
  },
  inheritAttrs: false,
  props: {
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: 0
    },
    value: {
      type: null,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: ''
    },
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ''
    },
    name: {
      type: String,
      default: ''
    },
    label: {
      type: String,
      default: ''
    },
    placeholder: {
      type: String,
      default: ''
    },
    precision: {
      type: Number,
      validator(val) {
        return val >= 0 && val === parseInt(val, 10);
      },
      default: 0
    },
    resetNum: {
      type: [Number, String, null],
      default: null
    }
  },
  data() {
    return {
      currentValue: 0,
      userInput: null
    };
  },
  computed: {
    // 最小值时禁用decrease按钮
    minDisabled() {
      return this.value <= this.min;
      // return this._decrease(this.value, this.step) < this.min;
    },
    // 最大值时禁用increase按钮
    maxDisabled() {
      // return this._increase(this.value, this.step) > this.max;
      return this.value >= this.max;
    },
    // 精度
    numPrecision() {
      const {
        value,
        step,
        getPrecision,
        precision
      } = this;
      const stepPrecision = getPrecision(step);
      if (precision !== undefined) {
        // 如果步长的小数位比 value的小数位数还长，警告并返回vaulue小数位
        if (stepPrecision > precision) {
          console.warn('[HUI Warn][InputNumber]precision should not be less than the decimal places of step');
        }
        return precision;
      } else {
        // 步长精度和value精度，返回更精准的
        return Math.max(getPrecision(value), stepPrecision);
      }
    },
    controlsAtRight() {
      return this.controls && this.controlsPosition === 'right';
    },
    inputNumberSize() {
      return this.size;
    },
    inputNumberDisabled() {
      return this.disabled;
    },
    // 显示的值
    displayValue() {
      if (this.userInput !== null && this.userInput !== '') {
        return this.userInput;
      }
      let currentValue = this.currentValue;
      if (typeof currentValue === 'number') {
        if (this.stepStrictly) {
          const stepPrecision = this.getPrecision(this.step);
          const precisionFactor = Math.pow(10, stepPrecision);
          currentValue = Math.round(currentValue / this.step) * precisionFactor * this.step / precisionFactor;
        }
        // 修正小数点位数
        if (this.precision !== undefined) {
          currentValue = currentValue.toFixed(this.precision);
        }
      }
      return currentValue;
    }
  },
  watch: {
    // 传入的值
    value: {
      immediate: true,
      handler(value) {
        let newVal = value === undefined || value === '' ? value : Number(value);
        if (typeof newVal === 'number') {
          if (isNaN(newVal)) {
            return;
          }
          if (this.stepStrictly) {
            const stepPrecision = this.getPrecision(this.step);
            const precisionFactor = Math.pow(10, stepPrecision);
            newVal = Math.round(newVal / this.step) * precisionFactor * this.step / precisionFactor;
          }
          if (this.precision !== undefined) {
            newVal = this.toPrecision(newVal, this.precision);
          }
        }
        if (typeof newVal === 'number') {
          if (newVal >= this.max) newVal = this.max;
          if (newVal <= this.min) newVal = this.min;
        }
        this.currentValue = newVal;
        // this.userInput = null;
        this.$emit('input', newVal);
      }
    }
  },
  mounted() {
    const innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('role', 'spinbutton');
    innerInput.setAttribute('aria-valuemax', this.max);
    innerInput.setAttribute('aria-valuemin', this.min);
    innerInput.setAttribute('aria-valuenow', this.currentValue);
    innerInput.setAttribute('aria-disabled', this.inputNumberDisabled);
  },
  updated() {
    if (!this.$refs || !this.$refs.input) return;
    const innerInput = this.$refs.input.$refs.input;
    innerInput.setAttribute('aria-valuenow', this.currentValue);
  },
  methods: {
    // 转化精度
    toPrecision(num, precision) {
      if (precision === undefined) precision = this.numPrecision;
      return parseFloat(Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision));
    },
    // 计算精度
    getPrecision(value) {
      if (value === undefined) return 0;
      const valueString = value.toString();
      const dotPosition = valueString.indexOf('.');
      let precision = 0;
      // 计算小数点后有几位
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    },
    _increase(val, step) {
      if (typeof val !== 'number' && val !== undefined) return this.currentValue;
      const precisionFactor = Math.pow(10, this.numPrecision);
      // Solve the accuracy problem of JS decimal calculation by converting the value to integer.
      return this.toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
    },
    _decrease(val, step) {
      if (typeof val !== 'number' && val !== undefined) return this.currentValue;
      const precisionFactor = Math.pow(10, this.numPrecision);
      return this.toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
    },
    increase() {
      if (this.inputNumberDisabled || this.maxDisabled) return;
      this.userInput = null;
      const value = this.value || 0;
      const newVal = this._increase(value, this.step);
      this.setCurrentValue(newVal);
    },
    decrease() {
      if (this.inputNumberDisabled || this.minDisabled) return;
      this.userInput = null;
      const value = this.value || 0;
      const newVal = this._decrease(value, this.step);
      this.setCurrentValue(newVal);
    },
    handleBlur(event) {
      this.userInput = null;
      let newVal = event.target.value;
      // 如果用户什么都没有输入，默认用resetNum xx
      if (newVal.trim() === '') {
        newVal = this.resetNum === null ? '' : this.resetNum;
      }

      // 如果转换结果是 NaN（不是一个有效的数字）则判断为0或者是resetNum
      newVal = isNaN(Number(newVal)) ? this.resetNum === null ? 0 : this.resetNum : Number(newVal);

      // 加入精度和最大小值的判断
      if (this.precision !== undefined) {
        newVal = this.toPrecision(newVal, this.precision);
      }
      if (typeof newVal === 'number') {
        if (newVal >= this.max) newVal = this.max;
        if (newVal <= this.min) newVal = this.min;
      }
      this.setCurrentValue(newVal);
      this.$emit('blur', event);
    },
    handleFocus(event) {
      this.$emit('focus', event);
    },
    setCurrentValue(newVal) {
      const oldVal = this.currentValue;
      if (oldVal === newVal) return;
      // this.userInput = null;
      this.$emit('input', newVal);
      this.$emit('change', newVal, oldVal);
      this.currentValue = newVal;
    },
    handleInput(value) {
      this.userInput = value;
    },
    handleInputChange(value) {
      const newVal = Number(value);
      if (!isNaN(newVal) && !isNaN(parseFloat(value))) {
        this.setCurrentValue(newVal);
      } else {
        this.currentValue = value;
      }
      // this.userInput = null;
    }
  }
});
// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_input_numbervue_type_script_lang_js_ = (input_numbervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/input-number/src/input-number.vue





/* normalize component */

var input_number_component = normalizeComponent(
  src_input_numbervue_type_script_lang_js_,
  input_numbervue_type_template_id_660b01ee_render,
  input_numbervue_type_template_id_660b01ee_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var input_number = (input_number_component.exports);
// CONCATENATED MODULE: ./packages/input-number/index.js


/* istanbul ignore next */
input_number.install = function (Vue) {
  Vue.component(input_number.name, input_number);
};
/* harmony default export */ var packages_input_number = (input_number);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/ip-input/src/ip-input.vue?vue&type=template&id=4283ecc6&
var ip_inputvue_type_template_id_4283ecc6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-popover',{ref:"popoverInput",attrs:{"content":_vm.tips,"max-width":_vm.tipsMaxWidth,"placement":_vm.tipsPlacement,"show-html":true,"offset-placement":_vm.tipsOffset,"value":_vm.tipsVisible,"effect":"effect","trigger":"manual","popper-class":"\n    el-popover__for-input el-popover__for-input-form\n  "}},[_c('div',{staticClass:"h-ip-input",class:{
      'is-focus': _vm.focused,
      'is-disabled': _vm.disabled
    },style:(_vm.styleObj),attrs:{"slot":"reference"},slot:"reference"},_vm._l((4),function(i){return _c('el-input',{key:i,ref:'input_' + i,refInFor:true,staticClass:"h-ip-input__verse",style:({ width: _vm.itemWidth }),attrs:{"maxlength":3,"disabled":_vm.disabled},on:{"change":function($event){return _vm.updateValue($event, i)},"focus":_vm.handleFocus,"blur":function (e) { return _vm.handleBlur(e, i); }},nativeOn:{"keyup":function($event){return _vm.onInputKeyup($event, i)},"paste":function($event){$event.preventDefault();return _vm.onPaste($event, i)}},model:{value:(_vm.ipArr[i - 1]),callback:function ($$v) {_vm.$set(_vm.ipArr, i - 1, $$v)},expression:"ipArr[i - 1]"}})}),1)])}
var ip_inputvue_type_template_id_4283ecc6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/ip-input/src/ip-input.vue?vue&type=template&id=4283ecc6&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/ip-input/src/ip-input.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

// 获取当前输入框的焦点位置 by liumeng6
function getRange(el) {
  const ret = {};
  if (el.setSelectionRange) {
    ret.begin = el.selectionStart;
    ret.end = el.selectionEnd;
    ret.result = el.value.substring(ret.begin, ret.end);
  }
  el.focus();
  return ret;
}
/* harmony default export */ var ip_inputvue_type_script_lang_js_ = ({
  name: 'HIpInput',
  props: {
    value: {
      type: String,
      default: ''
    },
    width: {
      type: String,
      default: '100%'
    },
    itemWidth: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    // 提示信息，设置了tips才能显示popover
    tips: {
      type: String,
      default: null
    },
    // popover的最大宽度
    tipsMaxWidth: {
      type: [String, Number],
      default: null
    },
    // popover出现的位置
    tipsPlacement: {
      type: String,
      default: 'top'
    },
    // 出现位置的偏移量
    tipsOffset: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      ipArr: (this.value || '').split('.'),
      tipsVisible: false,
      focused: false
    };
  },
  computed: {
    styleObj() {
      return {
        width: this.width
      };
    }
  },
  watch: {
    value(val) {
      this.ipArr = val.split('.');
    }
  },
  methods: {
    updateValue(val, index) {
      this.$nextTick(() => {
        if (/^\D*$/.test(val)) {
          // 输入的内容都是非数字时，输入框置空
          val = '';
        } else {
          if (!/^\d*$/.test(val)) {
            // 去除非数字的字符
            val = parseInt(val.replace(/[^\d]/g, ''));
          } else {
            // 超过255默认显示255
            val = parseInt(val) > 255 ? 255 : parseInt(val);
          }
          // 当不处于第四个输入框，且当前输入框满三位时，自动获取下一个焦点
          if (index < 4 && `${val}`.length >= 3) {
            const inputEl = this.$el.getElementsByTagName('input')[index];
            this._setCursorPosition(inputEl, 0);
          }
        }
        this.ipArr.splice(index - 1, 1, val);

        // 如果ip都为空，则返回空字符串，如果ip不为空，则返回ip字符串
        this.$emit('input', this.ipArr.every(ip => ip === '') ? '' : this.ipArr.join('.'));
      });
    },
    /**
     * @author liumeng6
     * @date 2017-12-11 15:50:48
     * @desc input按键监听
     */
    onInputKeyup(event, index) {
      const keyCode = event.keyCode || event.which;
      const value = event.target.value;
      const arrIndex = index - 1; // 值在数组中的顺序 即从0开始
      const ip = this.ipArr[arrIndex];
      // 处理键盘监听，8 为退格键，37 为left箭头，39 为right箭头，110 为数字键盘上的小数点，190为控制键上的小数点，229为中文数字键盘上小数点
      if (keyCode === 8 || keyCode === 37) {
        if ((value.length === 0 || getRange(event.target).end === 0) && arrIndex > 0) {
          const inputEl = this.$el.getElementsByTagName('input')[arrIndex - 1];
          this._setCursorPosition(inputEl, inputEl.value.length, event);
        }
      } else if (keyCode === 39) {
        // 按下右箭头，要光标在最后的时候才聚焦下一个
        if (getRange(event.target).end !== value.length) return;
        if (arrIndex < 3 && ip !== undefined) {
          const inputEl = this.$el.getElementsByTagName('input')[arrIndex + 1];
          this._setCursorPosition(inputEl, 0, event);
        }
      } else if (keyCode === 110 || keyCode === 190 || keyCode === 229 && (event.code === 'NumpadDecimal' || event.code === 'Period')) {
        if (!value.length) return;
        // 输入小数点或数字键盘上的句号能跳转
        if (arrIndex < 3 && ip !== undefined) {
          const inputEl = this.$el.getElementsByTagName('input')[arrIndex + 1];
          this._setCursorPosition(inputEl, 0, event);
        }
      }
    },
    /**
     * @desc 设置输入框光标位置
     * @author chenguanbin
     * @param {Document} inputEl 设置光标的IP框
     * @param {Number} index 光标位置
     */
    _setCursorPosition(inputEl, index, event) {
      inputEl.select();
      if (inputEl.setSelectionRange) inputEl.setSelectionRange(index, 10);
      // 解决缺陷：IE浏览器下一定概率出现，IP输入框按退格键，当前一位是3位数时，无法退回到上一个输入框的问题
      // 原因：IE下先执行了键盘的退格事件，再执行前一个输入框的focus，这样会触发前一个输入框的change事件，导致焦点重新回到原输入框。（正确事件顺序：focus - 退格 - change）
      // 解决：focus事件后阻止后续事件的执行，这样就不会执行键盘的退格事件和输入框的change事件
      event && event.preventDefault();
    },
    /**
     * @author liumeng6
     * @date 2017-12-11 15:50:17
     * @desc ip粘贴事件
     */
    onPaste(event, index) {
      const arrayIndex = index - 1;
      // `ie`和`chrome`兼容
      const pasteText = event.clipboardData ? event.clipboardData.getData('text/plain').trim() : window.clipboardData.getData('text').trim();
      if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(pasteText)) {
        const segments = pasteText.split('.');
        segments.forEach((segment, i) => {
          const value = Number(segment);
          if (arrayIndex + i < 4 && !isNaN(value) && value >= 0 && value <= 255) {
            this.ipArr.splice(arrayIndex + i, 1, value);
            this.$emit('input', this.ipArr.join('.'));
          }
        });
        this.$emit('input', this.ipArr.every(ip => ip === '') ? '' : this.ipArr.join('.'));
      }
    },
    /**
     * @author liumeng6
     * @date 2018-09-05 10:45:33
     * @desc 处理焦点事件
     */
    handleFocus() {
      this.focused = true;
      if (this.tips) {
        this.tipsVisible = true;
      }
    },
    /**
     * @author liumeng6
     * @date 2018-09-05 11:10:06
     * @desc 处理失焦事件
     */
    handleBlur(e, i) {
      this.focused = false;
      if (this.tips) {
        this.tipsVisible = false;
      }
      this.$emit('blur', e, i);
    }
  }
});
// CONCATENATED MODULE: ./packages/ip-input/src/ip-input.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_ip_inputvue_type_script_lang_js_ = (ip_inputvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/ip-input/src/ip-input.vue





/* normalize component */

var ip_input_component = normalizeComponent(
  src_ip_inputvue_type_script_lang_js_,
  ip_inputvue_type_template_id_4283ecc6_render,
  ip_inputvue_type_template_id_4283ecc6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ip_input = (ip_input_component.exports);
// CONCATENATED MODULE: ./packages/ip-input/index.js

ip_input.install = function (Vue) {
  Vue.component(ip_input.name, ip_input);
};
/* harmony default export */ var packages_ip_input = (ip_input);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=template&id=78893673&
var radiovue_type_template_id_78893673_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-radio",class:[
    _vm.radioSize ? 'el-radio--' + _vm.radioSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-focus': _vm.focus },
    { 'is-checked': _vm.model === _vm.label }
  ],style:({ 'max-width': _vm.maxWidth + 'px' }),attrs:{"aria-checked":_vm.model === _vm.label,"aria-disabled":_vm.isDisabled,"tabindex":_vm.tabIndex,"role":"radio"},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.stopPropagation();$event.preventDefault();_vm.model = _vm.isDisabled ? _vm.model : _vm.label}}},[_c('span',{staticClass:"el-radio__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.model === _vm.label
    }},[_c('span',{staticClass:"el-radio__inner"}),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],ref:"radio",staticClass:"el-radio__original",attrs:{"name":_vm.name,"disabled":_vm.isDisabled,"type":"radio","tabindex":"-1"},domProps:{"value":_vm.label,"checked":_vm._q(_vm.model,_vm.label)},on:{"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false},"change":[function($event){_vm.model=_vm.label},_vm.handleChange]}})]),(_vm.icon)?_c('span',{staticClass:"el-radio__icon"},[_c('i',{class:_vm.icon})]):_vm._e(),_c('span',{staticClass:"el-radio__label"},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(" "+_vm._s(_vm.label)+" ")]:_vm._e()],2)])}
var radiovue_type_template_id_78893673_staticRenderFns = []


// CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=template&id=78893673&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var radiovue_type_script_lang_js_ = ({
  name: 'ElRadio',
  mixins: [emitter],
  componentName: 'ElRadio',
  props: {
    maxWidth: {
      type: Number,
      default: 256
    },
    value: {
      type: null,
      default: null
    },
    label: {
      type: null,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: null
    },
    plain: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      focus: false,
      titleLabel: ''
    };
  },
  computed: {
    isGroup() {
      let parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElRadioGroup') {
          parent = parent.$parent;
        } else {
          // this._radioGroup = parent;
          return true;
        }
      }
      return false;
    },
    model: {
      get() {
        return this.isGroup ? this._radioGroup.value : this.value;
      },
      set(val) {
        if (this.isGroup) {
          this.dispatch('ElRadioGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
        }
        this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);
      }
    },
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    radioSize() {
      const temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._radioGroup.radioGroupSize || temRadioSize : temRadioSize;
    },
    isDisabled() {
      return this.isGroup ? this._radioGroup.disabled || this.disabled : this.disabled;
    },
    tabIndex() {
      return !this.isDisabled ? this.isGroup ? this.model === this.label ? 0 : -1 : 0 : -1;
    }
  },
  created() {
    if (this.$parent.$options.componentName === 'ElRadioGroup') {
      this._radioGroup = this.$parent;
    }
  },
  methods: {
    handleChange() {
      this.$nextTick(() => {
        this.$emit('change', this.model);
        this.isGroup && this.dispatch('ElRadioGroup', 'handleChange', this.model);
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/radio/src/radio.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_radiovue_type_script_lang_js_ = (radiovue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/radio/src/radio.vue





/* normalize component */

var radio_component = normalizeComponent(
  src_radiovue_type_script_lang_js_,
  radiovue_type_template_id_78893673_render,
  radiovue_type_template_id_78893673_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_radio = (radio_component.exports);
// CONCATENATED MODULE: ./packages/radio/index.js


/* istanbul ignore next */
src_radio.install = function (Vue) {
  Vue.component('el-radio', src_radio);
};
/* harmony default export */ var packages_radio = (src_radio);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-group.vue?vue&type=template&id=57bde8a0&
var radio_groupvue_type_template_id_57bde8a0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-radio-group"},[_vm._t("default")],2)}
var radio_groupvue_type_template_id_57bde8a0_staticRenderFns = []


// CONCATENATED MODULE: ./packages/radio/src/radio-group.vue?vue&type=template&id=57bde8a0&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-group.vue?vue&type=script&lang=js&
//
//
//
//
//


/* harmony default export */ var radio_groupvue_type_script_lang_js_ = ({
  name: 'ElRadioGroup',
  componentName: 'ElRadioGroup',
  mixins: [emitter],
  props: {
    value: {
      type: null,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    fill: {
      type: String,
      default: null
    },
    textColor: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'default'
    }
  },
  watch: {
    value(value) {
      this.dispatch('ElFormItem', 'el.form.change', [this.value]);
      this.$emit('change', this.value);
    }
  }
});
// CONCATENATED MODULE: ./packages/radio/src/radio-group.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_radio_groupvue_type_script_lang_js_ = (radio_groupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/radio/src/radio-group.vue





/* normalize component */

var radio_group_component = normalizeComponent(
  src_radio_groupvue_type_script_lang_js_,
  radio_groupvue_type_template_id_57bde8a0_render,
  radio_groupvue_type_template_id_57bde8a0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var radio_group = (radio_group_component.exports);
// CONCATENATED MODULE: ./packages/radio-group/index.js


/* istanbul ignore next */
radio_group.install = function (Vue) {
  Vue.component(radio_group.name, radio_group);
};
/* harmony default export */ var packages_radio_group = (radio_group);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-button.vue?vue&type=template&id=009e4ba2&
var radio_buttonvue_type_template_id_009e4ba2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-radio-button",class:[
    _vm.size ? 'el-radio-button--' + _vm.size : '',
    { 'is-checked': _vm.value === _vm.label },
    { 'is-disabled': _vm.isDisabled },
    { 'is-simple': _vm.isSimple }
  ]},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.value),expression:"value"}],staticClass:"el-radio-button__orig-radio",attrs:{"name":_vm.name,"disabled":_vm.isDisabled,"type":"radio"},domProps:{"value":_vm.label,"checked":_vm._q(_vm.value,_vm.label)},on:{"change":function($event){_vm.value=_vm.label}}}),_c('span',{staticClass:"el-radio-button__inner",style:(_vm.buttonStyle),attrs:{"title":_vm.titleLabel},on:{"mouseover":_vm.handleMouseover}},[_vm._t("default"),(!_vm.$slots.default)?[_vm._v(" "+_vm._s(_vm.label)+" ")]:_vm._e()],2)])}
var radio_buttonvue_type_template_id_009e4ba2_staticRenderFns = []


// CONCATENATED MODULE: ./packages/radio/src/radio-button.vue?vue&type=template&id=009e4ba2&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/radio/src/radio-button.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var radio_buttonvue_type_script_lang_js_ = ({
  name: 'ElRadioButton',
  props: {
    maxWidth: {
      type: Number,
      default: 256
    },
    label: {
      type: null,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      titleLabel: '',
      isIE: false
    };
  },
  computed: {
    isSimple() {
      return this._radioGroup.type === 'simple';
    },
    value: {
      get() {
        return this._radioGroup.value;
      },
      set(value) {
        this._radioGroup.$emit('input', value);
      }
    },
    _radioGroup() {
      let parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElRadioGroup') {
          parent = parent.$parent;
        } else {
          return parent;
        }
      }
      return false;
    },
    buttonStyle() {
      const isActive = this._radioGroup.value === this.label;
      let style = {
        'max-width': this.maxWidth + 'px'
      };
      if (isActive) {
        style = Object.assign(style, {
          backgroundColor: this._radioGroup.fill || '',
          borderColor: this._radioGroup.fill || '',
          boxShadow: this._radioGroup.fill ? `-1px 0 0 0 ${this._radioGroup.fill}` : '',
          color: this._radioGroup.textColor || ''
        });
      }
      return style;
    },
    size() {
      return this._radioGroup.size;
    },
    isDisabled() {
      return this.disabled || this._radioGroup.disabled;
    }
  },
  mounted() {
    // ie兼容
    if (!!window.ActiveXObject || 'ActiveXObject' in window) {
      this.isIE = true;
    }
  },
  methods: {
    handleMouseover(e) {
      const t = e.target;
      if (t.tagName === 'SPAN') {
        if (t.scrollWidth > t.clientWidth || this.isIE) {
          this.titleLabel = t.innerText;
        } else {
          this.titleLabel = '';
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/radio/src/radio-button.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_radio_buttonvue_type_script_lang_js_ = (radio_buttonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/radio/src/radio-button.vue





/* normalize component */

var radio_button_component = normalizeComponent(
  src_radio_buttonvue_type_script_lang_js_,
  radio_buttonvue_type_template_id_009e4ba2_render,
  radio_buttonvue_type_template_id_009e4ba2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var radio_button = (radio_button_component.exports);
// CONCATENATED MODULE: ./packages/radio-button/index.js


/* istanbul ignore next */
radio_button.install = function (Vue) {
  Vue.component(radio_button.name, radio_button);
};
/* harmony default export */ var packages_radio_button = (radio_button);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-button.vue?vue&type=template&id=fb482068&
var checkbox_buttonvue_type_template_id_fb482068_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox-button",class:[
    _vm.size ? 'el-checkbox-button--' + _vm.size : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-checked': _vm.isChecked },
    { 'is-focus': _vm.focus },
    { 'is-simple': _vm.isSimple }
  ],attrs:{"aria-checked":_vm.isChecked,"aria-disabled":_vm.isDisabled,"role":"checkbox"}},[(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox-button__orig-checkbox",attrs:{"name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel,"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox-button__orig-checkbox",attrs:{"name":_vm.name,"disabled":_vm.isDisabled,"type":"checkbox"},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox-button__inner",style:(_vm.isChecked ? _vm.activeStyle : null)},[_vm._t("default",function(){return [_vm._v(_vm._s(_vm.label))]})],2):_vm._e()])}
var checkbox_buttonvue_type_template_id_fb482068_staticRenderFns = []


// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue?vue&type=template&id=fb482068&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-button.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var checkbox_buttonvue_type_script_lang_js_ = ({
  name: 'ElCheckboxButton',
  mixins: [emitter],
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },
  props: {
    value: {
      type: [String, Number, Boolean],
      default: undefined
    },
    label: {
      type: [String, Number, Boolean],
      default: undefined
    },
    disabled: {
      type: Boolean,
      default: null
    },
    checked: {
      type: Boolean,
      default: null
    },
    name: {
      type: String,
      default: undefined
    },
    trueLabel: {
      type: [String, Number],
      default: undefined
    },
    falseLabel: {
      type: [String, Number],
      default: undefined
    }
  },
  data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },
  computed: {
    isSimple() {
      return this._checkboxGroup.type === 'simple';
    },
    model: {
      get() {
        return this._checkboxGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set(val) {
        if (this._checkboxGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);
          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);
          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else if (this.value !== undefined) {
          this.$emit('input', val);
        } else {
          this.selfModel = val;
        }
      }
    },
    isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
      return false;
    },
    _checkboxGroup() {
      let parent = this.$parent;
      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          return parent;
        }
      }
      return false;
    },
    store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    activeStyle() {
      return {
        backgroundColor: this._checkboxGroup.fill || '',
        borderColor: this._checkboxGroup.fill || '',
        color: this._checkboxGroup.textColor || '',
        'box-shadow': '-1px 0 0 0 ' + this._checkboxGroup.fill
      };
    },
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    size() {
      return this._checkboxGroup.checkboxGroupSize || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    isDisabled() {
      return this._checkboxGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled : this.disabled || (this.elForm || {}).disabled;
    }
  },
  created() {
    this.checked && this.addToStore();
  },
  methods: {
    addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange(ev) {
      if (this.isLimitExceeded) return;
      let value;
      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }
      this.$emit('change', value, ev);
      this.$nextTick(() => {
        if (this._checkboxGroup) {
          this.dispatch('ElCheckboxGroup', 'change', [this._checkboxGroup.value]);
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_checkbox_buttonvue_type_script_lang_js_ = (checkbox_buttonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-button.vue





/* normalize component */

var checkbox_button_component = normalizeComponent(
  src_checkbox_buttonvue_type_script_lang_js_,
  checkbox_buttonvue_type_template_id_fb482068_render,
  checkbox_buttonvue_type_template_id_fb482068_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var checkbox_button = (checkbox_button_component.exports);
// CONCATENATED MODULE: ./packages/checkbox-button/index.js


/* istanbul ignore next */
checkbox_button.install = function (Vue) {
  Vue.component(checkbox_button.name, checkbox_button);
};
/* harmony default export */ var packages_checkbox_button = (checkbox_button);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=20b7d66c&
var checkbox_groupvue_type_template_id_20b7d66c_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-checkbox-group",class:{ 'el-checkbox-group--vertical': _vm.vertical },attrs:{"role":"group","aria-label":"checkbox-group"}},[_vm._t("default")],2)}
var checkbox_groupvue_type_template_id_20b7d66c_staticRenderFns = []


// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=template&id=20b7d66c&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&

/* harmony default export */ var checkbox_groupvue_type_script_lang_js_ = ({
  name: 'ElCheckboxGroup',
  componentName: 'ElCheckboxGroup',
  mixins: [emitter],
  inject: {
    elFormItem: {
      default: ''
    }
  },
  props: {
    value: {
      type: Array,
      default: function () {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: null
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: Infinity
    },
    size: {
      type: String,
      default: 'medium'
    },
    fill: {
      type: String,
      default: undefined
    },
    textColor: {
      type: String,
      default: undefined
    },
    type: {
      type: String,
      default: 'default'
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxGroupSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    }
  },
  watch: {
    value(value) {
      this.dispatch('ElFormItem', 'el.form.change', [value]);
    }
  }
});
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_checkbox_groupvue_type_script_lang_js_ = (checkbox_groupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/checkbox/src/checkbox-group.vue





/* normalize component */

var checkbox_group_component = normalizeComponent(
  src_checkbox_groupvue_type_script_lang_js_,
  checkbox_groupvue_type_template_id_20b7d66c_render,
  checkbox_groupvue_type_template_id_20b7d66c_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var checkbox_group = (checkbox_group_component.exports);
// CONCATENATED MODULE: ./packages/checkbox-group/index.js


/* istanbul ignore next */
checkbox_group.install = function (Vue) {
  Vue.component(checkbox_group.name, checkbox_group);
};
/* harmony default export */ var packages_checkbox_group = (checkbox_group);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/switch/src/component.vue?vue&type=template&id=3e1280c6&
var componentvue_type_template_id_3e1280c6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-switch",class:[
    _vm.size ? 'el-switch--' + _vm.size : '',
    {
      'is-disabled': _vm.disabled,
      'is-checked': _vm.checked
    }
  ]},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.disabled),expression:"disabled"}],staticClass:"el-switch__mask"}),(_vm.inactiveText)?_c('div',{staticClass:"el-switch__label el-switch__label--left",class:[!_vm.checked ? 'is-active' : '']},[(_vm.inactiveIconClass)?_c('i',{class:[_vm.inactiveIconClass]}):_vm._e(),_c('span',[_vm._v(" "+_vm._s(_vm.inactiveText)+" ")])]):_vm._e(),_c('input',{ref:"input",staticClass:"el-switch__input",class:{ 'allow-focus': _vm.allowFocus },attrs:{"name":_vm.name,"true-value":_vm.activeValue,"false-value":_vm.inactiveValue,"disabled":_vm.disabled,"type":"checkbox"},on:{"change":_vm.handleChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur}}),_c('span',{ref:"core",staticClass:"el-switch__core",style:({ width: _vm.coreWidth + 'px' }),on:{"click":_vm.setFocus}},[_c('span',{staticClass:"el-switch__button",style:({ transform: _vm.transform })})]),(_vm.activeText)?_c('div',{staticClass:"el-switch__label el-switch__label--right",class:[_vm.checked ? 'is-active' : '']},[(_vm.activeIconClass)?_c('i',{class:[_vm.activeIconClass]}):_vm._e(),_c('span',[_vm._v(" "+_vm._s(_vm.activeText)+" ")])]):_vm._e(),(_vm.instruction)?_c('span',{staticClass:"el-switch__instruction"},[_vm._v(" "+_vm._s(_vm.instruction)+" ")]):_vm._e()])}
var componentvue_type_template_id_3e1280c6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/switch/src/component.vue?vue&type=template&id=3e1280c6&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/switch/src/component.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var switch_src_componentvue_type_script_lang_js_ = ({
  name: 'ElSwitch',
  props: {
    value: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 0
    },
    activeText: {
      type: String,
      default: ''
    },
    inactiveText: {
      type: String,
      default: ''
    },
    activeIconClass: {
      type: String,
      default: ''
    },
    inactiveIconClass: {
      type: String,
      default: ''
    },
    size: {
      type: String,
      default: 'medium'
    },
    instruction: {
      type: String,
      default: null
    },
    activeColor: {
      type: String,
      default: ''
    },
    inactiveColor: {
      type: String,
      default: ''
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    name: {
      type: String,
      default: ''
    },
    allowFocus: {
      type: Boolean,
      default: false
    },
    beforeChange: {
      type: Function,
      default: null
    }
  },
  data() {
    return {
      coreWidth: this.width
    };
  },
  computed: {
    checked() {
      return this.value === this.activeValue;
    },
    transform() {
      if (this.size === 'small') {
        return this.checked ? `translate(${this.coreWidth - 18}px, 1px)` : 'translate(2px, 1px)';
      } else if (this.size === 'mini') {
        return this.checked ? `translate(${this.coreWidth - 14}px, 1px)` : 'translate(2px, 1px)';
      }
      return this.checked ? `translate(${this.coreWidth - 22}px, 1px)` : 'translate(2px, 1px)';
    }
  },
  watch: {
    checked() {
      this.$refs.input.checked = this.checked;
      if (this.activeColor || this.inactiveColor) {
        this.setBackgroundColor();
      }
    }
  },
  created() {
    if (!~[this.activeValue, this.inactiveValue].indexOf(this.value)) {
      this.$emit('input', this.inactiveValue);
    }
  },
  mounted() {
    /* istanbul ignore if */
    if (this.width === 0) {
      this.coreWidth = 48;
      if (this.size === 'medium') {
        this.coreWidth = 48;
      } else if (this.size === 'small') {
        this.coreWidth = 40;
      } else if (this.size === 'mini') {
        this.coreWidth = 32;
      }
    }
    if (this.activeColor || this.inactiveColor) {
      this.setBackgroundColor();
    }
    this.$refs.input.checked = this.checked;
  },
  methods: {
    handleChange() {
      // 判断是否存在beforeChange
      if (this.beforeChange) {
        this.beforeChange(this.checked ? this.activeValue : this.inactiveValue, () => {
          this.change();
        });
      } else {
        this.change();
      }
    },
    change() {
      this.$emit('input', !this.checked ? this.activeValue : this.inactiveValue);
      this.$emit('change', !this.checked ? this.activeValue : this.inactiveValue);
      this.$nextTick(() => {
        // set input's checked property
        // in case parent refuses to change component's value
        this.$refs.input.checked = this.checked;
      });
    },
    setBackgroundColor() {
      const newColor = this.checked ? this.activeColor : this.inactiveColor;
      this.$refs.core.style.borderColor = newColor;
      this.$refs.core.style.backgroundColor = newColor;
    },
    setFocus() {
      // set focus on input
      if (this.allowFocus) {
        this.$refs.input.focus();
      }
    },
    handleBlur(event) {
      if (this.allowFocus) {
        this.$emit('blur', event);
      }
    },
    handleFocus(event) {
      if (this.allowFocus) {
        this.$emit('focus', event);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/switch/src/component.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_switch_src_componentvue_type_script_lang_js_ = (switch_src_componentvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/switch/src/component.vue





/* normalize component */

var src_component_component = normalizeComponent(
  packages_switch_src_componentvue_type_script_lang_js_,
  componentvue_type_template_id_3e1280c6_render,
  componentvue_type_template_id_3e1280c6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var switch_src_component = (src_component_component.exports);
// CONCATENATED MODULE: ./packages/switch/index.js


/* istanbul ignore next */
switch_src_component.install = function (Vue) {
  Vue.component(switch_src_component.name, switch_src_component);
};
/* harmony default export */ var packages_switch = (switch_src_component);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option-group.vue?vue&type=template&id=1ed2d12f&
var option_groupvue_type_template_id_1ed2d12f_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:"el-select-group__wrap"},[_c('li',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-select-group__title"},[_vm._v(" "+_vm._s(_vm.label)+" ")]),_c('li',[_c('ul',{staticClass:"el-select-group"},[_vm._t("default")],2)])])}
var option_groupvue_type_template_id_1ed2d12f_staticRenderFns = []


// CONCATENATED MODULE: ./packages/select/src/option-group.vue?vue&type=template&id=1ed2d12f&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/select/src/option-group.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var option_groupvue_type_script_lang_js_ = ({
  name: 'ElOptionGroup',
  mixins: [emitter],
  componentName: 'ElOptionGroup',
  props: {
    label: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      visible: true
    };
  },
  watch: {
    disabled(val) {
      this.broadcast('ElOption', 'handleGroupDisabled', val);
    }
  },
  created() {
    this.$on('queryChange', this.queryChange);
  },
  mounted() {
    if (this.disabled) {
      this.broadcast('ElOption', 'handleGroupDisabled', this.disabled);
    }
  },
  methods: {
    queryChange() {
      this.visible = this.$children && Array.isArray(this.$children) && this.$children.some(option => option.visible === true);
    }
  }
});
// CONCATENATED MODULE: ./packages/select/src/option-group.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_option_groupvue_type_script_lang_js_ = (option_groupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/select/src/option-group.vue





/* normalize component */

var option_group_component = normalizeComponent(
  src_option_groupvue_type_script_lang_js_,
  option_groupvue_type_template_id_1ed2d12f_render,
  option_groupvue_type_template_id_1ed2d12f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var option_group = (option_group_component.exports);
// CONCATENATED MODULE: ./packages/option-group/index.js


/* istanbul ignore next */
option_group.install = function (Vue) {
  Vue.component(option_group.name, option_group);
};
/* harmony default export */ var packages_option_group = (option_group);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=template&id=3d789884&
var tablevue_type_template_id_3d789884_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-table",class:{
    'el-table--fit': _vm.fit,
    'el-table--striped': _vm.stripe,
    'el-table--border': _vm.border,
    'el-table--group': _vm.isGroup,
    'el-table--fluid-height': _vm.maxHeight,
    'el-table--enable-row-hover': !_vm.store.states.isComplex,
    'el-table--enable-row-transition':
      (_vm.store.states.data || []).length !== 0 &&
      (_vm.store.states.data || []).length < 100
  },on:{"mouseleave":function($event){return _vm.handleMouseLeave($event)}}},[_c('div',{ref:"hiddenColumns",staticClass:"hidden-columns"},[_vm._t("default")],2),(_vm.showHeader)?_c('div',{ref:"headerWrapper",staticClass:"el-table__header-wrapper"},[_c('table-header',{style:({ width: _vm.bodyWidth }),attrs:{"store":_vm.store,"default-sort":_vm.defaultSort}})],1):_vm._e(),_c('div',{ref:"bodyWrapper",staticClass:"el-table__body-wrapper",style:([_vm.bodyHeight])},[_c('el-scrollbar',{ref:"tableScrollbar",attrs:{"overflow":_vm.alwaysShowBar || _vm.isFixBarScrollShow ? 'scroll' : 'auto',"overflow-x":_vm.niceScroll === 'vertical' ? 'hidden' : 'auto',"wrap-class":"el-table-scrollbar__wrap","view-class":"el-table-scrollbar__view","wrap-style":_vm.wrapStyle,"view-style":[{ width: _vm.bodyWidth }]},on:{"on-scrolling-x":_vm.onScrollingX,"on-scrolling-y":_vm.onScrollingY}},[_c('table-body',{ref:"tableBody",style:({ width: _vm.bodyWidth }),attrs:{"context":_vm.context,"store":_vm.store,"stripe":_vm.stripe,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle,"highlight":_vm.highlightCurrentRow}}),(_vm.isShowEmptyText)?_c('div',{staticClass:"el-table__empty-block",style:({ width: _vm.bodyWidth })},[_c('span',{staticClass:"el-table__empty-text"},[_vm._t("empty",function(){return [_vm._v(" "+_vm._s(_vm.emptyText || _vm.t('el.table.emptyText'))+" ")]})],2)]):_vm._e()],1),(_vm.showLoading)?_vm._t("loading",function(){return [_c('div',{directives:[{name:"loading",rawName:"v-loading",value:(_vm.showLoading),expression:"showLoading"}],staticClass:"el-table__loading"})]}):_vm._e()],2),(_vm.showSummary)?_c('div',{ref:"footerWrapper",staticClass:"el-table__footer-wrapper"},[_c('table-footer',{style:({ width: _vm.bodyWidth }),attrs:{"store":_vm.store,"border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"default-sort":_vm.defaultSort}})],1):_vm._e(),(_vm.fixedColumns.length > 0)?_c('div',{ref:"fixedWrapper",staticClass:"el-table__fixed",style:([{ width: _vm.fixedWidth }, _vm.fixedHeight]),on:{"mouseenter":function($event){$event.stopPropagation();_vm.isFixBarScrollShow = true},"mouseleave":function($event){$event.stopPropagation();_vm.isFixBarScrollShow = false}}},[(_vm.showHeader)?_c('div',{ref:"fixedHeaderWrapper",staticClass:"el-table__fixed-header-wrapper"},[_c('table-header',{style:({ width: _vm.fixedWidth }),attrs:{"store":_vm.store,"fixed":"left"}})],1):_vm._e(),_c('div',{ref:"fixedBodyWrapper",staticClass:"el-table__fixed-body-wrapper",style:([_vm.fixedBodyHeight])},[_c('table-body',{ref:"tableBody",style:({ width: _vm.fixedWidth }),attrs:{"store":_vm.store,"stripe":_vm.stripe,"highlight":_vm.highlightCurrentRow,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle,"fixed":"left"}})],1),(_vm.showSummary)?_c('div',{ref:"fixedFooterWrapper",staticClass:"el-table__fixed-footer-wrapper"},[_c('table-footer',{style:({ width: _vm.fixedWidth }),attrs:{"border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"store":_vm.store,"fixed":"left"}})],1):_vm._e()]):_vm._e(),(_vm.fixedColumns.length > 0)?_c('div',{staticClass:"el-table__fixed-box-shadow el-table__fixed-box-shadow-left",style:([
      {
        width: _vm.fixedWidth,
        height: _vm.fixedShadowHeight
      }
    ])}):_vm._e(),(_vm.rightFixedColumns.length > 0)?_c('div',{ref:"rightFixedWrapper",staticClass:"el-table__fixed-right",style:([
      { width: _vm.rightFixedWidth },
      {
        right: _vm.border ? _vm.layout.gutterWidth : (_vm.layout.gutterWidth || 1) + 'px'
      },
      _vm.fixedHeight
    ]),on:{"mouseenter":function($event){$event.stopPropagation();_vm.isFixBarScrollShow = true},"mouseleave":function($event){$event.stopPropagation();_vm.isFixBarScrollShow = false}}},[(_vm.showHeader)?_c('div',{ref:"rightFixedHeaderWrapper",staticClass:"el-table__fixed-header-wrapper"},[_c('table-header',{style:({ width: _vm.rightFixedWidth }),attrs:{"store":_vm.store,"fixed":"right"}})],1):_vm._e(),_c('div',{ref:"rightFixedBodyWrapper",staticClass:"el-table__fixed-body-wrapper",style:([_vm.fixedBodyHeight])},[_c('table-body',{ref:"tableBody",style:({ width: _vm.rightFixedWidth }),attrs:{"store":_vm.store,"stripe":_vm.stripe,"row-class-name":_vm.rowClassName,"row-style":_vm.rowStyle,"highlight":_vm.highlightCurrentRow,"fixed":"right"}})],1),(_vm.showSummary)?_c('div',{ref:"rightFixedFooterWrapper",staticClass:"el-table__fixed-footer-wrapper"},[_c('table-footer',{style:({ width: _vm.rightFixedWidth }),attrs:{"border":_vm.border,"sum-text":_vm.sumText || _vm.t('el.table.sumText'),"summary-method":_vm.summaryMethod,"store":_vm.store,"fixed":"right"}})],1):_vm._e()]):_vm._e(),(_vm.rightFixedColumns.length > 0)?_c('div',{staticClass:"el-table__fixed-box-shadow el-table__fixed-box-shadow-right",style:([
      {
        width: _vm.rightFixedWidth,
        height: _vm.fixedShadowHeight
      }
    ])}):_vm._e(),(_vm.rightFixedColumns.length > 0)?_c('div',{staticClass:"el-table__fixed-right-patch",style:({ width: '0', height: _vm.layout.headerHeight + 'px' })}):_vm._e(),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.resizeProxyVisible),expression:"resizeProxyVisible"}],ref:"resizeProxy",staticClass:"el-table__column-resize-proxy"})])}
var tablevue_type_template_id_3d789884_staticRenderFns = []


// CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=template&id=3d789884&

// CONCATENATED MODULE: ./packages/table/src/util.js

const getCell = function (event) {
  let cell = event.target;
  while (cell && cell.tagName.toUpperCase() !== 'HTML') {
    if (cell.tagName.toUpperCase() === 'TD') {
      return cell;
    }
    cell = cell.parentNode;
  }
  return null;
};
const util_isObject = function (obj) {
  return obj !== null && typeof obj === 'object';
};
const orderBy = function (array, sortKey, reverse, sortMethod, defaultSortMethod) {
  if (typeof reverse === 'string') {
    reverse = reverse === 'descending' ? -1 : 1;
  } else {
    return array;
  }
  if (!sortKey && !sortMethod) {
    return array;
  }
  const order = reverse && reverse < 0 ? -1 : 1;

  // sort on a copy to avoid mutating original array
  return array.slice().sort(sortMethod ? function (a, b) {
    return sortMethod(a, b) ? order : -order;
  } : function (a, b) {
    if (sortKey !== '$key') {
      if (util_isObject(a) && '$value' in a) a = a.$value;
      if (util_isObject(b) && '$value' in b) b = b.$value;
    }
    a = util_isObject(a) ? getValueByPath(a, sortKey) : a;
    b = util_isObject(b) ? getValueByPath(b, sortKey) : b;
    if (!defaultSortMethod) return a === b ? 0 : a > b ? order : -order;
    return defaultSortMethod(a, b) ? order : -order;
  });
};
const getColumnById = function (table, columnId) {
  let column = null;
  (table.columns || []).forEach(function (item) {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};
const getColumnByCell = function (table, cell) {
  const matches = (cell.className || '').match(/el-table_[^\s]+/gm);
  if (matches) {
    return getColumnById(table, matches[0]);
  }
  return null;
};
const isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
const mousewheel = function (element, callback) {
  if (element && element.addEventListener) {
    element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', callback);
  }
};
const normalizeWheel = event => {
  // Reasonable defaults
  const PIXEL_STEP = 10;
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;

  // spinX, spinY, pixelX, pixelY
  let sX = 0;
  let sY = 0;
  let pX = 0;
  let pY = 0;

  // Legacy
  if ('detail' in event) {
    sY = event.detail;
  }
  if ('wheelDelta' in event) {
    sY = -event.wheelDelta / 120;
  }
  if ('wheelDeltaY' in event) {
    sY = -event.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in event) {
    sX = -event.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ('deltaY' in event) {
    pY = event.deltaY;
  }
  if ('deltaX' in event) {
    pX = event.deltaX;
  }
  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode === 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
};
const getRowIdentity = (row, rowKey) => {
  if (!row) throw new Error('row is required when get row identity');
  if (typeof rowKey === 'string') {
    if (rowKey.indexOf('.') < 0) {
      return row[rowKey];
    }
    const key = rowKey.split('.');
    let current = row;
    for (let i = 0; i < key.length; i++) {
      current = current[key[i]];
    }
    return current;
  } else if (typeof rowKey === 'function') {
    return rowKey(row);
  }
};
// CONCATENATED MODULE: ./packages/table/src/table-store.js




const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
    return data;
  }
  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, states.defaultSortMethod);
};
const getKeysMap = function (array, rowKey) {
  const arrayMap = {};
  (array || []).forEach((row, index) => {
    arrayMap[getRowIdentity(row, rowKey)] = {
      row,
      index
    };
  });
  return arrayMap;
};
const toggleRowSelection = function (selection, row, selected) {
  let changed = false;
  const index = selection.indexOf(row);
  if (typeof selected === 'undefined') {
    if (index === -1) {
      selection.push(row);
      changed = true;
    } else {
      selection.splice(index, 1);
      changed = true;
    }
  } else {
    if (selected && index === -1) {
      selection.push(row);
      changed = true;
    } else if (!selected && index > -1) {
      selection.splice(index, 1);
      changed = true;
    }
  }
  return changed;
};
const toggleRowExpanded = function (states, row, expanded) {
  let changed = false;
  const expandRows = states.expandRows;
  if (typeof expanded !== 'undefined') {
    const index = expandRows.indexOf(row);
    if (expanded) {
      if (index === -1) {
        expandRows.push(row);
        changed = true;
      }
    } else {
      if (index !== -1) {
        expandRows.splice(index, 1);
        changed = true;
      }
    }
  } else {
    const index = expandRows.indexOf(row);
    if (index === -1) {
      expandRows.push(row);
      changed = true;
    } else {
      expandRows.splice(index, 1);
      changed = true;
    }
  }
  return changed;
};
const TableStore = function (table, initialState = {}) {
  if (!table) {
    throw new Error('Table is required.');
  }
  this.table = table;
  this.states = {
    rowKey: null,
    _columns: [],
    originColumns: [],
    columns: [],
    fixedColumns: [],
    rightFixedColumns: [],
    fixedLeafColumns: [],
    rightFixedLeafColumns: [],
    isComplex: false,
    _data: null,
    filteredData: null,
    data: null,
    sortingColumn: null,
    sortProp: null,
    sortOrder: null,
    isAllSelected: false,
    selection: [],
    reserveSelection: false,
    selectable: null,
    currentRow: null,
    hoverRow: null,
    filters: {},
    expandRows: [],
    defaultExpandAll: false,
    defaultSortMethod: null,
    rowsHeight: [],
    rowHeight: 36,
    // 全选是否禁用
    isAllDisabled: false
  };
  for (const prop in initialState) {
    if (hasOwn(initialState, prop) && hasOwn(this.states, prop)) {
      this.states[prop] = initialState[prop];
    }
  }
};
TableStore.prototype.mutations = {
  setData(states, data) {
    const dataInstanceChanged = states._data !== data;
    states._data = data;
    Object.keys(states.filters).forEach(columnId => {
      const values = states.filters[columnId];
      if (!values || values.length === 0) return;
      const column = getColumnById(this.states, columnId);
      if (column && column.filterMethod) {
        data = data.filter(row => {
          return values.some(value => column.filterMethod.call(null, value, row));
        });
      }
    });
    states.filteredData = data;
    states.data = sortData(data || [], states);

    // states.data.forEach((item) => {
    //   if (!item.$extra) {
    //     Object.defineProperty(item, '$extra', {
    //       value: {},
    //       enumerable: false
    //     });
    //   }
    // });

    this.updateCurrentRow();
    if (!states.reserveSelection) {
      if (dataInstanceChanged) {
        this.clearSelection();
      } else {
        this.cleanSelection();
      }
      this.updateAllSelected();
    } else {
      const rowKey = states.rowKey;
      if (rowKey) {
        const selection = states.selection;
        const selectedMap = getKeysMap(selection, rowKey);
        states.data.forEach(row => {
          const rowId = getRowIdentity(row, rowKey);
          const rowInfo = selectedMap[rowId];
          if (rowInfo) {
            selection[rowInfo.index] = row;
          }
        });
        this.updateAllSelected();
      } else {
         false && false;
      }
    }
    const defaultExpandAll = states.defaultExpandAll;
    if (defaultExpandAll) {
      this.states.expandRows = (states.data || []).slice(0);
    }
    this.getTableRowsHeight();
  },
  changeSortCondition(states) {
    states.data = sortData(states.filteredData || states._data || [], states);
    this.table.$emit('sort-change', {
      column: this.states.sortingColumn,
      prop: this.states.sortProp,
      order: this.states.sortOrder
    });

    // Vue.nextTick(() => this.table.updateScrollY());
  },
  filterChange(states, options) {
    const {
      column,
      silent
    } = options;
    let {
      values
    } = options;
    if (values && !Array.isArray(values)) {
      values = [values];
    }
    const prop = column.property;
    const filters = {};
    if (prop) {
      states.filters[column.id] = values;
      filters[column.columnKey || column.id] = values;
    }
    let data = states._data;
    Object.keys(states.filters).forEach(columnId => {
      const values = states.filters[columnId];
      if (!values || values.length === 0) return;
      const column = getColumnById(this.states, columnId);
      if (column && column.filterMethod) {
        data = data.filter(row => {
          return values.some(value => column.filterMethod.call(null, value, row, column));
        });
      }
    });
    states.filteredData = data;
    states.data = sortData(data, states);
    if (!silent) {
      this.table.$emit('filter-change', filters);
    }
  },
  insertColumn(states, column, index, parent) {
    let array = states._columns;
    if (parent) {
      array = parent.children;
      if (!array) array = parent.children = [];
    }
    if (typeof index !== 'undefined') {
      array.splice(index, 0, column);
    } else {
      array.push(column);
    }
    if (column.type === 'selection') {
      states.selectable = column.selectable;
      states.reserveSelection = column.reserveSelection;
    }
    if (this.table.$ready) {
      this.updateColumns(); // hack for dynamics insert column
      this.scheduleLayout();
    }
  },
  removeColumn(states, column, parent) {
    let array = states._columns;
    if (parent) {
      array = parent.children;
      if (!array) array = parent.children = [];
    }
    if (array) {
      array.splice(array.indexOf(column), 1);
    }
    if (this.table.$ready) {
      this.updateColumns(); // hack for dynamics remove column
      this.scheduleLayout();
    }
  },
  setHoverRow(states, row) {
    states.hoverRow = row;
  },
  setCurrentRow(states, row) {
    const oldCurrentRow = states.currentRow;
    states.currentRow = row;
    if (oldCurrentRow !== row) {
      this.table.$emit('current-change', row, oldCurrentRow);
    }
  },
  rowSelectedChanged(states, row) {
    const changed = toggleRowSelection(states.selection, row);
    const selection = states.selection;
    if (changed) {
      const table = this.table;
      table.$emit('selection-change', selection);
      const isCurrentSelect = selection.indexOf(row) !== -1;
      table.$emit('select', selection, row, isCurrentSelect);
    }
    this.updateAllSelected();
  },
  toggleAllSelection: debounce_default()(10, function (states) {
    const data = states.data || [];
    const value = !states.isAllSelected;
    const selection = this.states.selection;
    let selectionChanged = false;
    const changedList = [];
    data.forEach((item, index) => {
      if (states.selectable) {
        if (states.selectable.call(null, item, index) && toggleRowSelection(selection, item, value)) {
          changedList.push(item);
          selectionChanged = true;
        }
      } else {
        if (toggleRowSelection(selection, item, value)) {
          changedList.push(item);
          selectionChanged = true;
        }
      }
    });
    const table = this.table;
    if (selectionChanged) {
      table.$emit('selection-change', selection);
    }
    table.$emit('select-all', selection, value, changedList);
    states.isAllSelected = value;
  })
};
const doFlattenColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
TableStore.prototype.getTableRowsHeight = function () {
  if (!this.states.isComplex && !this.table.isVirtualScroll) return;
  if (!this.table.$ready) return external_vue_default.a.nextTick(() => this.getTableRowsHeight());
  if (this.table.isVirtualScroll && "production" === 'production') {
    // 虚拟滚动在生产环境下只取第一行高度来得到行高以减少性能消耗
    // 开发环境下取所有行的高度，且行高不固定时做控制台的提示
    const row = this.table.bodyWrapper.querySelector('tbody > tr.el-table__row');
    if (row) {
      this.states.rowsHeight = [row.getBoundingClientRect().height];
      this.states.rowHeight = row.getBoundingClientRect().height;
    }
  } else {
    const rows = this.table.bodyWrapper.querySelectorAll('tbody > tr.el-table__row');
    if (rows.length) {
      const rowsHeight = [];
      for (let i = 0; i < rows.length; ++i) {
        const tr = rows[i];
        rowsHeight.push(tr.getBoundingClientRect().height);
      }
      this.states.rowsHeight = rowsHeight;
      this.states.rowHeight = this.getRowHeight();
    }
  }
};
TableStore.prototype.getRowHeight = function () {
  const distinct = [...new Set(this.states.rowsHeight)];
  const isRowsHeightEqual = distinct.length === 1;
  if (this.table.isVirtualScroll && !isRowsHeightEqual) {
     false && false;
  }
  return distinct[0];
};
TableStore.prototype.updateColumns = function () {
  const states = this.states;
  const _columns = states._columns || [];
  states.fixedColumns = _columns.filter(column => column.fixed === true || column.fixed === 'left');
  states.rightFixedColumns = _columns.filter(column => column.fixed === 'right');
  if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
    _columns[0].fixed = true;
    states.fixedColumns.unshift(_columns[0]);
  }
  const notFixedColumns = _columns.filter(column => !column.fixed);
  states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);
  const leafColumns = doFlattenColumns(notFixedColumns);
  states.fixedLeafColumns = doFlattenColumns(states.fixedColumns);
  states.rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);
  states.columns = [].concat(states.fixedLeafColumns).concat(leafColumns).concat(states.rightFixedLeafColumns);
  states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
  this.getTableRowsHeight();
};
TableStore.prototype.isSelected = function (row) {
  return (this.states.selection || []).indexOf(row) > -1;
};
TableStore.prototype.clearSelection = function () {
  const states = this.states;
  states.isAllSelected = false;
  const oldSelection = states.selection;
  states.selection = [];
  if (oldSelection.length > 0) {
    this.table.$emit('selection-change', states.selection);
  }
};
TableStore.prototype.setExpandRowKeys = function (rowKeys) {
  const expandRows = [];
  const data = this.states.data;
  const rowKey = this.states.rowKey;
  if (!rowKey) throw new Error('[Table] prop row-key should not be empty.');
  const keysMap = getKeysMap(data, rowKey);
  rowKeys.forEach(key => {
    const info = keysMap[key];
    if (info) {
      expandRows.push(info.row);
    }
  });
  this.states.expandRows = expandRows;
};
TableStore.prototype.toggleRowSelection = function (row, selected, emitChange = true) {
  const changed = toggleRowSelection(this.states.selection, row, selected);
  if (changed) {
    const newSelection = (this.states.selection || []).slice();
    // 调用 API 修改选中值，不触发 select 事件
    if (emitChange) {
      this.table.$emit('select', newSelection, row);
    }
    this.table.$emit('selection-change', this.states.selection);
  }
};
TableStore.prototype.toggleRowExpanded = function (row, expanded) {
  const changed = toggleRowExpanded(this.states, row, expanded);
  if (changed) {
    this.table.$emit('expand-change', row, this.states.expandRows);
  }
};
TableStore.prototype.cleanSelection = function () {
  const selection = this.states.selection || [];
  const data = this.states.data;
  const rowKey = this.states.rowKey;
  let deleted;
  if (rowKey) {
    deleted = [];
    const selectedMap = getKeysMap(selection, rowKey);
    const dataMap = getKeysMap(data, rowKey);
    for (const key in selectedMap) {
      if (hasOwn(selectedMap, key) && !dataMap[key]) {
        deleted.push(selectedMap[key].row);
      }
    }
  } else {
    deleted = selection.filter(item => {
      return data.indexOf(item) === -1;
    });
  }
  deleted.forEach(deletedItem => {
    selection.splice(selection.indexOf(deletedItem), 1);
  });
  if (deleted.length) {
    this.table.$emit('selection-change', selection);
  }
};
TableStore.prototype.updateAllSelected = function () {
  const states = this.states;
  const {
    selection,
    rowKey,
    selectable,
    data
  } = states;
  if (!data || data.length === 0) {
    states.isAllSelected = false;
    return;
  }
  let selectedMap;
  if (rowKey) {
    selectedMap = getKeysMap(states.selection, rowKey);
  }
  const isSelected = function (row) {
    if (selectedMap) {
      return !!selectedMap[getRowIdentity(row, rowKey)];
    } else {
      return selection.indexOf(row) !== -1;
    }
  };
  let isAllSelected = true;
  let selectedCount = 0;
  for (let i = 0, j = data.length; i < j; i++) {
    const item = data[i];
    if (selectable) {
      const isRowSelectable = selectable(item, i);
      if (isRowSelectable) {
        if (!isSelected(item)) {
          isAllSelected = false;
          break;
        } else {
          selectedCount++;
        }
      }
    } else {
      if (!isSelected(item)) {
        isAllSelected = false;
        break;
      } else {
        selectedCount++;
      }
    }
  }
  if (selectedCount === 0) isAllSelected = false;
  states.isAllSelected = isAllSelected;
};
TableStore.prototype.scheduleLayout = function (dragResize) {
  this.table.debouncedLayout(dragResize);
};
TableStore.prototype.setCurrentRowKey = function (key) {
  const states = this.states;
  const rowKey = states.rowKey;
  if (!rowKey) throw new Error('[Table] row-key should not be empty.');
  const data = states.data || [];
  const keysMap = getKeysMap(data, rowKey);
  const info = keysMap[key];
  if (info) {
    states.currentRow = info.row;
  }
};
TableStore.prototype.updateCurrentRow = function () {
  const states = this.states;
  const table = this.table;
  const data = states.data || [];
  const oldCurrentRow = states.currentRow;
  if (data.indexOf(oldCurrentRow) === -1) {
    // 注释为null 因为切换table回来时，需要保留上次选中的行
    // states.currentRow = null;

    if (states.currentRow !== oldCurrentRow) {
      table.$emit('current-change', null, oldCurrentRow);
    }
  }
};
TableStore.prototype.commit = function (name, ...args) {
  const mutations = this.mutations;
  if (mutations[name]) {
    mutations[name].apply(this, [this.states].concat(args));
  } else {
    throw new Error(`Action not found: ${name}`);
  }
};
/* harmony default export */ var table_store = (TableStore);
// CONCATENATED MODULE: ./packages/table/src/table-layout.js

// import scrollbarWidth from 'hui/src/utils/scrollbar-width';

class table_layout_TableLayout {
  constructor(options) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = null;
    this.fit = true;
    this.showHeader = true;
    this.height = null;
    // this.scrollX = false;
    // this.scrollY = false;
    this.bodyWidth = null;
    this.fixedWidth = null;
    this.fixedBodyTop = null; // 固定列时计算header高度
    this.rightFixedWidth = null;
    this.tableHeight = null;
    this.headerHeight = 36; // Table Header Height
    this.footerHeight = 0; // Table Footer Height
    // this.viewportHeight = null; // Table Height - Scroll Bar Height （same with tableHeight）
    this.bodyHeight = null; // Table Height - Table Header Height
    this.fixedBodyHeight = null; // Table Height - Table Header Height - Scroll Bar Height
    this.dragFlexWidth = 0; // 记录拖拽可调节宽度
    this.hasDragged = false; // 记录是否拖拽过
    for (const name in options) {
      if (hasOwn(options, name)) {
        this[name] = options[name];
      }
    }
    if (!this.table) {
      throw new Error('table is required for Table Layout');
    }
    if (!this.store) {
      throw new Error('store is required for Table Layout');
    }
  }
  setHeight(value, prop = 'height') {
    const el = this.table.$el;
    if (typeof value === 'string' && /^\d+$/.test(value)) {
      value = Number(value);
    }
    this.height = value;
    if (!el && (value || value === 0)) {
      return external_vue_default.a.nextTick(() => this.setHeight(value, prop));
    }
    if (typeof value === 'number') {
      el.style[prop] = value + 'px';
      this.updateHeight();
    } else if (typeof value === 'string') {
      el.style[prop] = value;
      this.updateHeight();
    }
  }
  setMaxHeight(value) {
    return this.setHeight(value, 'max-height');
  }
  updateHeight() {
    if (!this.table.$ready) return external_vue_default.a.nextTick(() => this.updateHeight());
    const {
      headerWrapper,
      appendWrapper,
      footerWrapper
    } = this.table.$refs;
    this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper) return;

    // fix issue (https://github.com/ElemeFE/element/pull/16956)
    const headerTrElm = headerWrapper ? headerWrapper.querySelector('.el-table__header tr') : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerHeight = this.headerHeight = !this.showHeader ? 0 : headerWrapper.offsetHeight;
    if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.columns || []).length > 0 && headerHeight < 2) {
      return external_vue_default.a.nextTick(() => this.updateHeight());
    }
    const tableHeight = this.tableHeight = this.table.$el.clientHeight;
    const footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
    if (this.height !== null) {
      this.bodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
    }
    this.fixedBodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
  }
  headerDisplayNone(elm) {
    if (!elm) return true;
    let headerChild = elm;
    while (headerChild.tagName !== 'DIV') {
      if (getComputedStyle(headerChild).display === 'none') {
        return true;
      }
      headerChild = headerChild.parentElement;
    }
    return false;
  }
  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.columns;
    columns.forEach(column => {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }
  update(dragResize) {
    const fit = this.fit;
    const hasDragged = this.hasDragged = this.hasDragged || dragResize;
    // const columns = this.table.columns;
    const bodyWidth = this.table.$el.clientWidth || this.bodyWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    // 兼容没有设置 column 的场景
    if (!flattenColumns.length) return;
    let flexColumns = flattenColumns.filter(column => typeof column.width !== 'number');
    if (fit) {
      // 存在列没有设置 width 为 number 的场景（width为百分比或者没有设置）
      if (flexColumns.length > 0 && !hasDragged) {
        flattenColumns.forEach(column => {
          if (typeof column.width === 'number') {
            bodyMinWidth += column.width;
          }
        });
        const remainWidth = bodyWidth - bodyMinWidth;
        let percent = 0;
        flexColumns.forEach(column => {
          if (/%$/.test(column.width)) {
            percent = Number(column.width.replace(/%$/, '')) / 100;
            const realWidth = remainWidth * percent >= column.minWidth ? remainWidth * percent : column.minWidth;
            column.realWidth = realWidth;
            bodyMinWidth += realWidth;
          } else {
            bodyMinWidth += column.minWidth || 80;
          }
        });
        flexColumns = flexColumns.filter(column => !/%$/.test(column.width));
        // DON'T HAVE SCROLL BAR
        if (bodyMinWidth < bodyWidth && flexColumns.length) {
          const totalFlexWidth = bodyWidth - bodyMinWidth;
          if (flexColumns.length === 1) {
            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
          } else {
            const allColumnsWidth = flexColumns.reduce((prev, column) => prev + (column.minWidth || 80), 0);
            const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
            let noneFirstWidth = 0;
            flexColumns.forEach((column, index) => {
              if (index === 0) return;
              const flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
              noneFirstWidth += flexWidth;
              column.realWidth = (column.minWidth || 80) + flexWidth;
            });
            flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
          }
        } else {
          // HAVE HORIZONTAL SCROLL BAR
          flexColumns.forEach(function (column) {
            column.realWidth = column.minWidth;
          });
        }
        this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
      } else {
        // 1.flexColumns.length === 0 即各列宽度均被设置为 number 时
        // 2.hasDragged = true 用户对列宽进行了拖拽操作
        // 拖动
        flattenColumns.forEach(column => {
          bodyMinWidth += column.realWidth;
        });
        if (bodyMinWidth - bodyWidth >= this.dragFlexWidth) {
          flattenColumns[flattenColumns.length - 1].realWidth = flattenColumns[flattenColumns.length - 1].realWidth - this.dragFlexWidth;
          this.bodyWidth = bodyMinWidth - this.dragFlexWidth;
          this.dragFlexWidth = 0;
        } else if (bodyMinWidth - bodyWidth < this.dragFlexWidth && bodyMinWidth > bodyWidth) {
          const flexWidth = bodyMinWidth - bodyWidth;
          flattenColumns[flattenColumns.length - 1].realWidth = flattenColumns[flattenColumns.length - 1].realWidth - flexWidth;
          this.bodyWidth = bodyWidth;
          this.dragFlexWidth -= flexWidth;
        } else {
          flattenColumns[flattenColumns.length - 1].realWidth = flattenColumns[flattenColumns.length - 1].realWidth + bodyWidth - bodyMinWidth;
          this.dragFlexWidth += bodyWidth - bodyMinWidth;
          this.bodyWidth = bodyWidth;
        }
      }

      // if (this.table.$refs.tableScrollbar) {
      //   this.table.$refs.tableScrollbar.$refs.resize.style.width =
      //     this.bodyWidth + 'px';
      // }
      this.table.resizeState.width = this.bodyWidth;
    } else {
      flattenColumns.forEach(column => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = column.width || column.minWidth;
        }
        bodyMinWidth += column.realWidth;
      });
      this.bodyWidth = bodyMinWidth;
    }
    const fixedColumns = this.store.states.fixedColumns;
    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach(function (column) {
        fixedWidth += column.realWidth;
      });
      this.fixedWidth = fixedWidth;
    }
    const rightFixedColumns = this.store.states.rightFixedColumns;
    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach(function (column) {
        rightFixedWidth += column.realWidth;
      });
      this.rightFixedWidth = rightFixedWidth;
    }
    const $header = this.table.$el.querySelector('.el-table__header-wrapper');
    this.fixedBodyTop = $header ? window.getComputedStyle($header).getPropertyValue('height') : 0;
    this.notifyObservers();
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }
  notifyObservers() {
    const observers = this.observers;
    observers.forEach(observer => {
      observer.onColumnsChange(this);
    });
  }
}
/* harmony default export */ var table_layout = (table_layout_TableLayout);
// CONCATENATED MODULE: ./packages/table/src/layout-observer.js
/* harmony default export */ var layout_observer = ({
  created() {
    this.tableLayout.addObserver(this);
  },
  destroyed() {
    this.tableLayout.removeObserver(this);
  },
  computed: {
    tableLayout() {
      let layout = this.layout;
      if (!layout && this.table) {
        layout = this.table.layout;
      }
      if (!layout) {
        throw new Error('Can not find table layout.');
      }
      return layout;
    }
  },
  mounted() {
    this.onColumnsChange(this.tableLayout);
  },
  updated() {
    if (this.__updated__) return;
    this.onColumnsChange(this.tableLayout);
    this.__updated__ = true;
  },
  methods: {
    onColumnsChange(layout) {
      const cols = this.$el.querySelectorAll('colgroup > col');
      if (!cols.length) return;
      const flattenColumns = layout.getFlattenColumns();
      const columnsMap = {};
      flattenColumns.forEach(column => {
        columnsMap[column.id] = column;
      });
      for (let i = 0, j = cols.length; i < j; i++) {
        const col = cols[i];
        const name = col.getAttribute('name');
        const column = columnsMap[name];
        if (column) {
          let w = column.realWidth || column.width;
          if (w < 36) w = 36;
          col.setAttribute('width', w);
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/table/src/table-body.js






/* harmony default export */ var table_body = ({
  name: 'ElTableBody',
  mixins: [layout_observer],
  components: {
    ElCheckbox: packages_checkbox,
    ElTooltip: packages_tooltip
  },
  props: {
    store: {
      required: true
    },
    stripe: {
      type: Boolean,
      default: null
    },
    context: {},
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: String,
    highlight: {
      type: Boolean,
      default: null
    }
  },
  render(h) {
    return h("table", {
      "class": 'el-table__body',
      "attrs": {
        "cellspacing": '0',
        "cellpadding": '0',
        "border": '0'
      }
    }, [h("colgroup", [this._l(this.columns, column => h("col", {
      "attrs": {
        "name": column.id
      }
    }))]), h("tbody", [this._l(this.data, (row, _$index) => {
      // modify by zhangxiaogang
      const renderExpanded = this.table.renderExpanded || this.table.$parent.renderExpanded;
      const $index = _$index + this.startIndex;
      return [h("tr", {
        "style": this.getRowStyle(row, $index),
        "key": this.table.rowKey ? this.getKeyOfRow(row, $index) : $index,
        "on": {
          "dblclick": $event => this.handleDoubleClick($event, row),
          "click": $event => this.handleClick($event, row, $index),
          "contextmenu": $event => this.handleContextMenu($event, row),
          "mouseenter": () => this.handleMouseEnter($index),
          "mouseleave": () => this.handleMouseLeave()
        },
        "class": [this.getRowClass(row, $index)]
      }, [this._l(this.columns, (column, _cellIndex) => {
        const cellIndex = column.cellIndex || _cellIndex;
        const {
          rowspan,
          colspan
        } = this.getSpan(row, column, $index, cellIndex);
        if (!rowspan && !colspan) {
          return '';
        } else {
          if (rowspan === 1 && colspan === 1) {
            return h("td", {
              "style": this.getCellStyle($index, cellIndex, row, column),
              "class": this.getCellClass($index, cellIndex, row, column),
              "on": {
                "mouseenter": $event => this.handleCellMouseEnter($event, row),
                "mouseleave": this.handleCellMouseLeave
              }
            }, [column.renderCell.call(this._renderProxy, h, {
              row,
              column,
              $index,
              store: this.store,
              _self: this.context || this.table.$vnode.context
            })]);
          } else {
            return h("td", {
              "style": this.getCellStyle($index, cellIndex, row, column),
              "class": this.getCellClass($index, cellIndex, row, column),
              "attrs": {
                "rowspan": rowspan,
                "colspan": colspan
              },
              "on": {
                "mouseenter": $event => this.handleCellMouseEnter($event, row),
                "mouseleave": this.handleCellMouseLeave
              }
            }, [column.renderCell.call(this._renderProxy, h, {
              row,
              column,
              $index,
              store: this.store,
              _self: this.context || this.table.$vnode.context
            })]);
          }
        }
      })]), this.store.states.expandRows.indexOf(row) > -1 ? h("tr", {
        "class": {
          'is-hidden': this.fixed
        }
      }, [h("td", {
        "attrs": {
          "colspan": this.columns.length
        },
        "class": 'el-table__expanded-cell'
      }, [renderExpanded ? renderExpanded(h, {
        row,
        $index,
        store: this.store
      }) : ''])]) : ''];
    }).concat(this.table.$slots.append).concat(h("el-tooltip", {
      "attrs": {
        "placement": 'top',
        "content": this.tooltipContent
      },
      "ref": 'tooltip'
    }))])]);
  },
  watch: {
    scrollViewStyle: {
      handler(style) {
        if (!this.isVirtualScroll) return;
        if (!this.table.$refs.bodyWrapper) {
          this.$nextTick(() => {
            this.setScrollViewStyle(style);
          });
        } else {
          this.setScrollViewStyle(style);
        }
        // 修复虚拟滚动下固定列错位的问题
        if (this.fixed) {
          this.$nextTick(() => {
            this.setFixedBodyStyle(style);
          });
        }
      },
      immediate: true
    },
    /**
     * modified by zhangxiaogang
     * date: 2018-05-09
     * todo: 合并行列的表格hover需要关联变化，故改写此处逻辑
     */
    'store.states.hoverRow'(newVal) {
      if (!this.store.states.isComplex) return;
      const el = this.$el;
      if (!el) return;
      const rows = el.querySelectorAll('tbody > tr.el-table__row');
      const oldRow = el.querySelector('tbody > tr.el-table__row.hover-row');
      const newRow = newVal !== 0 && !newVal ? null : rows[newVal - this.startIndex];
      if (oldRow) {
        removeClass(oldRow, 'hover-row');
      }
      if (newRow) {
        addClass(newRow, 'hover-row');
      }
      /* const setHover = (index, flag) => {
        const row = rows[index];
        flag ? addClass(row, 'hover-row') : removeClass(row, 'hover-row');
      };
      if (!Array.isArray(newVal)) newVal = [newVal];
      if (!Array.isArray(oldVal)) oldVal = [oldVal];
      [newVal, oldVal].forEach((vv, i) => {
        vv.forEach((v) => {
          !isNaN(v) && setHover(v, i === 0);
        });
      }); */
    },
    'store.states.currentRow'(newVal, oldVal) {
      if (!this.highlight) return;
      const el = this.$el;
      if (!el) return;
      const data = this.store.states.data;
      const rows = el.querySelectorAll('tbody > tr.el-table__row');
      const oldRow = rows[data.indexOf(oldVal)];
      const newRow = rows[data.indexOf(newVal)];
      if (oldRow) {
        removeClass(oldRow, 'current-row');
      } else if (rows) {
        [].forEach.call(rows, row => removeClass(row, 'current-row'));
      }
      if (newRow) {
        addClass(newRow, 'current-row');
      }
    }
  },
  computed: {
    table() {
      if (!this.$parent.columns) {
        return this.$parent.$parent;
      }
      return this.$parent;
    },
    scrollTop() {
      return this.table.scrollTop;
    },
    isVirtualScroll() {
      return this.table.isVirtualScroll;
    },
    rowHeight() {
      return this.store.states.rowHeight;
    },
    clientHeight() {
      return Number(this.table.height) || Number(this.table.maxHeight) || this.table.bodyWrapperHeight;
    },
    scrollState() {
      const {
        scrollTop,
        clientHeight
      } = this;
      return {
        start: scrollTop,
        end: scrollTop + clientHeight
      };
    },
    count() {
      return this.store.states.data.length;
    },
    startIndex() {
      const {
        rowHeight,
        scrollState,
        isVirtualScroll,
        columnsCount
      } = this;
      if (!isVirtualScroll || !columnsCount || !this.count) return 0;
      let index = Math.floor(scrollState.start / rowHeight);
      index < 0 && (index = 0);
      return index;
    },
    endIndex() {
      const {
        rowHeight,
        scrollState,
        count,
        isVirtualScroll
      } = this;
      if (!isVirtualScroll) return count;
      let index = Math.ceil(scrollState.end / rowHeight);
      index > count - 1 && (index = count - 1);
      return index;
    },
    viewMarginTop() {
      return this.startIndex * this.rowHeight;
    },
    viewMarginBottom() {
      return (this.count - 1 - this.endIndex) * this.rowHeight;
    },
    scrollViewStyle() {
      const {
        isVirtualScroll,
        viewMarginTop,
        viewMarginBottom
      } = this;
      return isVirtualScroll ? {
        marginTop: `${viewMarginTop}px`,
        marginBottom: `${viewMarginBottom}px`
      } : {};
    },
    data() {
      return this.isVirtualScroll ? this.store.states.data.slice(this.startIndex, this.endIndex + 1) : this.store.states.data;
    },
    columnsCount() {
      return this.store.states.columns.length;
    },
    leftFixedLeafCount() {
      return this.store.states.fixedLeafColumns.length;
    },
    rightFixedLeafCount() {
      return this.store.states.rightFixedLeafColumns.length;
    },
    columns() {
      if (this.fixed === true || this.fixed === 'left') {
        return this.store.states.fixedLeafColumns;
      } else if (this.fixed === 'right') {
        // 固定列优化后，右侧固定列索引需要计算 add by yangzhini 2020-04-17
        const {
          columns,
          rightFixedLeafColumns
        } = this.store.states;
        const bIndex = columns.length - rightFixedLeafColumns.length;
        return rightFixedLeafColumns.map((col, cellIndex) => ({
          ...col,
          cellIndex: bIndex + cellIndex
        }));
      }
      return this.store.states.columns;
    }
  },
  data() {
    return {
      tooltipContent: ''
    };
  },
  created() {
    this.activateTooltip = debounce_default()(50, tooltip => tooltip.handleShowPopper());
  },
  methods: {
    setScrollViewStyle(style) {
      const scrollView = this.table.$refs.bodyWrapper.querySelector('.el-table-scrollbar__view');
      Object.assign(scrollView.style, style);
    },
    setFixedBodyStyle(style) {
      Object.assign(this.$el.style, style);
    },
    getKeyOfRow(row, index) {
      const rowKey = this.table.rowKey;
      if (rowKey) {
        return getRowIdentity(row, rowKey);
      }
      return index;
    },
    getSpan(row, column, rowIndex, columnIndex) {
      let rowspan = 1;
      let colspan = 1;
      const fn = this.table.spanMethod;
      if (typeof fn === 'function') {
        const result = fn({
          row,
          column,
          rowIndex,
          columnIndex
        });
        if (Array.isArray(result)) {
          rowspan = result[0];
          colspan = result[1];
        } else if (typeof result === 'object') {
          rowspan = result.rowspan;
          colspan = result.colspan;
        }
      }
      return {
        rowspan,
        colspan
      };
    },
    getRowStyle(row, rowIndex) {
      let rowStyle = this.table.rowStyle;
      if (typeof rowStyle === 'function') {
        rowStyle = rowStyle({
          row,
          rowIndex
        });
      }
      if (this.fixed) {
        const rowHeight = this.isVirtualScroll ? this.store.states.rowHeight : this.store.states.rowsHeight[rowIndex];
        const fixedRowStyle = {
          height: `${rowHeight}px`
        };
        if (!rowStyle) {
          return fixedRowStyle;
        }
        if (typeof rowStyle === 'string') {
          return `height:${rowHeight}px;${rowStyle}`;
        }
        if (typeof rowStyle === 'object') {
          return {
            ...rowStyle,
            ...fixedRowStyle
          };
        }
      }
      return rowStyle || null;
    },
    getRowClass(row, rowIndex) {
      const classes = ['el-table__row'];
      if (this.stripe && rowIndex % 2 === 1) {
        classes.push('el-table__row--striped');
      }
      const rowClassName = this.table.rowClassName;
      if (typeof rowClassName === 'string') {
        classes.push(rowClassName);
      } else if (typeof rowClassName === 'function') {
        classes.push(rowClassName({
          row,
          rowIndex
        }));
      }
      if (this.store.states.expandRows.indexOf(row) > -1) {
        classes.push('expanded');
      }

      // 如果切换列表数据判断 currentRow 是否是之前的
      if (this.store.states.currentRow && this.table.rowKey && this.store.states.currentRow[this.table.rowKey] === row[this.table.rowKey]) {
        classes.push('current-row');
      }
      if (this.isRowUnselectable(row, rowIndex)) {
        classes.push('disabled');
      }
      return classes.join(' ');
    },
    getCellStyle(rowIndex, columnIndex, row, column) {
      const cellStyle = this.table.cellStyle;
      if (typeof cellStyle === 'function') {
        return cellStyle({
          rowIndex,
          columnIndex,
          row,
          column
        });
      }
      return cellStyle;
    },
    getCellClass(rowIndex, columnIndex, row, column) {
      const classes = [column.id, column.align, column.className];
      const cellClassName = this.table.cellClassName;
      if (typeof cellClassName === 'string') {
        classes.push(cellClassName);
      } else if (typeof cellClassName === 'function') {
        classes.push(cellClassName({
          rowIndex,
          columnIndex,
          row,
          column
        }));
      }
      return classes.join(' ');
    },
    // 寻找其他相关合并的单元格, 并设置hover状态
    findAndSetRowspanTdHoverState(rowIndex, flag = 'enter') {
      if (flag === 'leave') {
        // 清除之前设置的cell hover状态
        this.$el.querySelectorAll('tbody > tr.el-table__row > td.el-table_td-hover').forEach(td => {
          removeClass(td, 'el-table_td-hover');
        });
      }
      // 如果td没有rowspan属性，则不进行处理
      const cellsWithRowspan = document.querySelectorAll('tbody td[rowspan]');
      if (cellsWithRowspan.length === 0) {
        return;
      }
      const allRows = this.$el.querySelectorAll('tbody > tr.el-table__row');
      // 当td的rowspan为0时，表示从当前行一直到末尾都合并，这个就默认要加上hover状态
      const tds = [...this.$el.querySelectorAll('td[rowspan="0"]')];
      for (let i = 0; i < rowIndex; i++) {
        const row = allRows[i];
        for (const td of row.children) {
          const rowspan = td.getAttribute('rowspan');
          if (rowspan && Number(rowspan) + i > rowIndex) {
            tds.push(td);
          }
        }
      }
      tds.forEach(td => {
        addClass(td, 'el-table_td-hover');
      });
    },
    /**
     * add by zhangxiaogang
     * 2018-05-09
     * 如果有合并行的单元格，鼠标处于合并的单元格，则该单元格所跨的行全部要处于hover状态
     * 鼠标离开，则状态对应改变
     * {@param} cell:单元格td的dom
     * {@param} flag:'enter'表示进入，'leave'表示离开
     **/
    setRowspanTrHoverState(cell, flag = 'enter') {
      const allRow = this.$el.querySelectorAll('tbody > tr.el-table__row');
      let rowspan = cell.getAttribute('rowspan');

      // 当前单元格所在行的序号
      let start = [].slice.call(allRow).indexOf(cell.parentNode);

      // 如果鼠标进入，处理其他相关合并的单元格
      this.findAndSetRowspanTdHoverState(start, flag);

      // 如果rowspan为null，则表示鼠标不再合并的单元格上
      if (rowspan === null) {
        return;
      }
      rowspan = +rowspan;
      // rowspan == 0表示从当前行一直都末尾都合并
      // rowspan == 1无意义，等同于未合并
      if (rowspan > 1 || rowspan === 0) {
        const end = rowspan > 0 ? rowspan + start - 1 : allRow.length - start;
        while (start <= end) {
          flag === 'enter' ? addClass(allRow[start], 'hover-row') : removeClass(allRow[start], 'hover-row');
          start++;
        }
      }
    },
    handleCellMouseEnter(event, row) {
      // const tdValue = event.target.innerText;
      const table = this.table;
      const cell = getCell(event);
      if (cell) {
        const column = getColumnByCell(table, cell);
        const hoverState = table.hoverState = {
          cell,
          column,
          row
        };
        table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
        this.$nextTick(() => {
          this.setRowspanTrHoverState(cell);
        });
      }
      const cellChild = event.target.querySelector('.cell');
      const labelChild = event.target.querySelector('.label');
      const labelItem = labelChild || cellChild;

      /**
       * IE 下当 labelItem.getBoundingClientRect().width 为小数时
       * clientWidth 根据实际宽度四舍五入，而 scrollWidth 比 clientWidth 大 1px
       * 故存在内容未溢出而显示 title 的情况
       * 此处暂时不做兼容处理
       * add by yangzhini 2019-05-14
       **/

      if (labelItem.clientWidth <= labelItem.scrollWidth) {
        if (hasClass(cellChild, 'el-tooltip')) {
          const tooltip = this.$refs.tooltip;
          this.tooltipContent = cell.innerText.trim();
          tooltip.referenceElm = cell;
          tooltip.$refs.popper && (tooltip.$refs.popper.style.display = 'none');
          tooltip.doDestroy();
          tooltip.setExpectedState(true);
          this.activateTooltip(tooltip);
        } else if (hasClass(cellChild, 'show-overflow-title')) {
          cell.setAttribute('title', cell.innerText.trim());
        }
      } else if (cell.getAttribute('title')) {
        cell.removeAttribute('title');
      }
    },
    handleCellMouseLeave(event) {
      const tooltip = this.$refs.tooltip;
      if (tooltip) {
        tooltip.setExpectedState(false);
        tooltip.handleClosePopper();
      }
      const cell = getCell(event);
      if (!cell) return;
      const oldHoverState = this.table.hoverState;
      this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
      this.$nextTick(() => {
        this.setRowspanTrHoverState(cell, 'leave');
      });
    },
    /**
     * modified by zhangxiaogang
     * date: 2018-05-09
     * todo: 合并行列的表格hover需要关联变化，故改写此处逻辑
     */
    handleMouseEnter(index) {
      this.store.commit('setHoverRow', index);
    },
    handleMouseLeave() {
      this.store.commit('setHoverRow', null);
    },
    handleContextMenu(event, row) {
      this.handleEvent(event, row, 'contextmenu');
    },
    handleDoubleClick(event, row) {
      this.handleEvent(event, row, 'dblclick');
    },
    handleClick(event, row, $index) {
      if (!this.isRowUnselectable(row, $index)) {
        this.store.commit('setCurrentRow', row);
        this.handleEvent(event, row, 'click');
      }
    },
    isRowUnselectable(row, $index) {
      const radioColumn = this.columns.find(col => col.type === 'radio');
      return radioColumn && radioColumn.selectable && !radioColumn.selectable.call(null, row, $index);
    },
    handleEvent(event, row, name) {
      const table = this.table;
      const cell = getCell(event);
      let column;
      if (cell) {
        column = getColumnByCell(table, cell);
        if (column) {
          table.$emit(`cell-${name}`, row, column, cell, event);
        }
      }
      table.$emit(`row-${name}`, row, event, column);
    },
    handleExpandClick(row) {
      this.store.toggleRowExpanded(row);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=template&id=002dd4ca&
var filter_panelvue_type_template_id_002dd4ca_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"}},[(_vm.multiple)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-table-filter el-popper"},[_c('div',{staticClass:"el-table-filter__content"},[_c('el-checkbox-group',{staticClass:"el-table-filter__checkbox-group",model:{value:(_vm.filteredValue),callback:function ($$v) {_vm.filteredValue=$$v},expression:"filteredValue"}},_vm._l((_vm.filters),function(filter){return _c('el-checkbox',{key:filter.value,attrs:{"label":filter.value}},[_vm._v(" "+_vm._s(filter.text)+" ")])}),1)],1),_c('div',{staticClass:"el-table-filter__bottom"},[_c('button',{class:{ 'is-disabled': _vm.filteredValue.length === 0 },attrs:{"disabled":_vm.filteredValue.length === 0},on:{"click":_vm.handleConfirm}},[_vm._v(" "+_vm._s(_vm.t('el.table.confirmFilter'))+" ")]),_c('button',{on:{"click":_vm.handleReset}},[_vm._v(" "+_vm._s(_vm.t('el.table.resetFilter'))+" ")])])]):_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-table-filter"},[_c('ul',{staticClass:"el-table-filter__list"},[_c('li',{staticClass:"el-table-filter__list-item",class:{ 'is-active': !_vm.filterValue },on:{"click":function($event){return _vm.handleSelect(null)}}},[_vm._v(" "+_vm._s(_vm.t('el.table.clearFilter'))+" ")]),_vm._l((_vm.filters),function(filter){return _c('li',{key:filter.value,staticClass:"el-table-filter__list-item",class:{ 'is-active': _vm.isActive(filter) },attrs:{"label":filter.value},on:{"click":function($event){return _vm.handleSelect(filter.value)}}},[_vm._v(" "+_vm._s(filter.text)+" ")])})],2)])])}
var filter_panelvue_type_template_id_002dd4ca_staticRenderFns = []


// CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=template&id=002dd4ca&

// CONCATENATED MODULE: ./packages/table/src/dropdown.js

var dropdowns = [];
!external_vue_default.a.prototype.$isServer && document.addEventListener('click', function (event) {
  dropdowns.forEach(function (dropdown) {
    var target = event.target;
    if (!dropdown || !dropdown.$el) return;
    if (target === dropdown.$el || dropdown.$el.contains(target)) {
      return;
    }
    dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
  });
});
/* harmony default export */ var src_dropdown = ({
  open(instance) {
    if (instance) {
      dropdowns.push(instance);
    }
  },
  close(instance) {
    var index = dropdowns.indexOf(instance);
    if (index !== -1) {
      dropdowns.splice(instance, 1);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








/* harmony default export */ var filter_panelvue_type_script_lang_js_ = ({
  name: 'ElTableFilterPanel',
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    ElCheckbox: packages_checkbox,
    ElCheckboxGroup: packages_checkbox_group
  },
  mixins: [vue_popper, locale],
  props: {
    placement: {
      type: String,
      default: 'bottom-end'
    },
    visibleArrow: {
      type: Boolean,
      default: true
    }
  },
  customRender() {
    const h = this.$createElement;
    return h("div", {
      "class": 'el-table-filter'
    }, [h("div", {
      "class": 'el-table-filter__content'
    }), h("div", {
      "class": 'el-table-filter__bottom'
    }, [h("button", {
      "on": {
        "click": this.handleConfirm
      }
    }, [this.t('el.table.confirmFilter')]), h("button", {
      "on": {
        "click": this.handleReset
      }
    }, [this.t('el.table.resetFilter')])])]);
  },
  data() {
    return {
      table: null,
      cell: null,
      column: null
    };
  },
  computed: {
    filters() {
      return this.column && this.column.filters;
    },
    filterValue: {
      get() {
        return (this.column.filteredValue || [])[0];
      },
      set(value) {
        if (this.filteredValue) {
          if (typeof value !== 'undefined' && value !== null) {
            this.filteredValue.splice(0, 1, value);
          } else {
            this.filteredValue.splice(0, 1);
          }
        }
      }
    },
    filteredValue: {
      get() {
        if (this.column) {
          return this.column.filteredValue || [];
        }
        return [];
      },
      set(value) {
        if (this.column) {
          this.column.filteredValue = value;
        }
      }
    },
    multiple() {
      if (this.column) {
        return this.column.filterMultiple;
      }
      return true;
    }
  },
  watch: {
    showPopper(val) {
      if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < popup_manager.zIndex) {
        this.popperJS._popper.style.zIndex = popup_manager.nextZIndex();
      }
    }
  },
  mounted() {
    this.popperElm = this.$el;
    this.referenceElm = this.cell.querySelector('.el-table__column-filter-trigger');
    this.table.bodyWrapper.addEventListener('scroll', () => {
      this.updatePopper();
    });
    this.$watch('showPopper', value => {
      if (this.column) this.column.filterOpened = value;
      if (value) {
        src_dropdown.open(this);
      } else {
        src_dropdown.close(this);
      }
    });
  },
  methods: {
    isActive(filter) {
      return filter.value === this.filterValue;
    },
    handleOutsideClick() {
      this.showPopper = false;
    },
    handleConfirm() {
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },
    handleReset() {
      this.filteredValue = [];
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },
    handleSelect(filterValue) {
      this.filterValue = filterValue;
      if (typeof filterValue !== 'undefined' && filterValue !== null) {
        this.confirmFilter(this.filteredValue);
      } else {
        this.confirmFilter([]);
      }
      this.handleOutsideClick();
    },
    confirmFilter(filteredValue) {
      this.table.store.commit('filterChange', {
        column: this.column,
        values: filteredValue
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/table/src/filter-panel.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_filter_panelvue_type_script_lang_js_ = (filter_panelvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/table/src/filter-panel.vue





/* normalize component */

var filter_panel_component = normalizeComponent(
  src_filter_panelvue_type_script_lang_js_,
  filter_panelvue_type_template_id_002dd4ca_render,
  filter_panelvue_type_template_id_002dd4ca_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var filter_panel = (filter_panel_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/selection-panel.vue?vue&type=template&id=a1b429d6&
var selection_panelvue_type_template_id_a1b429d6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"el-table-selection"},[_c('ul',{staticClass:"el-table-selection__list"},_vm._l((_vm.selections),function(selection){return _c('li',{key:selection.value,staticClass:"el-table-selection__list-item",attrs:{"label":selection.value},on:{"click":function($event){return _vm.handleSelect(selection.value)}}},[_vm._v(" "+_vm._s(selection.text)+" ")])}),0)])])}
var selection_panelvue_type_template_id_a1b429d6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/table/src/selection-panel.vue?vue&type=template&id=a1b429d6&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/selection-panel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var selection_panelvue_type_script_lang_js_ = ({
  name: 'ElTableSelectionPanel',
  mixins: [vue_popper],
  props: {
    placement: {
      type: String,
      default: 'bottom-start'
    }
  },
  data() {
    return {
      table: null,
      target: null,
      column: null
    };
  },
  computed: {
    selections() {
      return this.column && this.column.selections;
    }
  },
  watch: {
    showPopper(val) {
      if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < popup_manager.zIndex) {
        this.popperJS._popper.style.zIndex = popup_manager.nextZIndex();
      }
    }
  },
  mounted() {
    this.popperElm = this.$el;
    this.referenceElm = this.target;
    this.table.bodyWrapper.addEventListener('scroll', () => {
      this.updatePopper();
    });
    on(this.referenceElm, 'mouseenter', this.handleMouseEnter);
    on(this.popperElm, 'mouseenter', this.handleMouseEnter);
    on(this.referenceElm, 'mouseleave', this.handleMouseLeave);
    on(this.popperElm, 'mouseleave', this.handleMouseLeave);
  },
  destroyed() {
    off(this.referenceElm, 'mouseenter', this.handleMouseEnter);
    off(this.popperElm, 'mouseenter', this.handleMouseEnter);
    off(this.referenceElm, 'mouseleave', this.handleMouseLeave);
    off(this.popperElm, 'mouseleave', this.handleMouseLeave);
  },
  methods: {
    handleSelect(selectedValue) {
      const selection = this.column.selections.find(selection => selection.value === selectedValue);
      if (selection && selection.onClick) {
        selection.onClick();
      }
      this.showPopper = false;
    },
    handleMouseEnter() {
      clearTimeout(this._timer);
      this.showPopper = true;
    },
    handleMouseLeave() {
      this._timer = setTimeout(() => {
        this.showPopper = false;
      }, 200);
    }
  }
});
// CONCATENATED MODULE: ./packages/table/src/selection-panel.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_selection_panelvue_type_script_lang_js_ = (selection_panelvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/table/src/selection-panel.vue





/* normalize component */

var selection_panel_component = normalizeComponent(
  src_selection_panelvue_type_script_lang_js_,
  selection_panelvue_type_template_id_a1b429d6_render,
  selection_panelvue_type_template_id_a1b429d6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var selection_panel = (selection_panel_component.exports);
// CONCATENATED MODULE: ./packages/table/src/table-header.js








const getAllColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = originColumns => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach(column => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach(column => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};

// function parseToDOM(str) {
//     const div = document.createElement('div');
//     if (typeof str === 'string') {
//         div.innerHTML = str;
//     }
//     return <div />;
// }

/* harmony default export */ var table_header = ({
  name: 'ElTableHeader',
  mixins: [layout_observer],
  render(h) {
    const originColumns = this.store.states.originColumns;
    const columnRows = convertToRows(originColumns, this.columns);

    // 是否拥有多级表头
    const isGroup = columnRows.length > 1;
    if (isGroup) this.$parent.isGroup = true;
    return h("table", {
      "class": 'el-table__header',
      "attrs": {
        "cellspacing": '0',
        "cellpadding": '0',
        "border": '0'
      }
    }, [h("colgroup", [this._l(this.columns, column => h("col", {
      "attrs": {
        "name": column.id
      }
    }))]), h("thead", [this._l(columnRows, (columns, rowIndex) => h("tr", {
      "style": this.getHeaderRowStyle(rowIndex),
      "class": this.getHeaderRowClass(rowIndex)
    }, [this._l(columns, (column, cellIndex) => h("th", {
      "attrs": {
        "colspan": column.colSpan,
        "rowspan": column.rowSpan
      },
      "on": {
        "mousemove": $event => this.handleMouseMove($event, column, cellIndex),
        "mouseout": this.handleMouseOut,
        "mousedown": $event => this.handleMouseDown($event, column),
        "mouseenter": $event => this.handleCellMouseEnter($event, column),
        "click": $event => this.handleHeaderClick($event, column)
      },
      "style": this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
      "class": this.getHeaderCellClass(rowIndex, cellIndex, columns, column)
    }, [h("div", {
      "class": ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName, {
        'show-header-overflow': this.store.table.showHeaderOverflow
      }]
    }, [column.renderHeader ? column.renderHeader.call(this._renderProxy, h, {
      column,
      $index: cellIndex,
      store: this.store,
      _self: this.$parent.$vnode.context
    }) : column.hasSlotHeader() ? column.slotHeader.call(this._renderProxy, h, {
      column,
      $index: cellIndex,
      store: this.store,
      _self: this.$parent.$vnode.context
    }) : column.ishtml ? h('span', {
      domProps: {
        innerHTML: column.label
      }
    }) : (column.sortable || column.filterable) && this.store.table.showHeaderOverflow ? h("span", {
      "class": ['has-icon-right', {
        'double-icon': column.sortable && column.filterable
      }]
    }, [column.label]) : h("div", {
      "class": 'label'
    }, [column.label]), column.sortable ? h("span", {
      "class": 'caret-wrapper',
      "on": {
        "click": $event => this.handleSortClick($event, column)
      }
    }, [h("i", {
      "class": 'sort-caret ascending',
      "on": {
        "click": $event => this.handleSortClick($event, column, 'ascending')
      }
    }), h("i", {
      "class": 'sort-caret descending',
      "on": {
        "click": $event => this.handleSortClick($event, column, 'descending')
      }
    })]) : '', column.filterable ? h("span", {
      "class": 'el-table__column-filter-trigger',
      "on": {
        "click": $event => this.handleFilterClick($event, column)
      }
    }, [h("i", {
      "class": ['h-icon-filter', column.filteredValue && column.filteredValue.length > 0 ? 'h-icon-filter_f' : '', column.filterOpened ? 'filter-opened' : '']
    })]) : '', column.selections ? h("span", {
      "class": 'el-table__column-selection-icon',
      "on": {
        "mouseenter": $event => this.handleSelectionMouseEnter($event, column)
      }
    }, [h("i", {
      "class": 'h-icon-angle_down_sm'
    })]) : ''])]))]))])]);
  },
  props: {
    fixed: String,
    store: {
      required: true
    },
    defaultSort: {
      type: Object,
      default() {
        return {
          prop: '',
          order: ''
        };
      }
    }
  },
  components: {
    ElCheckbox: packages_checkbox,
    ElTag: packages_tag
  },
  computed: {
    table() {
      return this.$parent;
    },
    isAllSelected() {
      return this.store.states.isAllSelected;
    },
    columnsCount() {
      return this.store.states.columns.length;
    },
    leftFixedLeafCount() {
      return this.store.states.fixedLeafColumns.length;
    },
    rightFixedLeafCount() {
      return this.store.states.rightFixedLeafColumns.length;
    },
    columns() {
      return this.store.states.columns;
    }
  },
  created() {
    this.filterPanels = {};
  },
  mounted() {
    if (this.defaultSort.prop) {
      const states = this.store.states;
      states.sortProp = this.defaultSort.prop;
      states.sortOrder = this.defaultSort.order || 'ascending';
      this.$nextTick(() => {
        for (let i = 0, length = this.columns.length; i < length; i++) {
          const column = this.columns[i];
          if (column.property === states.sortProp) {
            column.order = states.sortOrder;
            states.sortingColumn = column;
            break;
          }
        }
        if (states.sortingColumn) {
          this.store.commit('changeSortCondition');
        }
      });
    }
  },
  beforeDestroy() {
    const panels = this.filterPanels;
    for (const prop in panels) {
      if (hasOwn(panels, prop) && panels[prop]) {
        panels[prop].$destroy(true);
      }
    }
    if (this.selectionPanel) {
      this.selectionPanel.$destroy(true);
    }
  },
  methods: {
    isCellHidden(index, columns) {
      if (this.fixed === true || this.fixed === 'left') {
        return index >= this.leftFixedLeafCount;
      } else if (this.fixed === 'right') {
        let before = 0;
        for (let i = 0; i < index; i++) {
          before += columns[i].colSpan;
        }
        return before < this.columnsCount - this.rightFixedLeafCount;
      } else {
        return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
      }
    },
    getHeaderRowStyle(rowIndex) {
      const headerRowStyle = this.table.headerRowStyle;
      if (typeof headerRowStyle === 'function') {
        return headerRowStyle({
          rowIndex
        });
      }
      return headerRowStyle;
    },
    getHeaderRowClass(rowIndex) {
      const classes = [];
      const headerRowClassName = this.table.headerRowClassName;
      if (typeof headerRowClassName === 'string') {
        classes.push(headerRowClassName);
      } else if (typeof headerRowClassName === 'function') {
        classes.push(headerRowClassName({
          rowIndex
        }));
      }
      return classes.join(' ');
    },
    getHeaderCellStyle(rowIndex, columnIndex, row, column) {
      const headerCellStyle = this.table.headerCellStyle;
      if (typeof headerCellStyle === 'function') {
        return headerCellStyle({
          rowIndex,
          columnIndex,
          row,
          column
        });
      }
      return headerCellStyle;
    },
    getHeaderCellClass(rowIndex, columnIndex, row, column) {
      const classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];

      // if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
      //   classes.push('is-hidden');
      // }

      if (!column.children) {
        classes.push('is-leaf');
      }
      if (column.sortable) {
        classes.push('is-sortable');
      }
      if (column.filterable) {
        classes.push('is-filterable');
      }
      const headerCellClassName = this.table.headerCellClassName;
      if (typeof headerCellClassName === 'string') {
        classes.push(headerCellClassName);
      } else if (typeof headerCellClassName === 'function') {
        classes.push(headerCellClassName({
          rowIndex,
          columnIndex,
          row,
          column
        }));
      }
      return classes.join(' ');
    },
    toggleAllSelection() {
      this.store.commit('toggleAllSelection');
    },
    handleFilterClick(event, column) {
      event.stopPropagation();
      const target = event.target;
      let cell = target;
      while (cell.tagName !== 'TH') {
        cell = cell.parentNode;
      }
      const table = this.$parent;
      let filterPanel = this.filterPanels[column.id];
      if (filterPanel && column.filterOpened) {
        filterPanel.showPopper = false;
        return;
      }
      if (!filterPanel) {
        filterPanel = new external_vue_default.a(filter_panel);
        this.filterPanels[column.id] = filterPanel;
        if (column.filterPlacement) {
          filterPanel.placement = column.filterPlacement;
        }
        filterPanel.table = table;
        filterPanel.cell = cell;
        filterPanel.column = column;
        !this.$isServer && filterPanel.$mount(document.createElement('div'));
      }
      this.closeAllFilterPanel();
      setTimeout(() => {
        filterPanel.showPopper = true;
      }, 16);
    },
    closeAllFilterPanel() {
      Object.values(this.filterPanels).forEach(panel => {
        panel.showPopper = false;
      });
    },
    handleSelectionMouseEnter(event, column) {
      event.stopPropagation();
      const target = event.target;
      const table = this.$parent;
      let selectionPanel = this.selectionPanel;
      if (!selectionPanel) {
        selectionPanel = new external_vue_default.a(selection_panel);
        this.selectionPanel = selectionPanel;
        selectionPanel.table = table;
        selectionPanel.target = target;
        selectionPanel.column = column;
        !this.$isServer && selectionPanel.$mount(document.createElement('div'));
      }
      setTimeout(() => {
        selectionPanel.showPopper = true;
      }, 16);
    },
    handleHeaderClick(event, column) {
      if (column.sortable) {
        this.handleSortClick(event, column);
      } else if (column.filters) {
        this.handleFilterClick(event, column);
      }
      this.$parent.$emit('header-click', column, event);
    },
    handleMouseDown(event, column) {
      if (this.$isServer) return;
      if (column.children && column.children.length > 0) return;
      /* istanbul ignore if */
      if (this.draggingColumn) {
        this.dragging = true;
        this.$parent.resizeProxyVisible = true;
        const table = this.$parent;
        const tableEl = table.$el;
        const tableLeft = tableEl.getBoundingClientRect().left;
        const columnEl = this.$el.querySelector(`th.${column.id}`);
        const columnRect = columnEl.getBoundingClientRect();
        const minLeft = columnRect.left - tableLeft + 30;
        addClass(columnEl, 'noclick');
        this.dragState = {
          startMouseLeft: event.clientX,
          startLeft: columnRect.right - tableLeft,
          startColumnLeft: columnRect.left - tableLeft,
          tableLeft
        };
        const resizeProxy = table.$refs.resizeProxy;
        resizeProxy.style.left = this.dragState.startLeft + 'px';
        document.onselectstart = function () {
          return false;
        };
        document.ondragstart = function () {
          return false;
        };
        const handleMouseMove = event => {
          // 直接使用tableEl.getBoundingClientRect().right，会导致边框线会被看不见。表格左右有1px边框，线本身有1px,为了明显一点，右侧留了1px。总共4px
          const maxTableRight = tableEl.getBoundingClientRect().right - 4;
          const deltaLeft = Math.min(event.clientX, maxTableRight) - this.dragState.startMouseLeft;
          const proxyLeft = this.dragState.startLeft + deltaLeft;
          resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
        };
        const handleMouseUp = () => {
          if (this.dragging) {
            const {
              startColumnLeft,
              startLeft
            } = this.dragState;
            const finalLeft = parseInt(resizeProxy.style.left, 10);
            let columnWidth = finalLeft - startColumnLeft;
            if (column.minWidth && columnWidth < column.minWidth) {
              columnWidth = column.minWidth;
            }
            column.width = column.realWidth = columnWidth;
            table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);
            this.store.scheduleLayout(true);
            document.body.style.cursor = '';
            this.dragging = false;
            this.draggingColumn = null;
            this.dragState = {};
            table.resizeProxyVisible = false;
          }
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.onselectstart = null;
          document.ondragstart = null;
          setTimeout(function () {
            removeClass(columnEl, 'noclick');
          }, 0);
        };
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      }
    },
    handleMouseMove(event, column, cellIndex) {
      if (column.children && column.children.length > 0) return;
      let target = event.target;
      while (target && target.tagName !== 'TH') {
        target = target.parentNode;
      }
      // 最后一列不可拖拽
      if (cellIndex === this.columns.length - 1) return;
      if (!column || !column.resizable) return;
      if (!this.dragging) {
        const rect = target.getBoundingClientRect();
        if (rect.width > 12 && rect.right - event.pageX < 8) {
          target.style.cursor = 'col-resize';
          this.draggingColumn = column;
        } else if (!this.dragging) {
          target.style.cursor = '';
          this.draggingColumn = null;
        }
      }
    },
    handleMouseOut() {
      if (this.$isServer) return;
      document.body.style.cursor = '';
    },
    /**
     * 当showHeaderOverflow为true时，为header设置title
     *  add by yangzhini 2018-08-03
     **/
    handleCellMouseEnter(event, column) {
      // const tdValue = event.target.innerText;

      let cell = event.target;
      while (cell && cell.tagName.toUpperCase() !== 'HTML') {
        if (cell.tagName.toUpperCase() === 'TH') {
          break;
        }
        cell = cell.parentNode;
      }
      const cellChild = event.target.querySelector('.cell');
      const labelChild = event.target.querySelector('.label');
      let labelItem = labelChild || cellChild;
      if (column.sortable || column.filterable) {
        labelItem = cellChild.querySelector('.has-icon-right');
      }

      /**
       * IE 下当 labelItem.getBoundingClientRect().width 为小数时
       * clientWidth 根据实际宽度四舍五入，而 scrollWidth 比 clientWidth 大 1px
       * 故存在内容未溢出而显示 title 的情况
       * 此处暂时不做兼容处理
       * add by yangzhini 2019-05-14
       **/

      if (labelItem.clientWidth <= labelItem.scrollWidth) {
        if (hasClass(cellChild, 'show-header-overflow')) {
          cell.setAttribute('title', cell.innerText.trim());
        }
      } else if (cell.getAttribute('title')) {
        cell.removeAttribute('title');
      }
    },
    toggleOrder(order) {
      return !order ? 'ascending' : order === 'ascending' ? 'descending' : null;
    },
    handleSortClick(event, column, givenOrder) {
      event.stopPropagation();
      const order = givenOrder || this.toggleOrder(column.order);
      let target = event.target;
      while (target && target.tagName !== 'TH') {
        target = target.parentNode;
      }
      if (target && target.tagName === 'TH') {
        if (hasClass(target, 'noclick')) {
          removeClass(target, 'noclick');
          return;
        }
      }
      if (!column.sortable) return;
      const states = this.store.states;
      let sortProp = states.sortProp;
      let sortOrder;
      const sortingColumn = states.sortingColumn;
      if (sortingColumn !== column) {
        if (sortingColumn) {
          sortingColumn.order = null;
        }
        states.sortingColumn = column;
        sortProp = column.property;
      }
      if (!order) {
        sortOrder = column.order = null;
      } else {
        sortOrder = column.order = order;
      }
      states.sortProp = sortProp;
      states.sortOrder = sortOrder;
      this.store.commit('changeSortCondition');
    }
  },
  data() {
    return {
      draggingColumn: null,
      dragging: false,
      dragState: {}
    };
  }
});
// CONCATENATED MODULE: ./packages/table/src/table-footer.js

/* harmony default export */ var table_footer = ({
  name: 'ElTableFooter',
  mixins: [layout_observer],
  render() {
    const h = arguments[0];
    const sums = [];
    this.columns.forEach((column, index) => {
      if (index === 0) {
        sums[index] = this.sumText;
        return;
      }
      const values = this.store.states.data.map(item => Number(item[column.property]));
      const precisions = [];
      let notNumber = true;
      values.forEach(value => {
        if (!isNaN(value)) {
          notNumber = false;
          const decimal = ('' + value).split('.')[1];
          precisions.push(decimal ? decimal.length : 0);
        }
      });
      const precision = Math.max.apply(null, precisions);
      if (!notNumber) {
        sums[index] = values.reduce((prev, curr) => {
          const value = Number(curr);
          if (!isNaN(value)) {
            return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
          } else {
            return prev;
          }
        }, 0);
      } else {
        sums[index] = '';
      }
    });
    return h("table", {
      "class": 'el-table__footer',
      "attrs": {
        "cellspacing": '0',
        "cellpadding": '0',
        "border": '0'
      }
    }, [h("colgroup", [this._l(this.columns, column => h("col", {
      "attrs": {
        "name": column.id
      }
    }))]), h("tbody", [h("tr", [this._l(this.columns, (column, cellIndex) => h("td", {
      "attrs": {
        "colspan": column.colSpan,
        "rowspan": column.rowSpan
      },
      "class": [column.id, column.headerAlign, column.className || '', !column.children ? 'is-leaf' : '', column.labelClassName]
    }, [h("div", {
      "class": ['cell', column.labelClassName]
    }, [this.summaryMethod ? this.summaryMethod({
      columns: this.columns,
      data: this.store.states.data
    })[cellIndex] : sums[cellIndex]])]))])])]);
  },
  props: {
    fixed: String,
    store: {
      required: true
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default() {
        return {
          prop: '',
          order: ''
        };
      }
    }
  },
  computed: {
    table() {
      return this.$parent;
    },
    isAllSelected() {
      return this.store.states.isAllSelected;
    },
    columnsCount() {
      return this.store.states.columns.length;
    },
    // leftFixedLeafCount() {
    //   return this.store.states.fixedLeafColumns.length;
    // },

    // rightFixedLeafCount() {
    //   return this.store.states.rightFixedLeafColumns.length;
    // },

    columns() {
      if (this.fixed === true || this.fixed === 'left') {
        return this.store.states.fixedLeafColumns;
      } else if (this.fixed === 'right') {
        return this.store.states.rightFixedLeafColumns;
      }
      return this.store.states.columns;
    }
  },
  methods: {
    // isCellHidden(index, columns) {
    //   if (this.fixed === true || this.fixed === 'left') {
    //     return index >= this.leftFixedLeafCount;
    //   } else if (this.fixed === 'right') {
    //     let before = 0;
    //     for (let i = 0; i < index; i++) {
    //       before += columns[i].colSpan;
    //     }
    //     return before < this.columnsCount - this.rightFixedLeafCount;
    //   } else {
    //     return (
    //       index < this.leftFixedLeafCount ||
    //       index >= this.columnsCount - this.rightFixedLeafCount
    //     );
    //   }
    // }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/table/src/table.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

// import ElCheckbox from 'hui/packages/checkbox';











const tableIdSeed = 1;
/* harmony default export */ var tablevue_type_script_lang_js_ = ({
  name: 'ElTable',
  components: {
    TableHeader: table_header,
    TableFooter: table_footer,
    TableBody: table_body,
    // ElCheckbox,
    ElScrollbar: scrollbar
  },
  mixins: [locale],
  props: {
    data: {
      type: Array,
      default() {
        return [];
      }
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: null
    },
    maxHeight: {
      type: [String, Number],
      default: null
    },
    fit: {
      type: Boolean,
      default: true
    },
    stripe: {
      type: Boolean,
      default: null
    },
    border: {
      type: Boolean,
      default: null
    },
    rowKey: {
      type: [String, Function],
      default: null
    },
    context: {
      type: null,
      default: null
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    showSummary: {
      type: Boolean,
      default: null
    },
    sumText: {
      type: String,
      default: null
    },
    summaryMethod: {
      type: Function,
      default: null
    },
    rowClassName: {
      type: [String, Function],
      default: null
    },
    rowStyle: {
      type: [Object, Function],
      default: null
    },
    cellClassName: {
      type: [String, Function],
      default: null
    },
    cellStyle: {
      type: [Object, Function],
      default: null
    },
    headerRowClassName: {
      type: [String, Function],
      default: null
    },
    headerRowStyle: {
      type: [Object, Function],
      default: null
    },
    headerCellClassName: {
      type: [String, Function],
      default: null
    },
    headerCellStyle: {
      type: [Object, Function],
      default: null
    },
    highlightCurrentRow: {
      type: Boolean,
      default: null
    },
    currentRowKey: {
      type: [String, Number],
      default: null
    },
    emptyText: {
      type: String,
      default: null
    },
    expandRowKeys: {
      type: Array,
      default: null
    },
    defaultExpandAll: {
      type: Boolean,
      default: null
    },
    defaultSort: {
      type: Object,
      default() {
        return {
          prop: '',
          order: ''
        };
      }
    },
    // 设置默认的排序规则 add by yangzhini 2019-04-18
    defaultSortMethod: {
      type: Function,
      default: null
    },
    alwaysShowBar: {
      type: Boolean,
      default: null
    },
    // 始终显示滚动条还是鼠标移入才显示

    forceScroll: {
      // 在不指定高度和最大高度时是否强制美化滚动条，如果是，则需要指定表格外部容器高度
      type: [Boolean, String],
      default: false
    },
    showLoading: {
      // 分页请求时是否显示加载中
      type: Boolean,
      default: false
    },
    spanMethod: {
      type: Function,
      default: null
    },
    showHeaderOverflow: {
      // 当header中内容过长被隐藏时显示title add by yangzhini 2018-08-02
      type: Boolean,
      default: true
    },
    showOverflowTooltip: {
      type: Boolean,
      default: null
    },
    showOverflowTitle: {
      // 默认单元格内容溢出时隐藏，展示title modify by yangzhini 2019-03-21
      type: Boolean,
      default: true
    },
    // 设置是否开启虚拟滚动 add by yangzhini 2019-09-05
    enableVirtualScroll: {
      type: Boolean,
      default: false
    },
    // 是否显示全选按钮
    showHeaderSelection: {
      type: Boolean,
      default: true
    }
  },
  data() {
    const store = new table_store(this, {
      rowKey: this.rowKey,
      defaultExpandAll: this.defaultExpandAll,
      defaultSortMethod: this.defaultSortMethod
    });
    const layout = new table_layout({
      store,
      table: this,
      fit: this.fit,
      showHeader: this.showHeader
    });
    return {
      store,
      layout,
      renderExpanded: null,
      resizeProxyVisible: false,
      // isShowLoading: false, 暂时没用了，去掉 2021/7/27
      /* 外部传入的force-scroll原本是boolean型，
       * 现改为boolean和string均可，
       * 那么以前的force-scroll直接写个属性名的方式声明布尔型会导致传入undefined
       * 为了兼容已有项目，这里声明内部变量予以拦截
       * */
      niceScroll: true,
      /**
       * 移动到el-table__fixed也出现滚动条，为了不影响alwaysShowBar；新增一个参数控制
       */
      isFixBarScrollShow: false,
      // fixedShadowHeight: '',
      resizeState: {
        width: null,
        height: null
      },
      // 是否拥有多级表头
      isGroup: false,
      scrollTop: 0,
      bodyWrapperHeight: 1080
    };
  },
  computed: {
    bodyWrapper() {
      return this.$refs.bodyWrapper;
    },
    shouldUpdateHeight() {
      return this.height || this.maxHeight || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
    },
    selection() {
      return this.store.states.selection;
    },
    columns() {
      return this.store.states.columns;
    },
    tableData() {
      return this.store.states.data;
    },
    fixedColumns() {
      return this.store.states.fixedColumns || [];
    },
    rightFixedColumns() {
      return this.store.states.rightFixedColumns;
    },
    wrapStyle() {
      let style = [];
      if (this.maxHeight) {
        let _maxHeight = this.maxHeight;
        if (typeof _maxHeight === 'string') {
          _maxHeight = +_maxHeight.replace('px', '');
        }
        style = [{
          'max-height': (this.showHeader ? _maxHeight - this.layout.headerHeight - this.layout.footerHeight : _maxHeight - this.layout.footerHeight) + 'px'
        }];
      }
      return style;
    },
    bodyHeight() {
      let style = {};
      if (this.maxHeight) {
        let _maxHeight = this.maxHeight;
        if (typeof _maxHeight === 'string') {
          _maxHeight = +_maxHeight.replace('px', '');
        }
        style = {
          'max-height': (this.showHeader ? _maxHeight - this.layout.headerHeight - this.layout.footerHeight : _maxHeight - this.layout.footerHeight) + 'px'
        };
        // this.setScrollStyle();
      } else if (this.niceScroll && this.niceScroll !== 'horizontal') {
        // 兼容 IE 下纵向无法滚动的问题
        style = {
          'flex-basis': '100%',
          'min-height': '0'
        };
      } else {
        style = {
          height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
        };
      }
      return style;
    },
    bodyWidth() {
      const {
        bodyWidth
      } = this.layout;
      return bodyWidth ? bodyWidth + 'px' : '';
    },
    fixedWidth() {
      const {
        fixedWidth
      } = this.layout;
      return fixedWidth ? fixedWidth + 'px' : '';
    },
    rightFixedWidth() {
      const {
        rightFixedWidth
      } = this.layout;
      return rightFixedWidth ? rightFixedWidth + 'px' : '';
    },
    fixedBodyHeight() {
      let style = {};
      if (this.height || this.niceScroll) {
        style = {
          height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
        };
      } else if (this.maxHeight) {
        let _maxHeight = this.maxHeight;
        if (typeof _maxHeight === 'string') {
          _maxHeight = +_maxHeight.replace('px', '');
        }
        if (this.showHeader) {
          _maxHeight -= this.layout.headerHeight;
        }
        _maxHeight -= this.layout.footerHeight;
        style = {
          'max-height': _maxHeight + 'px'
        };
      }
      style.top = this.layout.headerHeight + 'px';
      return style;
    },
    fixedHeight() {
      let style = {};
      if (this.maxHeight) {
        style = {
          bottom: 0
        };
      } else {
        style = {
          height: this.layout.tableHeight ? this.layout.tableHeight + 'px' : ''
        };
      }
      return style;
    },
    fixedShadowHeight() {
      const {
        tableHeight
      } = this.layout;
      return tableHeight ? tableHeight + 'px' : '';
    },
    isVirtualScroll() {
      return this.enableVirtualScroll && this.niceScroll !== 'horizontal';
    },
    isShowEmptyText() {
      const empty = !this.showLoading && (!this.data || this.data.length === 0 || !this.tableData || this.tableData.length === 0);
      empty && this.fixEmptyScrollViewHeight();
      return empty;
    }
  },
  watch: {
    height: {
      immediate: true,
      handler(value) {
        this.layout.setHeight(value);
        this.setScrollStyle();
      }
    },
    maxHeight: {
      immediate: true,
      handler(value) {
        this.layout.setMaxHeight(value);
        this.setScrollStyle();
      }
    },
    currentRowKey: {
      immediate: true,
      handler(value) {
        if (!this.rowKey) return;
        this.$nextTick(() => {
          this.store.setCurrentRowKey(value);
        });
      }
    },
    data: {
      immediate: true,
      handler(val = []) {
        this.store.commit('setData', val);
        if (this.$ready) {
          this.doLayout();
          this.$refs.tableScrollbar && this.$refs.tableScrollbar.update();
        }
      }
    },
    expandRowKeys: {
      immediate: true,
      handler(newVal) {
        if (newVal) {
          this.store.setExpandRowKeys(newVal);
        }
      }
    },
    isShowEmptyText(v) {
      v && this.fixEmptyScrollViewHeight();
    },
    columns(c, p) {
      /**
       * modify by zhangxiaogang
       * 2018-06-07
       * info: 当列宽自适应时，且列个数由少到多会出现宽度分布不均匀的问题，
       *    此情况下将realWidth重置为初始化状态即可
       */
      if (p.length > 0 && p.length !== c.length) {
        this.columns.forEach(column => {
          column.realWidth = column.width || column.minWidth;
        });
      }
    }
  },
  created() {
    this.tableId = 'el-table_' + tableIdSeed + '_';
    // this.debouncedLayout = debounce(50, () => this.doLayout());
    this.debouncedLayout = debounce_default()(50, debouncedLayout => this.doLayout(debouncedLayout));
    this.niceScroll = this.forceScroll;
    if (this.niceScroll === '') {
      this.niceScroll = true;
    }
  },
  destroyed() {
    if (this.resizeListener) {
      removeResizeListener(this.$el, this.resizeListener);
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.bindEvents();
      this.doLayout(); // 在 nextTick 调用是为了修复 IE 下无法获取 bodyWidth 的问题   add by yangzhini  2020-05-11
    });
    this.store.updateColumns();
    this.resizeState = {
      width: this.$el.offsetWidth,
      height: this.$el.offsetHeight
    };

    // init filters
    this.columns.forEach(column => {
      if (column.filteredValue && column.filteredValue.length) {
        this.store.commit('filterChange', {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    this.$ready = true;
    this.setScrollStyle();
  },
  methods: {
    setCurrentRow(row) {
      this.store.commit('setCurrentRow', row);
    },
    toggleRowSelection(row, selected, emitChange = true) {
      this.store.toggleRowSelection(row, selected, emitChange);
      this.store.updateAllSelected();
    },
    toggleRowExpanded(row, expanded) {
      this.store.toggleRowExpanded(row, expanded);
    },
    clearSelection() {
      this.store.clearSelection();
    },
    handleMouseLeave() {
      this.store.commit('setHoverRow', null);
      if (this.hoverState) this.hoverState = null;
    },
    // updateScrollY() {
    //   this.layout.updateScrollY();
    // },

    /**
     * scrollbar的横向滚动事件
     * add by zhangxiaogang 2017-09-27
     * @param {Object} s {scrollLeft: wrap.scrollLeft, scrollTop: wrap.scrollTop} 滚动条上下边距距离
     */
    onScrollingX(s) {
      // 触发用户传入的滚动和横向滚动事件 (若有)
      const {
        headerWrapper,
        footerWrapper
      } = this.$refs;
      const {
        scrollLeft,
        percentX
      } = s;
      if (headerWrapper) headerWrapper.scrollLeft = s.scrollLeft;
      if (footerWrapper) footerWrapper.scrollLeft = s.scrollLeft;
      this.$emit('on-scrolling-x', scrollLeft, percentX);
      this.$emit('on-scrolling', s);
    },
    /**
     * scrollbar的纵向滚动事件
     * add by zhangxiaogang 2017-09-27
     * @param {Object} s {scrollLeft: wrap.scrollLeft, scrollTop: wrap.scrollTop} 滚动条上下边距距离
     */
    onScrollingY(s) {
      // 触发用户传入的滚动和纵向滚动事件 (若有)
      const {
        fixedBodyWrapper,
        rightFixedBodyWrapper
      } = this.$refs;
      const {
        scrollTop,
        percentY
      } = s;
      if (this.isVirtualScroll) {
        this.scrollTop = scrollTop;
         false && false;
      }
      if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = s.scrollTop;
      if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = s.scrollTop;
      this.$emit('on-scrolling-y', scrollTop, percentY);
      this.$emit('on-scrolling', s);
    },
    bindEvents() {
      const {
        fixedBodyWrapper,
        rightFixedBodyWrapper
      } = this.$refs;
      /**
       * modify by yangzhini
       * 2019-02-13
       * info: 修复固定列区域鼠标上下滚动无效的问题
       */
      const scrollFixedBodyWrapper = event => {
        const data = normalizeWheel(event);
        const wrap = this.$refs.tableScrollbar.$refs.wrap;
        if (Math.abs(data.spinY) > 0) {
          const currentScrollTop = wrap.scrollTop;
          if (data.pixelY < 0 && currentScrollTop !== 0) {
            event.preventDefault();
          }
          if (data.pixelY > 0 && wrap.scrollHeight - wrap.clientHeight > currentScrollTop) {
            event.preventDefault();
          }
          wrap.scrollTop += Math.ceil(data.pixelY / 5);
        } else {
          wrap.scrollLeft += Math.ceil(data.pixelX / 5);
        }
      };
      if (fixedBodyWrapper) {
        mousewheel(fixedBodyWrapper, throttle_default()(16, scrollFixedBodyWrapper));
      }
      if (rightFixedBodyWrapper) {
        mousewheel(rightFixedBodyWrapper, throttle_default()(16, scrollFixedBodyWrapper));
      }
      if (this.fit) {
        addResizeListener(this.$el, this.resizeListener);
      }
    },
    resizeListener() {
      if (!this.$ready) return;
      let shouldUpdateLayout = false;
      const el = this.$el;
      const {
        width: oldWidth,
        height: oldHeight
      } = this.resizeState;
      const width = el.offsetWidth;
      if (oldWidth !== width) {
        shouldUpdateLayout = true;
      }
      const height = el.offsetHeight;
      if ((this.height || this.shouldUpdateHeight) && oldHeight !== height) {
        shouldUpdateLayout = true;
      }
      if (shouldUpdateLayout) {
        this.resizeState.width = width;
        this.resizeState.height = height;
        this.doLayout();
      }
    },
    doLayout(dragResize) {
      this.layout.update(dragResize);
      if (this.shouldUpdateHeight) {
        this.layout.updateHeight();
      }
      if (this.isVirtualScroll || this.store.states.isComplex) {
        this.$nextTick(() => {
          // 虚拟滚动：获取可视区域高度并更新行高数据
          this.bodyWrapperHeight = this.$refs.bodyWrapper ? this.$refs.bodyWrapper.clientHeight : 1080;
          this.store.getTableRowsHeight();
        });
      }
    },
    /**
     * 获取表格当前渲染的数据
     * add by zhangxiaogang 2017-11-28
     * @param {Number} index 行号，从0开始，不传则获取全部数据
     */
    getData(index) {
      const d = this.data;
      if (typeof index === 'undefined' || isNaN(index)) {
        return d;
      } else if (index > d.length - 1) {
        // 大于数组长度则倒序查找
        const l = d.length - 1;
        const i = index % l;
        return d[l - i];
      } else {
        return d[index];
      }
    },
    /**
     * 更新表格指定行的数据，index指定起始行，再根据data长度决定更新哪些行
     * add by zhangxiaogang 2017-11-28
     * @param {Array, Object} data 要更新的数据，可以是数组也可以是对象，数组则表示更新多行，对象则表示只更新一行
     * @param {Number} index 要更新的起始行号，从0开始
     */
    setData(data, index = 0) {
      if (!Array.isArray(data) && {}.toString.call(data) !== '[object Object]') {
        throw new Error('table func setDate first arguments type must be Array or Object');
      }
      if ({}.toString.call(data) === '[object Object]') {
        data = [data];
      }
      const d = this.data;
      const l = d.length - 1;
      if (isNaN(index)) {
        index = 0;
      } else if (index > l) {
        // 大于数组长度则倒序查找
        const i = index % l;
        index = l - i;
      }
      d.splice(index, data.length, ...data);
    },
    /**
     * 处理多场景下的美化滚动条
     */
    setScrollStyle() {
      // 指定了max-height时滚动条容器对应加上max-height
      this.$nextTick(() => {
        const scrollWrap = this.$el.querySelector('.el-table-scrollbar__wrap');
        if (!scrollWrap) return;
        /**
         * 没有指定高度也无最大高度，让表格自适应外部容器高度且内容超出时美化滚动条
         * zhangxiaogang  2017-11-7
         */
        if (!this.height && !this.maxHeight && this.niceScroll) {
          // 仅横向滚动，纵向自适应无滚动
          if (this.niceScroll === 'horizontal') {
            const $tableTixed = this.$el.querySelector('.el-table__fixed');
            const $tableTixedRight = this.$el.querySelector('.el-table__fixed-right');
            if ($tableTixed) {
              $tableTixed.style.overflow = 'hidden';
            }
            if ($tableTixedRight) {
              $tableTixedRight.style.overflow = 'hidden';
            }
            return;
          }
          this.$el.style.height = '100%';
          // 修复在chrome下能滚动却不显示滚动条的问题
          scrollWrap.style.overflow = 'hidden';
          setTimeout(() => {
            scrollWrap.style.overflow = 'visible';
          }, 0);
        }
      });
    },
    fixEmptyScrollViewHeight() {
      this.$nextTick(() => {
        const scrollView = this.$el.querySelector('.el-table-scrollbar__view');
        if (scrollView) {
          scrollView.style.height = '100%';
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/table/src/table.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tablevue_type_script_lang_js_ = (tablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/table/src/table.vue





/* normalize component */

var table_component = normalizeComponent(
  src_tablevue_type_script_lang_js_,
  tablevue_type_template_id_3d789884_render,
  tablevue_type_template_id_3d789884_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_table = (table_component.exports);
// CONCATENATED MODULE: ./packages/table/index.js


/* istanbul ignore next */
src_table.install = function (Vue) {
  Vue.component(src_table.name, src_table);
};
/* harmony default export */ var packages_table = (src_table);
// CONCATENATED MODULE: ./packages/table/src/table-column.js





let columnIdSeed = 1;
const defaults = {
  default: {
    order: ''
  },
  selection: {
    width: 40,
    minWidth: 40,
    realWidth: 40,
    order: '',
    className: 'el-table-column--selection'
  },
  radio: {
    width: 40,
    minWidth: 40,
    realWidth: 40,
    order: '',
    className: 'el-table-column--radio'
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  }
};
const forced = {
  selection: {
    renderHeader: function (h, {
      store
    }) {
      return store.table.showHeaderSelection ? h("el-checkbox", {
        "nativeOn": {
          "click": store.states.data && store.states.data.length === 0 || store.states.isAllDisabled ? () => {} : this.toggleAllSelection
        },
        "attrs": {
          "value": store.states.isAllSelected,
          "indeterminate": !store.states.isAllSelected && store.states.selection.length > 0,
          "disabled": store.states.data && store.states.data.length === 0 || store.states.isAllDisabled
        }
      }) : null;
    },
    renderCell: function (h, {
      row,
      column,
      store,
      $index
    }) {
      return h("el-checkbox", {
        "nativeOn": {
          "click": event => event.stopPropagation()
        },
        "attrs": {
          "value": store.isSelected(row),
          "disabled": column.selectable ? !column.selectable.call(null, row, $index) : false
        },
        "on": {
          "input": () => {
            store.commit('rowSelectedChanged', row);
          }
        }
      });
    },
    sortable: false,
    resizable: false
  },
  radio: {
    renderHeader: function () {
      return '';
    },
    renderCell: function (h, {
      row,
      column,
      store,
      $index
    }) {
      return h("el-radio", {
        "nativeOn": {
          "click": event => event.stopPropagation()
        },
        "attrs": {
          "value": store.states.currentRow,
          "disabled": column.selectable ? !column.selectable.call(null, row, $index) : false,
          "label": row
        },
        "on": {
          "input": () => {
            store.commit('setCurrentRow', row);
          }
        }
      }, [h("span")]);
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader: function (h, {
      column
    }) {
      return column.label || '#';
    },
    renderCell: function (h, {
      $index
    }) {
      return h("span", [$index + 1]);
    },
    sortable: false
  },
  expand: {
    renderHeader: function () {
      return '';
    },
    renderCell: function (h, {
      row,
      store
    }, proxy, allowExpand) {
      if (!allowExpand) return;
      const expanded = store.states.expandRows.indexOf(row) > -1;
      return h("div", {
        "class": 'el-table__expand-icon ' + (expanded ? 'el-table__expand-icon--expanded' : ''),
        "on": {
          "click": () => proxy.handleExpandClick(row)
        }
      }, [h("i", {
        "class": 'el-icon h-icon-angle_right_sm'
      })]);
    },
    sortable: false,
    resizable: false,
    className: 'el-table__expand-column'
  }
};
const getDefaultColumn = function (type, options) {
  const column = {};
  merge(column, defaults[type || 'default']);
  for (const name in options) {
    if (hasOwn(options, name)) {
      const value = options[name];
      if (typeof value !== 'undefined') {
        column[name] = value;
      }
    }
  }
  if (type === 'selection' && options.selections) {
    column.width = 64;
    column.minWidth = 64;
    column.realWidth = 64;
  }
  if (!column.minWidth) {
    column.minWidth = 80;
  }
  column.realWidth = column.width || column.minWidth;
  return column;
};
const DEFAULT_RENDER_CELL = function (h, {
  row,
  column
}) {
  const property = column.property;
  const value = property && getPropByPath(row, property).v;
  if (column && column.formatter) {
    return column.formatter(row, column, value);
  }
  return !value && value !== 0 ? '--' : value;
};
/* harmony default export */ var table_column = ({
  name: 'ElTableColumn',
  props: {
    type: {
      type: String,
      default: 'default'
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {},
    minWidth: {},
    renderHeader: Function,
    sortable: {
      type: [String, Boolean],
      default: false
    },
    sortMethod: Function,
    resizable: {
      type: Boolean,
      default: true
    },
    context: {},
    columnKey: String,
    align: String,
    headerAlign: String,
    showOverflowTooltip: Boolean,
    showOverflowTitle: Boolean,
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    selections: Array,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: true
    },
    ishtml: Boolean,
    allowExpand: {
      type: Function,
      default: () => true
    }
  },
  data() {
    return {
      isSubColumn: false,
      columns: []
    };
  },
  beforeCreate() {
    this.row = {};
    this.column = {};
    this.$index = 0;
  },
  components: {
    ElCheckbox: packages_checkbox,
    ElRadio: packages_radio,
    ElTag: packages_tag
  },
  computed: {
    owner() {
      let parent = this.$parent;
      while (parent && !parent.tableId) {
        parent = parent.$parent;
      }
      return parent;
    },
    columnOrTableParent() {
      let parent = this.$parent;
      while (parent && !parent.tableId && !parent.columnId) parent = parent.$parent;
      return parent;
    }
  },
  created() {
    const h = this.$createElement;
    const parent = this.columnOrTableParent;
    this.customRender = this.$options.render;
    this.$options.render = h => h('div', this.$slots.default);
    this.columnId = `${parent.tableId || `${parent.columnId}_`}column_${columnIdSeed++}`;
    const owner = this.owner;
    this.isSubColumn = owner !== parent;
    const type = this.type;
    let width = this.width;
    if (width !== undefined) {
      // width = parseInt(width, 10);
      // if (isNaN(width)) {
      //   width = null;
      // }
      if (!/%$/.test(width)) {
        width = parseInt(width, 10);
        if (isNaN(width)) {
          width = null;
        }
      }
    }
    let minWidth = this.minWidth;
    if (minWidth !== undefined) {
      minWidth = parseInt(minWidth, 10);
      if (isNaN(minWidth)) {
        minWidth = 51;
        if (this.sortable === '' || this.sortable) minWidth += 24;
        if (this.filters || this.filterMethod) minWidth += 32;
      }
    } else {
      minWidth = 51;
      if (this.sortable === '' || this.sortable) minWidth += 24;
      if (this.filters || this.filterMethod) minWidth += 32;
    }
    const isColumnGroup = false;
    const _self = this;
    const column = getDefaultColumn(type, {
      id: this.columnId,
      columnKey: this.columnKey,
      label: this.label,
      className: this.className,
      labelClassName: this.labelClassName,
      property: this.prop || this.property,
      type,
      renderCell: null,
      renderHeader: this.renderHeader,
      minWidth,
      width,
      isColumnGroup,
      context: this.context,
      align: this.align ? 'is-' + this.align : null,
      headerAlign: this.headerAlign ? 'is-' + this.headerAlign : this.align ? 'is-' + this.align : null,
      sortable: this.sortable === '' ? true : this.sortable,
      sortMethod: this.sortMethod,
      resizable: this.resizable,
      showOverflowTooltip: this.owner.store.table.showOverflowTooltip || this.showOverflowTooltip,
      showOverflowTitle: this.owner.store.table.showOverflowTitle || this.showOverflowTitle,
      formatter: this.formatter,
      selectable: this.selectable,
      reserveSelection: this.reserveSelection,
      selections: this.selections,
      fixed: this.fixed === '' ? true : this.fixed,
      filterMethod: this.filterMethod,
      filters: this.filters,
      filterable: this.filters || this.filterMethod,
      filterMultiple: this.filterMultiple,
      filterOpened: false,
      filteredValue: this.filteredValue || [],
      filterPlacement: this.filterPlacement || '',
      ishtml: this.ishtml,
      allowExpand: this.allowExpand,
      slotHeader: function (h, data) {
        if (!_self.$scopedSlots.header) return;
        return _self.$scopedSlots.header(data);
      },
      hasSlotHeader: function () {
        if (!_self.$scopedSlots.header) return false;
        return true;
      }
    });
    merge(column, forced[type] || {});
    this.columnConfig = column;
    let renderCell = column.renderCell;
    if (type === 'expand') {
      owner.renderExpanded = function (h, data) {
        return _self.$scopedSlots.default ? _self.$scopedSlots.default(data) : _self.$slots.default;
      };
      column.renderCell = function (h, data) {
        const allowExpand = column.allowExpand && column.allowExpand(data.row, data.$index);
        return h("div", {
          "class": 'cell'
        }, [renderCell(h, data, this._renderProxy, allowExpand)]);
      };
      return;
    }
    column.renderCell = function (h, data) {
      let tooltipWidth = data.column.realWidth;
      if (!tooltipWidth) {
        if (/%$/.test(data.column.width)) {
          tooltipWidth = data.column.width;
        } else {
          tooltipWidth = data.column.width + 'px';
        }
      } else {
        tooltipWidth += 'px';
      }
      // 未来版本移除
      if (_self.$vnode.data.inlineTemplate) {
        renderCell = function () {
          data._self = _self.context || data._self;
          if (Object.prototype.toString.call(data._self) === '[object Object]') {
            for (const prop in data._self) {
              if (!hasOwn(data, prop)) {
                data[prop] = data._self[prop];
              }
            }
          }
          // 静态内容会缓存到 _staticTrees 内，不改的话获取的静态数据就不是内部 context
          data._staticTrees = _self._staticTrees;
          data.$options.staticRenderFns = _self.$options.staticRenderFns;
          return _self.customRender.call(data);
        };
      } else if (_self.$scopedSlots.default) {
        renderCell = () => _self.$scopedSlots.default(data);
        if (!_self.showOverflowTooltip && !_self.showOverflowTitle) {
          return h("div", {
            "class": 'cell'
          }, [renderCell(h, data)]);
        }
      }
      if (!renderCell) {
        renderCell = DEFAULT_RENDER_CELL;
      }
      return column.showOverflowTooltip ? h("div", {
        "class": 'cell el-tooltip'
      }, [h("div", {
        "class": 'label'
      }, [renderCell(h, data)])]) : column.showOverflowTitle ? h("div", {
        "class": 'cell show-overflow-title'
      }, [h("div", {
        "class": 'label'
      }, [renderCell(h, data)])]) : h("div", {
        "class": 'cell'
      }, [renderCell(h, data)]);
    };
  },
  destroyed() {
    if (!this.$parent) return;
    const parent = this.$parent;
    this.owner.store.commit('removeColumn', this.columnConfig, this.isSubColumn ? parent.columnConfig : null);
  },
  watch: {
    label(newVal) {
      if (this.columnConfig) {
        this.columnConfig.label = newVal;
      }
    },
    prop(newVal) {
      if (this.columnConfig) {
        this.columnConfig.property = newVal;
      }
    },
    property(newVal) {
      if (this.columnConfig) {
        this.columnConfig.property = newVal;
      }
    },
    filters(newVal) {
      if (this.columnConfig) {
        this.columnConfig.filters = newVal;
      }
    },
    filteredValue(newVal) {
      if (this.columnConfig) {
        this.columnConfig.filteredValue = newVal;
        this.owner.store.commit('filterChange', {
          column: this.columnConfig,
          values: newVal,
          silent: true
        });
      }
    },
    filterMultiple(newVal) {
      if (this.columnConfig) {
        this.columnConfig.filterMultiple = newVal;
      }
    },
    align(newVal) {
      if (this.columnConfig) {
        this.columnConfig.align = newVal ? 'is-' + newVal : null;
        if (!this.headerAlign) {
          this.columnConfig.headerAlign = newVal ? 'is-' + newVal : null;
        }
      }
    },
    headerAlign(newVal) {
      if (this.columnConfig) {
        this.columnConfig.headerAlign = 'is-' + (newVal || this.align);
      }
    },
    width(newVal) {
      if (this.columnConfig) {
        this.columnConfig.width = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    minWidth(newVal) {
      if (this.columnConfig) {
        this.columnConfig.minWidth = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    fixed(newVal) {
      if (this.columnConfig) {
        this.columnConfig.fixed = newVal;
        this.owner.store.scheduleLayout();
      }
    },
    sortable(newVal) {
      if (this.columnConfig) {
        this.columnConfig.sortable = newVal;
      }
    }
  },
  mounted() {
    const owner = this.owner;
    const parent = this.columnOrTableParent;
    let columnIndex;
    if (!this.isSubColumn) {
      columnIndex = [].indexOf.call(parent.$refs.hiddenColumns.children, this.$el);
    } else {
      columnIndex = [].indexOf.call(parent.$el.children, this.$el);
    }
    owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
  }
});
// CONCATENATED MODULE: ./packages/table-column/index.js


/* istanbul ignore next */
table_column.install = function (Vue) {
  Vue.component(table_column.name, table_column);
};
/* harmony default export */ var packages_table_column = (table_column);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/h-paged-table/src/paged-table.vue?vue&type=template&id=1297e08a&
var paged_tablevue_type_template_id_1297e08a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-paged-table"},[_c('div',{staticClass:"el-paged-table__table"},[_vm._t("default",null,{"data":_vm.tableData})],2),_c('el-pagination',{staticClass:"el-paged-table__pagination",attrs:{"page-sizes":_vm.pageSizes,"page-size":_vm.pagination.pageSize,"total":_vm.pagination.total,"page-count":_vm.pagination.pageCount,"current-page":_vm.pagination.currentPage,"layout":_vm.layout,"before-current-change":_vm.beforeCurrentChange,"before-size-change":_vm.beforeSizeChange},on:{"size-change":_vm.handleSizeChange,"current-change":_vm.handleCurrentChange}})],1)}
var paged_tablevue_type_template_id_1297e08a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/h-paged-table/src/paged-table.vue?vue&type=template&id=1297e08a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/h-paged-table/src/paged-table.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var paged_tablevue_type_script_lang_js_ = ({
  name: 'HPagedTable',
  props: {
    /**
     * 构建 url 的函数
     * 当 props 的 fetch 未提供时，url 必填（为函数）
     * @param  {Number} pageSize    每页几条
     * @param  {Number} currentPage 第几页
     * @return {String} url 地址
     * @example (pageSize, currentPage, reloadOpt) => `https://api.example.com/items?perPage=${pageSize}&page=${currentPage}`
     */
    url: {
      type: [Function, String],
      default: ''
    },
    /**
     * 自定义请求函数
     * @param  {String} url         当前 url（由 props 的 url 返回的字符串）
     * @param  {Number} pageSize    每页几条
     * @param  {Number} currentPage 第几页
     * @param  {*} reloadOpt        调用 reload 方法时传进来的参数
     * @return {Promise<*>} 一个 Promise 对象，then 里接到的值为响应返回的数据
     * @example (url, pageSize, currentPage, reloadOpt) => axios.get(url)
     */
    fetch: {
      type: Function,
      default: url => defaultPromise({
        url
      })
    },
    /**
     * 当前是否正在请求
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * 分页跳转发请求前的钩子
     * @param {Number} val    改变后的值
     * @param {Number} oldVal 改变前的值
     * @return {Boolean} 是否继续发请求
     * @example (val, oldVal) => true
     */
    beforeCurrentChange: {
      type: Function,
      default: () => true
    },
    /**
     * 每页显示条目个数变化发请求前的钩子
     * @param {Number} val    改变后的值
     * @param {Number} oldVal 改变前的值
     * @return {Boolean} 是否继续发请求
     * @example (val, oldVal) => true
     */
    beforeSizeChange: {
      type: Function,
      default: () => true
    },
    /**
     * 获取表格数据的函数
     * @param {*} json 响应返回的数据
     * @return {Array} ElTable 的 props 中 data 所需的数据
     * @example (json) => json.items
     */
    data: {
      type: Function,
      required: true
    },
    /**
     * 获取总条目数的函数
     * @param {*} json 响应返回的数据
     * @return {Number} ElPagination 的 props 中 total 所需的数据
     * @example (json) => json.total
     */
    total: {
      type: Function,
      default: () => 0
    },
    /**
     * 获取总页数的函数
     * @param {*} json 响应返回的数据
     * @return {Number} ElPagination 的 props 中 page-count 所需的数据
     * @example (json) => json.pageCount
     */
    pageCount: {
      type: Function,
      default: () => 0
    },
    // 以下为 ElPagination 的 props
    layout: {
      type: String,
      default: 'total, sizes, prev, pager, next, jumper'
    },
    pageSize: {
      type: Number,
      default: 10
    },
    pageSizes: {
      type: Array,
      default: () => [10, 20, 30, 40, 50, 100]
    },
    // 用于用户对当前页的设置 add by yangzhini 2018-11-30
    currentPage: {
      type: Number,
      default: 1
    }
  },
  data() {
    return {
      tableData: [],
      pagination: {
        pageSize: this.pageSize || this.pageSizes[0] || 10,
        total: 0,
        pageCount: 0,
        currentPage: this.currentPage || 1
      }
    };
  },
  watch: {
    pageSize(val) {
      this.pagination.pageSize = val;
    },
    currentPage(val) {
      this.pagination.currentPage = val;
    }
  },
  mounted() {
    this.jump();
  },
  methods: {
    /**
     * 重新加载表格
     * @public
     */
    reload(opt) {
      return this.jump(opt);
    },
    jump(reloadOpt) {
      this.$emit('update:loading', true);
      const {
        pageSize,
        currentPage
      } = this.pagination;
      const url = typeof this.url === 'string' ? this.url : this.url(pageSize, currentPage, reloadOpt);
      return this.fetch(url, pageSize, currentPage, reloadOpt).then(json => {
        this.pagination.total = this.total(json);
        this.pagination.pageCount = this.pageCount(json);
        this.tableData = this.data(json);
        this.$emit('fetch-success', json);
      }).catch(err => this.$emit('fetch-error', err)).then(() => this.$emit('update:loading', false));
    },
    handleSizeChange(val) {
      this.pagination.pageSize = val;
      this.$emit('size-change', val);
      this.jump();
    },
    handleCurrentChange(val) {
      this.pagination.currentPage = val;
      this.$emit('update:currentPage', val);
      this.$emit('current-change', val);
      this.jump();
    }
  }
});
// CONCATENATED MODULE: ./packages/h-paged-table/src/paged-table.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_paged_tablevue_type_script_lang_js_ = (paged_tablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/h-paged-table/src/paged-table.vue





/* normalize component */

var paged_table_component = normalizeComponent(
  src_paged_tablevue_type_script_lang_js_,
  paged_tablevue_type_template_id_1297e08a_render,
  paged_tablevue_type_template_id_1297e08a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var paged_table = (paged_table_component.exports);
// CONCATENATED MODULE: ./packages/h-paged-table/index.js


/* istanbul ignore next */
paged_table.install = function (Vue) {
  Vue.component(paged_table.name, paged_table);
};
/* harmony default export */ var h_paged_table = (paged_table);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=template&id=6f1d7180&
var pickervue_type_template_id_6f1d7180_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.ranged)?_c('el-input',_vm._b({directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],ref:"reference",staticClass:"el-date-editor",class:'el-date-editor--' + _vm.type,attrs:{"readonly":!_vm.editable || _vm.readonly || _vm.type === 'dates',"disabled":_vm.pickerDisabled,"size":_vm.pickerSize,"name":_vm.name,"placeholder":_vm.placeholder,"value":_vm.displayValue,"title":_vm.displayValue,"validate-event":false,"maxlength":"20"},on:{"focus":_vm.handleFocus},nativeOn:{"mouseenter":function($event){return _vm.handleMouseEnter.apply(null, arguments)},"mouseleave":function($event){_vm.showClose = false},"keydown":function($event){return _vm.handleKeydown.apply(null, arguments)},"change":function($event){return _vm.handleChange.apply(null, arguments)},"input":function($event){return _vm.handleInput.apply(null, arguments)}}},'el-input',_vm.firstInputId,false),[_c('i',{staticClass:"el-input__icon el-date-editor__icon",class:[_vm.showClose ? _vm.clearIcon : _vm.triggerClass],attrs:{"slot":"suffix"},on:{"click":_vm.handleClickSuffixIcon},slot:"suffix"})]):_c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClose),expression:"handleClose"}],ref:"reference",staticClass:"el-date-editor el-range-editor el-input__inner",class:[
    'el-date-editor--' + _vm.type,
    _vm.pickerSize ? ("el-date-editor--" + _vm.pickerSize) : '',
    _vm.pickerDisabled ? 'is-disabled' : '',
    _vm.pickerVisible ? 'is-active' : ''
  ],attrs:{"title":_vm.displayTitle},on:{"click":_vm.handleFocus,"keydown":_vm.handleKeydown,"mouseenter":_vm.handleMouseEnter,"mouseleave":function($event){_vm.showClose = false}}},[_c('input',_vm._b({staticClass:"el-range-input",attrs:{"placeholder":_vm.startPlaceholder,"disabled":_vm.pickerDisabled,"readonly":!_vm.editable || _vm.readonly,"name":_vm.name && _vm.name[0],"autocomplete":"off"},domProps:{"value":_vm.displayValue && _vm.displayValue[0]},on:{"input":_vm.handleStartInput,"change":_vm.handleStartChange,"focus":_vm.handleFocus}},'input',_vm.firstInputId,false)),_vm._t("range-separator",function(){return [_c('span',{staticClass:"el-range-separator"},[_vm._v(_vm._s(_vm.rangeSeparator))])]}),_c('input',_vm._b({staticClass:"el-range-input",attrs:{"placeholder":_vm.endPlaceholder,"disabled":_vm.pickerDisabled,"readonly":!_vm.editable || _vm.readonly,"name":_vm.name && _vm.name[1],"autocomplete":"off"},domProps:{"value":_vm.displayValue && _vm.displayValue[1]},on:{"input":_vm.handleEndInput,"change":_vm.handleEndChange,"focus":_vm.handleFocus}},'input',_vm.secondInputId,false)),_c('span',{staticClass:"el-input__suffix"},[_c('span',{staticClass:"el-input__suffix-inner"},[_c('i',{staticClass:"el-input__icon el-range__icon el-date-editor__icon",class:[_vm.showClose ? _vm.clearIcon : _vm.triggerClass],on:{"click":_vm.handleClickSuffixIcon}})])])],2)}
var pickervue_type_template_id_6f1d7180_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=template&id=6f1d7180&

// CONCATENATED MODULE: ./src/utils/date.js
/* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd


/**
 * Parse or format dates
 * @class fecha
 */

var fecha = {};
var token = /d{1,4}|Mo|MM?M?M?|yy(?:yy)?|S{1,3}|do|W[o|W]?|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigits = /\d\d?/;
var threeDigits = /\d{3}/;
var fourDigits = /\d{4}/;
var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
var date_noop = function () {};
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
function monthUpdate(arrName) {
  return function (d, v, i18n) {
    var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
    if (~index) {
      d.month = index;
    }
  };
}
function pad(val, len) {
  val = String(val);
  len = len || 2;
  while (val.length < len) {
    val = '0' + val;
  }
  return val;
}
var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
fecha.i18n = {
  dayNamesShort: dayNamesShort,
  dayNames: dayNames,
  monthNamesShort: monthNamesShort,
  monthNames: monthNames,
  amPm: ['am', 'pm'],
  oFn: function oFn(D, i18nKey) {
    const reg = /(\$o){1}/;
    const isOrdinal = reg.test(Object(locale_["t"])(i18nKey, D));
    return isOrdinal ? D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10] : Object(locale_["t"])(i18nKey, {
      num: D
    });
  }
};
fecha.isDate = function (date) {
  if (date === null || date === undefined) return false;
  if (isNaN(new Date(date).getTime())) return false;
  if (Array.isArray(date)) return false; // deal with `new Date([ new Date() ]) -> new Date()`
  return true;
};
fecha.getWeekNumber = function (src) {
  if (fecha.isDate(src)) {
    const date = new Date(new Date(src).getTime());
    date.setHours(0, 0, 0, 0);
    // Thursday in current week decides the year.
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    // January 4 is always in week 1.
    const week1 = new Date(date.getFullYear(), 0, 4);
    // Adjust to Thursday in week 1 and count number of weeks from date to week 1.
    // Rounding should be fine for Daylight Saving Time. Its shift should never be more than 12 hours.
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
  } else {
    return null;
  }
};
var formatFlags = {
  W: function (dateObj) {
    const week = fecha.getWeekNumber(dateObj);
    return week;
  },
  WW: function (dateObj) {
    const week = fecha.getWeekNumber(dateObj);
    return week < 10 ? '0' + week : week;
  },
  D: function (dateObj) {
    return dateObj.getDay();
  },
  DD: function (dateObj) {
    return pad(dateObj.getDay());
  },
  d: function (dateObj) {
    return dateObj.getDate();
  },
  dd: function (dateObj) {
    return pad(dateObj.getDate());
  },
  ddd: function (dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function (dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function (dateObj) {
    return dateObj.getMonth() + 1;
  },
  MM: function (dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function (dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function (dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  yy: function (dateObj) {
    return String(dateObj.getFullYear()).substr(2);
  },
  yyyy: function (dateObj) {
    return dateObj.getFullYear();
  },
  h: function (dateObj) {
    return dateObj.getHours() % 12 || 12;
  },
  hh: function (dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function (dateObj) {
    return dateObj.getHours();
  },
  HH: function (dateObj) {
    return pad(dateObj.getHours());
  },
  m: function (dateObj) {
    return dateObj.getMinutes();
  },
  mm: function (dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function (dateObj) {
    return dateObj.getSeconds();
  },
  ss: function (dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function (dateObj) {
    return Math.round(dateObj.getMilliseconds() / 100);
  },
  SS: function (dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function (dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function (dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function (dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function (dateObj) {
    var o = dateObj.getTimezoneOffset();
    return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
  },
  do: function (dateObj, i18n) {
    return i18n.oFn(dateObj.getDate(), 'el.datepicker.dayOrdinal');
  },
  Mo: function (dateObj, i18n) {
    return i18n.oFn(dateObj.getMonth() + 1, 'el.datepicker.monthOrdinal');
  },
  Wo: function (dateObj, i18n) {
    const week = fecha.getWeekNumber(dateObj);
    return i18n.oFn(week, 'el.datepicker.weekOrdinal');
  }
};
var parseFlags = {
  d: [twoDigits, function (d, v) {
    d.day = v;
  }],
  M: [twoDigits, function (d, v) {
    d.month = v - 1;
  }],
  yy: [twoDigits, function (d, v) {
    var da = new Date(),
      cent = +('' + da.getFullYear()).substr(0, 2);
    d.year = '' + (v > 68 ? cent - 1 : cent) + v;
  }],
  h: [twoDigits, function (d, v) {
    d.hour = v;
  }],
  m: [twoDigits, function (d, v) {
    d.minute = v;
  }],
  s: [twoDigits, function (d, v) {
    d.second = v;
  }],
  yyyy: [fourDigits, function (d, v) {
    d.year = v;
  }],
  S: [/\d/, function (d, v) {
    d.millisecond = v * 100;
  }],
  SS: [/\d{2}/, function (d, v) {
    d.millisecond = v * 10;
  }],
  SSS: [threeDigits, function (d, v) {
    d.millisecond = v;
  }],
  D: [twoDigits, date_noop],
  ddd: [word, date_noop],
  MMM: [word, monthUpdate('monthNamesShort')],
  MMMM: [word, monthUpdate('monthNames')],
  a: [word, function (d, v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      d.isPm = false;
    } else if (val === i18n.amPm[1]) {
      d.isPm = true;
    }
  }],
  ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
    var parts = (v + '').match(/([\+\-]|\d\d)/gi),
      minutes;
    if (parts) {
      minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
      d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
    }
  }]
};
parseFlags.DD = parseFlags.D;
parseFlags.dddd = parseFlags.ddd;
parseFlags.do = parseFlags.dd = parseFlags.d;
parseFlags.mm = parseFlags.m;
parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
parseFlags.MM = parseFlags.M;
parseFlags.ss = parseFlags.s;
parseFlags.A = parseFlags.a;

// Some common format strings
fecha.masks = {
  default: 'ddd MMM dd yyyy HH:mm:ss',
  shortDate: 'M/D/yy',
  mediumDate: 'MMM d, yyyy',
  longDate: 'MMMM d, yyyy',
  fullDate: 'dddd, MMMM d, yyyy',
  shortTime: 'HH:mm',
  mediumTime: 'HH:mm:ss',
  longTime: 'HH:mm:ss.SSS'
};

/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 */
fecha.format = function (dateObj, mask, i18nSettings) {
  var i18n = i18nSettings || fecha.i18n;
  if (typeof dateObj === 'number') {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
    throw new Error('Invalid Date in fecha.format');
  }
  mask = fecha.masks[mask] || mask || fecha.masks['default'];
  return mask.replace(token, function ($0) {
    return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
  });
};
const isRangeIn = (str, min, max) => {
  const num = +str;
  if (num <= max && num >= min) {
    return true;
  }
  return false;
};

/**
 * Parse a date string into an object, changes - into /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @returns {Date|boolean}
 */
fecha.parse = function (dateStr, format, i18nSettings) {
  var i18n = i18nSettings || fecha.i18n;
  if (typeof format !== 'string') {
    throw new Error('Invalid format in fecha.parse');
  }
  format = fecha.masks[format] || format;
  // Avoid regular expression denial of service, fail early for really long strings
  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
  if (dateStr.length > 1000) {
    return false;
  }
  var isValid = true;
  var dateInfo = {};
  format.replace(token, function ($0) {
    if (parseFlags[$0]) {
      var info = parseFlags[$0];
      var index = dateStr.search(info[0]);
      if (!~index) {
        isValid = false;
      } else {
        dateStr.replace(info[0], function (result) {
          info[1](dateInfo, result, i18n);
          dateStr = dateStr.substr(index + result.length);
          return result;
        });
      }
    }
    return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
  });
  if (!isValid) {
    return false;
  }
  if (dateInfo.hour && !isRangeIn(dateInfo.hour, 0, 23)) {
    return false;
  }
  if (dateInfo.minute && !isRangeIn(dateInfo.minute, 0, 59)) {
    return false;
  }
  if (dateInfo.second && !isRangeIn(dateInfo.second, 0, 59)) {
    return false;
  }
  var today = new Date();
  if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var date;
  if (dateInfo.timezoneOffset != null) {
    dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
    date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
  } else {
    date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
  }
  return date;
};
/* harmony default export */ var utils_date = (fecha);
// CONCATENATED MODULE: ./packages/date-picker/src/util/index.js


const util_isEmpty = val => {
  if (typeof val === 'string') {
    return val.trim() === '';
  }
  return typeof val === 'undefined' || val === null;
};
const isString = function (val) {
  return typeof val === 'string' || val instanceof String;
};
const WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const MONTHS = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
const DEFAULT_FORMATS = {
  date: 'yyyy/MM/dd',
  month: 'yyyy/MM',
  datetime: 'yyyy/MM/dd HH:mm:ss',
  time: 'HH:mm:ss',
  week: 'yyyy/MM/dd$',
  timerange: 'HH:mm:ss',
  daterange: 'yyyy/MM/dd',
  monthrange: 'yyyy/MM',
  datetimerange: 'yyyy/MM/dd HH:mm:ss',
  year: 'yyyy'
};
const DATE_FORMATTER = function (value, format) {
  if (format === 'timestamp') return value.getTime();
  return formatDate(value, format);
};
const DATE_PARSER = function (text, format) {
  if (format === 'timestamp') return new Date(Number(text));
  return parseDate(text, format);
};
const RANGE_FORMATTER = function (value, format) {
  if (Array.isArray(value) && value.length === 2) {
    const start = value[0];
    const end = value[1];
    if (start && end) {
      return [DATE_FORMATTER(start, format), DATE_FORMATTER(end, format)];
    }
  }
  return '';
};
const RANGE_PARSER = function (array, format, separator) {
  if (!Array.isArray(array)) {
    array = array.split(separator);
  }
  if (array.length === 2) {
    const range1 = array[0];
    const range2 = array[1];
    return [DATE_PARSER(range1, format), DATE_PARSER(range2, format)];
  }
  return [];
};
const TYPE_VALUE_RESOLVER_MAP = {
  default: {
    formatter(value) {
      if (util_isEmpty(value)) {
        return '';
      }
      return '' + value;
    },
    parser(text) {
      if (text === undefined || text === '') return null;
      return text;
    }
  },
  week: {
    formatter(value, format) {
      const week = utils_date.getWeekNumber(value);
      let trueDate;
      if (Array.isArray(value)) {
        trueDate = new Date(value[0]);
      } else {
        trueDate = new Date(value);
      }
      const month = trueDate.getMonth();
      const showWeek = /W/.test(format);
      const isRange = /\${1}$/.test(format);
      if (isRange) {
        format = format.replace(/\${1}$/, '');
      }
      if (showWeek && week === 1 && month === 11) {
        trueDate.setHours(0, 0, 0, 0);
        trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);
      }
      const date = formatDate(trueDate, format);
      const endDate = formatDate(nextDate(trueDate, 6), format);
      if (!showWeek && isRange) {
        return `${date} - ${endDate}`;
      } else {
        return date;
      }
    },
    parser(text, format) {
      return TYPE_VALUE_RESOLVER_MAP.date.parser(text, format);
    }
  },
  date: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  datetime: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  daterange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  monthrange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  yearrange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  datetimerange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  timerange: {
    formatter: RANGE_FORMATTER,
    parser: RANGE_PARSER
  },
  time: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  month: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  year: {
    formatter: DATE_FORMATTER,
    parser: DATE_PARSER
  },
  number: {
    formatter(value) {
      if (util_isEmpty(value)) {
        return '';
      }
      return '' + value;
    },
    parser(text) {
      const result = Number(text);
      if (!isNaN(text)) {
        return result;
      } else {
        return null;
      }
    }
  },
  dates: {
    formatter(value, format) {
      return value.map(date => DATE_FORMATTER(date, format));
    },
    parser(value, format) {
      return (typeof value === 'string' ? value.split(', ') : value).map(date => date instanceof Date ? date : DATE_PARSER(date, format));
    }
  }
};
const validateFormatType = function (value, format) {
  switch (true) {
    case isDateObject(value):
      return true;
    case typeof value === 'number' && format === 'timestamp':
      {
        return true;
      }
    case typeof value === 'string':
      {
        const valueArr = value.split('');
        const formatArr = format.split('');
        const char = ['y', 'M', 'd', 'H', 'h', 'm', 's'];
        let formatLength = 0;
        let valueLength = 0;
        valueArr.forEach(str => {
          if (isInteger(+str) && str.trim() !== '') {
            valueLength++;
          }
        });
        formatArr.forEach(str => {
          if (char.includes(str)) {
            formatLength++;
          }
        });
        return formatLength === valueLength;
      }
    default:
      return true;
  }
};
const getI18nSettings = () => {
  return {
    dayNamesShort: WEEKS.map(week => Object(locale_["t"])(`el.datepicker.weeks.${week}`)),
    dayNames: WEEKS.map(week => Object(locale_["t"])(`el.datepicker.weeks.${week}`)),
    monthNamesShort: MONTHS.map(month => Object(locale_["t"])(`el.datepicker.months.${month}`)),
    monthNames: MONTHS.map((month, index) => Object(locale_["t"])(`el.datepicker.month${index + 1}`)),
    amPm: utils_date.i18n.amPm,
    oFn: utils_date.i18n.oFn
  };
};
const newArray = function (start, end) {
  const result = [];
  for (let i = start; i <= end; i++) {
    result.push(i);
  }
  return result;
};
const isDate = utils_date.isDate;
const getWeekNumber = utils_date.getWeekNumber;
const toDate = function (date) {
  return isDate(date) ? new Date(date) : util_now();
};
const isDateObject = function (val) {
  return val instanceof Date;
};
const formatDate = function (date, format, calendarType) {
  format = format || 'yyyy/MM/dd';
  if (typeof date === 'string') {
    return calendarType ? getOffsetDate(date, calendarType) : date;
  } else if (isDate(date)) {
    date = new Date(date);
  } else if (!date) {
    return '';
  }
  const d = utils_date.format(date, format, getI18nSettings());
  return calendarType ? getOffsetDate(d, calendarType) : d;
};
const parseDate = function (string, format) {
  format = format || 'yyyy/MM/dd';
  if (validateFormatType(string, format)) {
    return utils_date.parse(string, format, getI18nSettings());
  } else {
    return false;
  }
};
const getDayCountOfMonth = function (year, month) {
  if (month === 3 || month === 5 || month === 8 || month === 10) {
    return 30;
  }
  if (month === 1) {
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
      return 29;
    } else {
      return 28;
    }
  }
  return 31;
};
const setYear = function (date, _year) {
  return changeYearMonthAndClampDate(date, _year, date.getMonth());
};
const setMonth = function (date, _month) {
  return changeYearMonthAndClampDate(date, date.getFullYear(), _month);
};
const setDate = function (date, _date) {
  date.setDate(_date);
  return new Date(date);
};
const clearDate = date => {
  return new Date(date.getFullYear(), date.getMonth());
};
const clearDateAndMonth = date => {
  return new Date(date.getFullYear());
};
const clearTime = function (date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
};
const clearMinutes = function (date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());
};
const clearSeconds = function (date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());
};
const clearMilliseconds = function (date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
};
const timeToNowDate = function (date) {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};
const getDayCountOfYear = function (year) {
  const isLeapYear = year % 400 === 0 || year % 100 !== 0 && year % 4 === 0;
  return isLeapYear ? 366 : 365;
};
const getFirstDayOfMonth = function (date) {
  const temp = new Date(date.getTime());
  temp.setDate(1);
  return temp.getDay();
};

// see: https://stackoverflow.com/questions/3674539/incrementing-a-date-in-javascript
// {prev, next} Date should work for Daylight Saving Time
// Adding 24 * 60 * 60 * 1000 does not work in the above scenario
const prevDate = function (date, amount = 1) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate() - amount);
};
const nextDate = function (date, amount = 1) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate() + amount);
};
const getStartDateOfMonth = function (year, month) {
  const result = new Date(year, month, 1);
  const day = result.getDay();
  return prevDate(result, day);
};
const getRangeHours = function (ranges) {
  const hours = [];
  let disabledHours = [];
  (ranges || []).forEach(range => {
    const value = range.map(date => date.getHours());
    disabledHours = disabledHours.concat(newArray(value[0], value[1]));
  });
  if (disabledHours.length) {
    for (let i = 0; i < 24; i++) {
      hours[i] = disabledHours.indexOf(i) === -1;
    }
  } else {
    for (let i = 0; i < 24; i++) {
      hours[i] = false;
    }
  }
  return hours;
};
function setRangeData(arr, start, end, disabled) {
  for (let i = start; i < end; i++) {
    arr[i] = disabled;
  }
}
const util_getRange = function (type, ranges, date) {
  if (type === 'hours') {
    return getRangeHours(ranges);
  }
  const list = [];
  for (let i = 0; i < 60; i++) {
    list[i] = true;
  }
  if (!date) {
    return list;
  }
  const isMinutes = type === 'minutes';
  const dateTimestamp = isMinutes ? +clearMinutes(timeToNowDate(date)) : +clearSeconds(timeToNowDate(date));
  if (ranges.length > 0) {
    ranges.forEach(range => {
      const start = range[0];
      const end = range[1];
      const startList = isMinutes ? start.getMinutes() : start.getSeconds();
      const endList = isMinutes ? end.getMinutes() : end.getSeconds();
      const startTimestamp = isMinutes ? +clearMinutes(timeToNowDate(start)) : +clearSeconds(timeToNowDate(start));
      const endTimestamp = isMinutes ? +clearMinutes(timeToNowDate(end)) : +clearSeconds(timeToNowDate(end));
      if (startTimestamp === dateTimestamp && endTimestamp !== dateTimestamp) {
        setRangeData(list, startList, 60, false);
      } else if (startTimestamp === dateTimestamp && endTimestamp === dateTimestamp) {
        setRangeData(list, startList, endList + 1, false);
      } else if (startTimestamp !== dateTimestamp && endTimestamp === dateTimestamp) {
        setRangeData(list, 0, endList + 1, false);
      } else if (startTimestamp < dateTimestamp && endTimestamp > dateTimestamp) {
        setRangeData(list, 0, 60, false);
      }
    });
  } else {
    setRangeData(list, 0, 60, false);
  }
  return list;
};
const range = function (n) {
  // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
  return Array.apply(null, {
    length: n
  }).map((_, n) => n);
};
const dateMergeTime = function (from, to) {
  if (isDate(from) && isDate(to)) {
    from = new Date(from);
    to = new Date(to);
    return new Date(from.getFullYear(), from.getMonth(), from.getDate(), to.getHours(), to.getMinutes(), to.getSeconds(), to.getMilliseconds());
  }
  return to;
};
const modifyDate = function (date, y, m, d) {
  return new Date(y, m, d, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};
const modifyTime = function (date, h, m, s) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, s, date.getMilliseconds());
};
const modifyWithTimeString = (date, time) => {
  if (date === null) {
    return date;
  }
  if (!time) {
    return modifyTime(date, 0, 0, 0);
  }
  time = parseDate(time, 'HH:mm:ss');
  return modifyTime(date, time.getHours(), time.getMinutes(), time.getSeconds());
};
const limitTimeRange = function (date, ranges, format = 'HH:mm:ss') {
  // TODO: refactory a more elegant solution
  if (ranges.length === 0) return date;
  const normalizeDate = date => utils_date.parse(utils_date.format(date, format), format);
  const ndate = normalizeDate(date);
  const nranges = ranges.map(range => range.map(normalizeDate));
  if (nranges.some(nrange => ndate >= nrange[0] && ndate <= nrange[1])) {
    return date;
  }
  let minDate = nranges[0][0];
  let maxDate = nranges[0][0];
  nranges.forEach(nrange => {
    minDate = new Date(Math.min(nrange[0], minDate));
    maxDate = new Date(Math.max(nrange[1], minDate));
  });
  const ret = ndate < minDate ? minDate : maxDate;
  // preserve Year/Month/Date
  return modifyDate(ret, date.getFullYear(), date.getMonth(), date.getDate());
};
const timeWithinRange = function (date, selectableRange, format) {
  const limitedDate = limitTimeRange(date, selectableRange, format);
  return limitedDate.getTime() === date.getTime();
};
const changeYearMonthAndClampDate = function (date, year, month) {
  // clamp date to the number of days in `year`, `month`
  // eg: (2010-1-31, 2010, 2) => 2010-2-28
  const monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
  return modifyDate(date, year, month, monthDate);
};
const prevMonth = function (date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  return month === 0 ? changeYearMonthAndClampDate(date, year - 1, 11) : changeYearMonthAndClampDate(date, year, month - 1);
};
const util_nextMonth = function (date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  return month === 11 ? changeYearMonthAndClampDate(date, year + 1, 0) : changeYearMonthAndClampDate(date, year, month + 1);
};
const prevYear = function (date, amount = 1) {
  const year = date.getFullYear();
  const month = date.getMonth();
  return changeYearMonthAndClampDate(date, year - amount, month);
};
const nextYear = function (date, amount = 1) {
  const year = date.getFullYear();
  const month = date.getMonth();
  return changeYearMonthAndClampDate(date, year + amount, month);
};
const extractDateFormat = function (format) {
  return format.replace(/\W?m{1,2}\W?|\W?ZZ\W?/g, '').replace(/\W?h{1,2}\W?|\W?s{1,3}\W?|\W?a\W?/gi, '').trim();
};
const extractTimeFormat = function (format) {
  return format.replace(/\W?D{1,2}\W?|\W?do\W?|\W?d{1,4}\W?|\W?M{1,4}\W?|\W?y{2,4}\W?/g, '').trim();
};
const isInteger = function (val) {
  return typeof val === 'number' && val % 1 === 0;
};
const formatAsFormatAndType = (value, customFormat, type) => {
  if (util_isEmpty(value)) {
    return null;
  }
  const formatter = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP.default).formatter;
  const format = customFormat || DEFAULT_FORMATS[type];
  return formatter(value, format);
};
const parseAsFormatAndType = (value, customFormat, type, rangeSeparator = '-') => {
  if (util_isEmpty(value)) {
    return null;
  }
  const parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP.default).parser;
  let format = customFormat || DEFAULT_FORMATS[type];
  format = format && format.replace(/-/g, '/');
  if (validateFormatType(value, format)) {
    return parser(value, format, rangeSeparator);
  } else {
    return null;
  }
};
const getTimestamp = function (time, type = 'clearTime') {
  let tempTime;
  if (typeof time === 'number' || typeof time === 'string') {
    time = new Date(time);
  }
  if (!(time instanceof Date)) {
    return NaN;
  }
  switch (type) {
    case 'clearTime':
      tempTime = clearTime(time).getTime();
      break;
    case 'clearDate':
      tempTime = clearDate(time).getTime();
      break;
    case 'clearDateAndMonth':
      tempTime = clearDateAndMonth(time).getTime();
      break;
  }
  return tempTime;
};
const util_now = (type = 'clearTime') => {
  if (type === 'clearTime') {
    return clearTime(new Date());
  } else {
    return clearDate(new Date());
  }
};
const dateValidator = function (val) {
  const condition = item => isDate(item) || isString(item) || util_isEmpty(item);
  return util_isEmpty(val) || condition(val) || Array.isArray(val) && val.every(condition);
};
const isEmptyDate = val => {
  const condition = item => util_isEmpty(item);
  return condition(val) || Array.isArray(val) && val.every(condition);
};
const MIN_TIME = parseDate('00:00:00', 'HH:mm:ss');
const MAX_TIME = parseDate('23:59:59', 'HH:mm:ss');

// International calendar related interfaces, At present, it includes Buddhist calendar and Nepalese calendar
const src_util_getOffset = type => {
  let offset = 0;
  if (type === 'th') {
    offset = 543;
  } else if (type === 'np') {
    offset = 57;
  }
  return offset;
};
const getOffsetDate = (value, type) => {
  const offset = src_util_getOffset(type);
  const offsetDate = Number.parseInt(value.substring(0, 4), 10) + offset + value.substring(4, value.length);
  return offsetDate;
};
const RANGE_SPECIAL_FORMATTER = (value, calendarType) => {
  if (Array.isArray(value) && value.length === 2) {
    const start = value[0];
    const end = value[1];
    if (start && end) {
      return [getOffsetDate(start, calendarType), getOffsetDate(end, calendarType)];
    }
  }
  return '';
};
const TYPE_VALUE_SPECIAL_MAP = {
  default: {
    formatter(value) {
      return value;
    }
  },
  week: {
    formatter(value, calendarType, format) {
      const showWeek = /W/.test(format);
      const isRange = /\${1}$/.test(format);
      if (!showWeek && isRange) {
        const weeks = value.split(' - ');
        return getOffsetDate(weeks[0], calendarType) + ' - ' + getOffsetDate(weeks[1], calendarType);
      } else {
        return getOffsetDate(value, calendarType);
      }
    }
  },
  date: {
    formatter(value, calendarType) {
      return getOffsetDate(value, calendarType);
    }
  },
  month: {
    formatter(value, calendarType) {
      return getOffsetDate(value, calendarType);
    }
  },
  year: {
    formatter(value, calendarType) {
      return getOffsetDate(value, calendarType);
    }
  },
  datetime: {
    formatter(value, calendarType) {
      return getOffsetDate(value, calendarType);
    }
  },
  daterange: {
    formatter: RANGE_SPECIAL_FORMATTER
  },
  monthrange: {
    formatter: RANGE_SPECIAL_FORMATTER
  },
  datetimerange: {
    formatter: RANGE_SPECIAL_FORMATTER
  },
  dates: {
    formatter(value, calendarType) {
      return value.map(date => getOffsetDate(date, calendarType));
    }
  }
};
const formatSpecial = (value, customFormat, type, calendarType) => {
  if (value) {
    let format = customFormat || DEFAULT_FORMATS[type];
    format = format && format.replace(/-/g, '/');
    const formatter = (TYPE_VALUE_SPECIAL_MAP[type] || TYPE_VALUE_SPECIAL_MAP.default).formatter;
    return formatter(value, calendarType, format);
  } else {
    return value;
  }
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//









const NewPopper = {
  props: {
    appendToBody: vue_popper.props.appendToBody,
    offset: vue_popper.props.offset,
    boundariesPadding: vue_popper.props.boundariesPadding,
    arrowOffset: vue_popper.props.arrowOffset
  },
  methods: vue_popper.methods,
  data() {
    return merge({
      visibleArrow: false
    }, vue_popper.data);
  },
  beforeDestroy: vue_popper.beforeDestroy
};
const PLACEMENT_MAP = {
  left: 'bottom-start',
  center: 'bottom',
  right: 'bottom-end'
};
const HAVE_TRIGGER_TYPES = ['date', 'datetime', 'time', 'time-select', 'week', 'month', 'year', 'daterange', 'monthrange', 'timerange', 'datetimerange', 'dates', 'yearrange'];

/*
 * Considers:
 *   1. Date object
 *   2. date string
 *   3. array of 1 or 2
 */
const valueEquals = function (a, b) {
  // considers Date object and string
  const dateEquals = function (a, b) {
    const aIsDate = a instanceof Date;
    const bIsDate = b instanceof Date;
    if (aIsDate && bIsDate) {
      return a.getTime() === b.getTime();
    }
    if (!aIsDate && !bIsDate) {
      return a === b;
    }
    return false;
  };
  const aIsArray = a instanceof Array;
  const bIsArray = b instanceof Array;
  if (aIsArray && bIsArray) {
    if (a.length !== b.length) {
      return false;
    }
    return a.every((item, index) => dateEquals(item, b[index]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a, b);
  }
  return false;
};
const stringValidator = function (val) {
  // either: String, Array of String, null / undefined
  return util_isEmpty(val) || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);
};
/* harmony default export */ var pickervue_type_script_lang_js_ = ({
  components: {
    ElInput: packages_input
  },
  directives: {
    Clickoutside: clickoutside
  },
  mixins: [emitter, NewPopper],
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },
  props: {
    size: {
      type: String,
      default: null
    },
    format: {
      type: String,
      default: null
    },
    valueFormat: {
      type: String,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    startPlaceholder: {
      type: String,
      default: null
    },
    endPlaceholder: {
      type: String,
      default: null
    },
    prefixIcon: {
      type: String,
      default: null
    },
    clearIcon: {
      type: String,
      default: 'h-icon-close_f'
    },
    id: {
      default: '',
      validator: stringValidator
    },
    name: {
      default: '',
      validator: stringValidator
    },
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: true
    },
    popperClass: {
      type: String,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    align: {
      type: String,
      default: 'left'
    },
    value: {
      default: null,
      validator: dateValidator
    },
    defaultValue: {
      default: null,
      validator: dateValidator
    },
    defaultTime: {
      default: null,
      validator: dateValidator
    },
    rangeSeparator: {
      type: String,
      default: '-'
    },
    pickerOptions: {
      type: Object,
      default: () => {}
    },
    unlinkPanels: {
      type: Boolean,
      default: true
    },
    unlinkRange: {
      type: Boolean,
      default: true
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    unlink: {
      type: Boolean,
      default: null
    },
    calendarType: {
      type: String,
      default: ''
    }
  },
  data() {
    return {
      pickerVisible: false,
      showClose: false,
      userInput: null,
      valueOnOpen: null,
      // value when picker opens, used to determine whether to emit change
      unwatchPickerOptions: null,
      changeInput: true,
      preConfirmValue: null,
      calcValue: null
    };
  },
  computed: {
    ranged() {
      return this.type.indexOf('range') > -1;
    },
    refInput() {
      if (this.reference) {
        return [].slice.call(this.reference.querySelectorAll('input'));
      }
      return [];
    },
    valueIsEmpty() {
      const val = this.value;
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length; i < len; i++) {
          if (val[i]) {
            return false;
          }
        }
      } else {
        if (val) {
          return false;
        }
      }
      return true;
    },
    triggerClass() {
      return this.prefixIcon || (this.type === 'time' || this.type === 'time-select' || this.type === 'timerange' ? 'h-icon-clock' : 'h-icon-calendar');
    },
    selectionMode() {
      if (this.type === 'week') {
        return 'week';
      } else if (this.type === 'month') {
        return 'month';
      } else if (this.type === 'year') {
        return 'year';
      } else if (this.type === 'dates') {
        return 'dates';
      }
      return 'day';
    },
    haveTrigger() {
      if (typeof this.showTrigger !== 'undefined') {
        return this.showTrigger;
      }
      return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
    },
    displayValue() {
      let formattedValue = formatAsFormatAndType(this.preConfirmValue, this.format, this.type);
      // special date(th、niboer)
      if (this.calendarType === 'th' || this.calendarType === 'np') {
        formattedValue = formatSpecial(formattedValue, this.format, this.type, this.calendarType);
      }
      const userInput = this.userInput;
      const isTrueValue = () => {
        if (Array.isArray(formattedValue) && !util_isEmpty(formattedValue[0]) && !util_isEmpty(formattedValue[1])) {
          return true;
        }
        return !util_isEmpty(formattedValue);
      };
      if (Array.isArray(userInput) && isTrueValue()) {
        return [userInput[0] || formattedValue && formattedValue[0] || '', userInput[1] || formattedValue && formattedValue[1] || ''];
      } else if (userInput) {
        return userInput;
      } else if (isTrueValue()) {
        return this.type === 'dates' ? formattedValue.join(', ') : formattedValue;
      } else {
        return '';
      }
    },
    displayTitle() {
      const displayValue = this.displayValue;
      return displayValue === '' ? '' : `${displayValue && displayValue[0]} ${this.rangeSeparator} ${displayValue && displayValue[1]}`;
    },
    parsedValue() {
      if (!this.calcValue) return this.calcValue; // component value is not set
      if (this.type === 'time-select') {
        // time-select does not require parsing, this might change in next major version
        return this.value.length !== 5 ? this.calcValue : this.value;
      }
      const valueIsDateObject = isDateObject(this.calcValue) || Array.isArray(this.calcValue) && this.calcValue.every(isDateObject);
      if (valueIsDateObject) {
        return this.calcValue;
      }
      if (this.valueFormat) {
        const formatValue = parseAsFormatAndType(this.calcValue, this.valueFormat, this.type, this.rangeSeparator);
        if (!util_isEmpty(formatValue)) {
          return formatValue;
        } else {
          return this.calcValue;
        }
      }
      // NOTE: deal with common but incorrect usage, should remove in next major version
      // user might provide string / timestamp without value-format, coerce them into date (or array of date)
      return Array.isArray(this.calcValue) ? this.calcValue.map(val => toDate(val)) : toDate(this.calcValue);
    },
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    pickerSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },
    pickerDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    },
    firstInputId() {
      const obj = {};
      let id;
      if (this.ranged) {
        id = this.id && this.id[0];
      } else {
        id = this.id;
      }
      if (id) obj.id = id;
      return obj;
    },
    secondInputId() {
      const obj = {};
      let id;
      if (this.ranged) {
        id = this.id && this.id[1];
      }
      if (id) obj.id = id;
      return obj;
    }
  },
  watch: {
    pickerVisible(val) {
      if (this.readonly || this.pickerDisabled) return;
      if (val) {
        this.showPicker();
        this.valueOnOpen = Array.isArray(this.value) ? [...this.value] : this.value;
      } else {
        this.hidePicker();
        this.userInput = null;
        if (this.validateEvent) {
          this.dispatch('ElFormItem', 'el.form.blur');
        }
        this.$emit('blur', this.formatToValue(this.calcValue), this.displayValue);
        this.blur();
      }
    },
    parsedValue: {
      immediate: true,
      handler(val) {
        if (this.picker && val) {
          this.picker.value = val;
        }
      }
    },
    defaultValue(val) {
      // NOTE: should eventually move to jsx style picker + panel ?
      if (this.picker) {
        this.picker.defaultValue = val;
      }
    },
    value(val, oldVal) {
      if (!valueEquals(val, oldVal) && !this.pickerVisible && this.validateEvent) {
        this.dispatch('ElFormItem', 'el.form.change', val);
        if (!valueEquals(this.formatToValue(this.preConfirmValue), val)) {
          this.preConfirmValue = val;
        }
        if (!valueEquals(this.formatToValue(this.calcValue), val)) {
          this.calcValue = val;
        }
      }
    },
    preConfirmValue(val, oldVal) {
      if (!valueEquals(val, this.value)) {
        this.$emit('input', this.formatToValue(val), this.displayValue);
      }
    },
    calcValue(val, oldVal) {
      if (!valueEquals(val, this.preConfirmValue) && this.isValidValue(val) && this.pickerVisible) {
        // calcValue变化时不触发el.form.change事件(@param doNotValid为true)，只在pick时触发
        this.emitChange(val, false, true);
      }
    }
  },
  created() {
    // init
    const {
      value: val,
      type
    } = this;
    if (typeof val === 'number') {
      this.calcValue = new Date(val);
    } else if (typeof val === 'string' && val.length > 0 && (type.includes('date') || type.includes('month') || type.includes('year') || type.includes('week'))) {
      // 可能会导致面板初始化不渲染的问题
      this.calcValue = val ? new Date(val) : new Date();
    } else {
      this.calcValue = val;
    }
    this.preConfirmValue = val;
    // vue-popper
    this.popperOptions = {
      boundariesPadding: 0,
      gpuAcceleration: false
    };
    this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;
    this.$on('fieldReset', this.handleFieldReset);
  },
  mounted() {
    this.setReference();
  },
  methods: {
    setReference() {
      const reference = this.$refs.reference;
      this.reference = reference.$el || reference;
    },
    // replaceDate(value) {
    //   return value.replace(/-/g, '/');
    // },

    focus() {
      if (window) {
        window.focus();
      }
      this.handleFocus();
      this.refInput[0].focus();
    },
    blur() {
      this.refInput.forEach(input => input.blur());
    },
    formatToValue(value) {
      if (typeof value === 'number') {
        value = new Date(value);
      }
      if (util_isEmpty(value)) {
        return '';
      }
      const isParsed = isDateObject(value) || Array.isArray(value) && value.every(isDateObject);
      if (this.valueFormat && isParsed) {
        const formatValue = formatAsFormatAndType(value, this.valueFormat, this.type);
        return util_isEmpty(formatValue) ? value : formatValue;
      } else {
        return value;
      }
    },
    // {parse, formatTo} String deals with user input
    parseString(value) {
      const type = Array.isArray(value) ? this.type : this.type.replace('range', '');
      return parseAsFormatAndType(value, this.format, type);
    },
    formatToString(value) {
      const type = Array.isArray(value) ? this.type : this.type.replace('range', '');
      return formatAsFormatAndType(value, this.format, type);
    },
    handleMouseEnter() {
      if (this.readonly || this.pickerDisabled) return;
      if (!this.valueIsEmpty && this.clearable) {
        this.showClose = true;
      }
    },
    handleInput(event) {
      const val = event.target.value;
      this.$nextTick(() => {
        this.userInput = val;
        if (val && this.picker) {
          const parseDate = this.parseString(val);
          if (parseDate) {
            this.picker.value = parseDate;
            if (this.isValidValue(parseDate)) {
              this.emitInput(parseDate);
            }
          }
        }
      });
    },
    handleChange(event) {
      const val = event.target.value;
      this.userInput = val;
    },
    handleStartInput(event) {
      const val = event.target.value;
      const preConfirmValue = this.preConfirmValue && this.preConfirmValue[0];
      const parseValue = this.parseString(val);
      const isTimerange = this.type === 'timerange';
      if (parseValue && this.picker) {
        const value = isTimerange ? modifyDate(parseValue, preConfirmValue.getFullYear(), preConfirmValue.getMonth(), preConfirmValue.getDate()) : parseValue;
        const newValue = [value, this.picker.value && this.picker.value[1]];
        this.picker.value = newValue;
        if (this.isValidValue(newValue)) {
          this.emitInput(newValue);
        }
      }
    },
    handleEndInput(event) {
      const val = event.target.value;
      const preConfirmValue = this.preConfirmValue && this.preConfirmValue[1];
      const parseValue = this.parseString(val);
      const isTimerange = this.type === 'timerange';
      if (parseValue && this.picker) {
        const value = isTimerange ? modifyDate(parseValue, preConfirmValue.getFullYear(), preConfirmValue.getMonth(), preConfirmValue.getDate()) : parseValue;
        const newValue = [this.picker.value && this.picker.value[0], value];
        this.picker.value = newValue;
        if (this.isValidValue(newValue)) {
          this.emitInput(newValue);
        }
      }
    },
    handleStartChange(event) {
      const val = event.target.value;
      if (this.userInput) {
        this.userInput = [val, this.userInput[1]];
      } else {
        this.userInput = [val, null];
      }
    },
    handleEndChange(event) {
      const val = event.target.value;
      if (this.userInput) {
        this.userInput = [this.userInput[0], val];
      } else {
        this.userInput = [null, val];
      }
    },
    handleClickSuffixIcon(event) {
      if (this.showClose) {
        this.handleClickIcon(event);
      } else {
        this.handleFocus();
      }
    },
    handleClickIcon(event) {
      if (this.readonly || this.pickerDisabled) return;
      this.valueOnOpen = this.value;
      event.stopPropagation();
      this.emitInput(null);
      this.showClose = false;
      if (this.picker && typeof this.picker.handleClear === 'function') {
        this.picker.handleClear();
      }
    },
    handleClose() {
      if (!this.pickerVisible) return;
      this.pickerVisible = false;
    },
    handleFieldReset(initialValue) {
      this.userInput = initialValue === '' ? null : initialValue;
    },
    handleFocus() {
      if (!this.editable) {
        this.blur();
      }
      const type = this.type;
      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
        this.pickerVisible = true;
      }
      this.$emit('focus', this.formatToValue(this.calcValue), this.displayValue);
    },
    handleKeydown(event) {
      const keyCode = event.keyCode;
      // ESC
      if (keyCode === 27) {
        this.pickerVisible = false;
        event.stopPropagation();
        return;
      }

      // Tab
      if (keyCode === 9) {
        if (!this.ranged) {
          this.pickerVisible = this.picker.visible = false;
          this.blur();
          event.stopPropagation();
        } else {
          // user may change focus between two input
          setTimeout(() => {
            if (this.refInput.indexOf(document.activeElement) === -1) {
              this.pickerVisible = false;
              this.blur();
              event.stopPropagation();
            }
          }, 0);
        }
        return;
      }

      // Enter
      if (keyCode === 13) {
        if (this.userInput === '' || this.isValidValue(this.parseString(this.displayValue))) {
          this.pickerVisible = this.picker.visible = false;
          this.blur();
        }
        event.stopPropagation();
        return;
      }
      if (this.refInput[0] === document.activeElement) {
        event.stopPropagation();
        return;
      }

      // delegate other keys to panel
      if (this.picker && this.picker.handleKeydown) {
        this.picker.handleKeydown(event);
      }
    },
    hidePicker() {
      if (this.picker) {
        let emitValue;
        if (this.userInput === '') {
          emitValue = null;
        } else if (!this.userInput && this.picker.unlink) {
          this.calcValue = this.preConfirmValue;
          emitValue = this.calcValue;
        } else {
          this.preConfirmValue = this.calcValue;
          emitValue = this.preConfirmValue;
        }
        this.emitInput(emitValue);
        this.pickerVisible = false;
        this.picker.visible = false;
        this.destroyPopper();
      }
    },
    showPicker() {
      if (this.$isServer) return;
      this.setReference();
      if (!this.picker) {
        this.mountPicker();
      }
      this.$nextTick(() => {
        this.picker.value = this.parsedValue;
        this.resetView();
        this.pickerVisible = true;
        this.picker.visible = true;
        this.updatePopper();
        this.picker.adjustSpinners && this.picker.adjustSpinners();
      });
    },
    mountPicker() {
      const specialUnlinkTypes = ['year', 'month', 'time'];
      this.picker = new external_vue_default.a(this.panel).$mount();
      if (Object.keys(this.$slots).length) {
        this.picker.$slots = this.$slots;
      }
      if (Object.keys(this.$scopedSlots).length) {
        this.picker.$scopedSlots = this.$scopedSlots;
      }
      this.picker.defaultValue = this.defaultValue;
      this.picker.defaultTime = this.defaultTime;
      this.picker.popperClass = this.popperClass;
      this.popperElm = this.picker.$el;
      this.picker.width = this.reference.getBoundingClientRect().width;
      this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
      this.picker.type = this.type;
      this.picker.selectionMode = this.selectionMode;
      this.picker.unlinkPanels = this.unlinkPanels;
      this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;
      if (this.compareTimes && this.isRange) {
        this.picker.compareTimesFunc = this.compareTimes;
      }
      // HUI custom
      this.picker.unlink = this.unlink === null ? !specialUnlinkTypes.includes(this.type) : this.unlink;
      this.picker.unlinkRange = this.unlinkRange;
      this.picker.isRange = this.isRange;
      this.picker.startPlaceholder = this.startPlaceholder;
      this.picker.endPlaceholder = this.endPlaceholder;
      this.picker.displayValue = this.displayValue;
      this.picker.calendarType = this.calendarType;
      this.$watch('format', format => {
        this.picker.format = format;
      });
      const updateOptions = () => {
        const options = this.pickerOptions;
        if (options && options.selectableRange) {
          let ranges = options.selectableRange;
          const parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;
          const format = DEFAULT_FORMATS.timerange;
          ranges = Array.isArray(ranges) ? ranges : [ranges];
          this.picker.selectableRange = ranges.map(range => parser(range, format, this.rangeSeparator));
        }
        for (const option in options) {
          if (hasOwn(options, option) &&
          // 忽略 time-picker 的该配置项
          option !== 'selectableRange') {
            this.picker[option] = options[option];
          }
        }

        // main format must prevail over undocumented pickerOptions.format
        if (this.format) {
          this.picker.format = this.format;
        }
      };
      updateOptions();
      this.unwatchPickerOptions = this.$watch('pickerOptions', () => updateOptions(), {
        deep: true
      });
      this.$el.appendChild(this.picker.$el);
      this.picker.$on('dodestroy', this.doDestroy);
      this.picker.$on('pick', (date = '', visible = false, changeInput) => {
        this.calcValue = date;
        if (changeInput !== undefined) {
          this.changeInput = changeInput;
        } else {
          this.changeInput = !visible;
        }
        if (this.changeInput) {
          this.emitChange(date);
        }
        if (!visible || this.changeInput) {
          this.emitInput(date);
        }
        this.picker.visible = visible;
        this.pickerVisible = visible;
      });
      this.picker.$on('select-range', (start, end, pos) => {
        if (this.refInput.length === 0 || !this.pickerVisible) return;
        if (!pos || pos === 'min') {
          this.refInput[0].setSelectionRange(start, end);
          this.refInput[0].focus();
        } else if (pos === 'max') {
          this.refInput[1].setSelectionRange(start, end);
          this.refInput[1].focus();
        }
      });
    },
    unmountPicker() {
      if (this.picker) {
        this.picker.$destroy();
        this.picker.$off();
        this.doDestroy();
        if (typeof this.unwatchPickerOptions === 'function') {
          this.unwatchPickerOptions();
        }
        this.picker.$el.parentNode.removeChild(this.picker.$el);
      }
    },
    emitChange(val, forceEmit, doNotValid) {
      // determine user real change only
      if (!valueEquals(val, this.preConfirmValue) && !valueEquals(val, this.valueOnOpen) || forceEmit) {
        this.$emit('change', this.formatToValue(val), this.displayValue);
        this.valueOnOpen = val;
        if (this.validateEvent && !doNotValid) {
          this.dispatch('ElFormItem', 'el.form.change', val);
        }
      }
    },
    emitInput(val) {
      this.userInput = null;
      if (!valueEquals(this.preConfirmValue, val)) {
        this.calcValue = val;
        this.preConfirmValue = val;
      }
    },
    isValidValue(value) {
      if (!this.picker) {
        this.mountPicker();
      }
      if (this.picker.isValidValue) {
        return value && this.picker.isValidValue(value);
      } else {
        return true;
      }
    },
    resetView() {
      this.picker.resetView && this.picker.resetView();
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_pickervue_type_script_lang_js_ = (pickervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue





/* normalize component */

var picker_component = normalizeComponent(
  src_pickervue_type_script_lang_js_,
  pickervue_type_template_id_6f1d7180_render,
  pickervue_type_template_id_6f1d7180_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var picker = (picker_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=template&id=753e8fa0&
var datevue_type_template_id_753e8fa0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-bottom"},on:{"after-enter":_vm.handleEnter,"after-leave":_vm.handleLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-picker el-popper",class:[
      {
        'has-sidebar': _vm.hasSidebar,
        'has-time': _vm.showTime
      },
      _vm.popperClass
    ]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_vm._t("sidebar"),(_vm.shortcuts)?_c('div',{staticClass:"el-picker-panel__sidebar"},_vm._l((_vm.shortcuts),function(shortcut,key){return _c('button',{key:key,staticClass:"el-picker-panel__shortcut",attrs:{"type":"button"},domProps:{"textContent":_vm._s(shortcut.text)},on:{"click":function($event){return _vm.handleShortcutClick(shortcut)}}})}),0):_vm._e(),_c('div',{staticClass:"el-picker-panel__body"},[(_vm.currentView !== 'time')?_c('div',{ref:"pickerHeader",staticClass:"el-date-picker__header",class:{
            'el-date-picker__header--bordered':
              _vm.currentView === 'year' || _vm.currentView === 'month'
          }},[_c('button',{staticClass:"el-picker-panel__icon-btn el-date-picker__prev-btn h-icon-angles_left_sm",attrs:{"aria-label":_vm.t("el.datepicker.prevYear"),"type":"button"},on:{"click":_vm.prevYear}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date' || _vm.currentView === 'month'),expression:"currentView === 'date' || currentView === 'month'"}],staticClass:"el-picker-panel__icon-btn el-date-picker__prev-btn h-icon-angle_left_sm",attrs:{"aria-label":_vm.t("el.datepicker.prevMonth"),"type":"button"},on:{"click":_vm.prevMonth}}),_c('span',{staticClass:"el-picker-panel__header-label-wrapper",class:[("is-" + _vm.currentView), { 'is-en': _vm.isEn }]},[_c('span',{staticClass:"el-picker-panel__header-label",class:{ active: _vm.currentView === 'year' },attrs:{"title":_vm.yearLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.yearLabel)},on:{"click":_vm.showYearPicker}}),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date' || _vm.currentView === 'month'),expression:"currentView === 'date' || currentView === 'month'"}],staticClass:"el-picker-panel__header-label",class:{ active: _vm.currentView === 'month' },attrs:{"title":_vm.monthLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.monthLabel)},on:{"click":_vm.showMonthPicker}})]),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentView === 'date' || _vm.currentView === 'month'),expression:"currentView === 'date' || currentView === 'month'"}],staticClass:"el-picker-panel__icon-btn el-date-picker__next-btn h-icon-angle_right_sm",attrs:{"aria-label":_vm.t("el.datepicker.nextMonth"),"type":"button"},on:{"click":_vm.nextMonth}}),_c('button',{staticClass:"el-picker-panel__icon-btn el-date-picker__next-btn h-icon-angles_right_sm",attrs:{"aria-label":_vm.t("el.datepicker.nextYear"),"type":"button"},on:{"click":_vm.nextYear}})]):_vm._e(),_c('div',{staticClass:"el-picker-panel__content",class:{
            'has-modal': _vm.visibleDateTable,
            'is-time-picker': _vm.timePickerVisible
          }},[(_vm.visibleDateTable)?_c('date-table',{ref:"dateTable",attrs:{"unlink":_vm.unlink,"selection-mode":_vm.selectionMode,"first-day-of-week":_vm.firstDayOfWeek,"date-class-render":_vm.dateClassRender,"value":_vm.value,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate},on:{"pick":_vm.handleDatePick},scopedSlots:_vm._u([{key:!!(_vm.$slots.date || _vm.$scopedSlots.date) ? 'date' : null,fn:function(data){return [_vm._t("date",null,null,data)]}}],null,true)}):_vm._e(),(_vm.currentView === 'year')?_c('year-table',{ref:"yearTable",attrs:{"unlink":_vm.unlink,"value":_vm.value,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType},on:{"pick":_vm.handleYearPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.year || _vm.$scopedSlots.year) ? 'year' : null,fn:function(data){return [_vm._t("year",null,null,data)]}}],null,true)}):_vm._e(),(_vm.currentView === 'month')?_c('month-table',{ref:"monthTable",attrs:{"unlink":_vm.unlink,"value":_vm.value,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"date":_vm.date,"disabled-date":_vm.disabledDate},on:{"pick":_vm.handleMonthPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.month || _vm.$scopedSlots.month) ? 'month' : null,fn:function(data){return [_vm._t("month",null,null,data)]}}],null,true)}):_vm._e(),(_vm.showTime)?_c('div',{staticClass:"el-date-picker__time-header"},[_c('span',{staticClass:"el-date-picker__editor-wrap"},[_c('span',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:({
                  fn: _vm.handleTimePickClose,
                  excludes: _vm.$refs.changeToNow ? [_vm.$refs.changeToNow.$el] : []
                }),expression:"{\n                  fn: handleTimePickClose,\n                  excludes: $refs.changeToNow ? [$refs.changeToNow.$el] : []\n                }"}]},[_c('el-input',{ref:"input",attrs:{"placeholder":_vm.t('el.datepicker.selectTime'),"value":_vm.visibleTime,"maxlength":"10"},on:{"focus":function($event){_vm.timePickerVisible = true},"blur":_vm.handleVisibleTimeBlur,"input":function (val) { return (_vm.userInputTime = val); },"change":_vm.handleVisibleTimeChange}}),_c('time-picker',{ref:"timepicker",attrs:{"time-arrow-control":_vm.arrowControl,"visible":_vm.timePickerVisible,"unlink":false},on:{"pick":_vm.handleTimePick,"mounted":_vm.proxyTimePickerDataProperties,"select-range":_vm.setSelectionRange}})],1)])]):_vm._e()],1)])],2),(_vm.visibleFooter)?_c('div',{staticClass:"el-picker-panel__footer"},[(_vm.hasSidebar)?_c('span',{staticClass:"el-picker-panel__footer-message"},[_c('span',{domProps:{"textContent":_vm._s(_vm.visibleDate)}}),(_vm.showTime)?_c('span',{domProps:{"textContent":_vm._s(_vm.visibleTime)}}):_vm._e()]):_vm._e(),((_vm.selectionMode === 'dates' || _vm.disabledNow) && !_vm.hasSidebar)?_c('span',{staticClass:"el-picker-panel__footer-message"}):_vm._e(),(_vm.selectionMode !== 'dates' && !_vm.disabledNow)?_c('el-button',{ref:"changeToNow",staticClass:"el-picker-panel__link-btn el-picker-panel__now",class:{
          'el-picker-panel-btn__today': !_vm.hasSidebar
        },domProps:{"textContent":_vm._s(_vm.t(_vm.nowI18nKey))},on:{"click":_vm.changeToNow}}):_vm._e(),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"disabled":_vm.btnDisabled,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":_vm.confirm}})],1):_vm._e()])])}
var datevue_type_template_id_753e8fa0_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=template&id=753e8fa0&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=template&id=74b68b78&
var timevue_type_template_id_74b68b78_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.type === 'datetime' ? 'el-zoom-in-bottom' : 'el-zoom-in-top'},on:{"after-leave":function($event){return _vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-time-panel el-popper",class:("el-time-panel__" + _vm.type + (_vm.popperClass ? ' ' + _vm.popperClass : ''))},[_c('div',{staticClass:"el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds }},[_c('time-spinner',{ref:"spinner",attrs:{"unlink-range":_vm.unlinkRange,"arrow-control":_vm.useArrow,"show-seconds":_vm.showSeconds,"am-pm-mode":_vm.amPmMode,"date":_vm.date,"is-empty":_vm.isEmpty,"visible":_vm.visible},on:{"change":_vm.handleChange,"select-range":_vm.setSelectionRange}})],1),(_vm.unlink)?_c('div',{staticClass:"el-time-panel__footer"},[_c('el-button',{staticClass:"el-time-panel__btn",class:{ confirm: !_vm.disabled },attrs:{"disabled":_vm.isEmpty,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":_vm.handleConfirm}})],1):_vm._e()])])}
var timevue_type_template_id_74b68b78_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=template&id=74b68b78&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=43bf86a7&
var time_spinnervue_type_template_id_43bf86a7_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-time-spinner",class:{ 'has-seconds': _vm.showSeconds }},[(!_vm.arrowControl)?[_c('el-scrollbar',{ref:"hours",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","tag":"ul"},nativeOn:{"mouseenter":function($event){return _vm.emitSelectRange('hours')}}},_vm._l((_vm.hoursList),function(disabled,hour){return _c('li',{key:hour,staticClass:"el-time-spinner__item",class:{ active: hour === _vm.hours && !_vm.isEmpty, disabled: disabled },domProps:{"textContent":_vm._s(
            ('0' + (_vm.amPmMode ? hour % 12 || 12 : hour)).slice(-2) + _vm.amPm(hour)
          )},on:{"click":function($event){return _vm.handleClick('hours', {
              value: hour,
              disabled: disabled,
              active: hour === _vm.hours && !_vm.isEmpty
            })}}})}),0),_c('el-scrollbar',{ref:"minutes",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","tag":"ul"},nativeOn:{"mouseenter":function($event){return _vm.emitSelectRange('minutes')}}},_vm._l((_vm.minutesList),function(disabled,key){return _c('li',{key:key,staticClass:"el-time-spinner__item",class:{
            active: key === _vm.minutes && !_vm.isEmpty,
            disabled: disabled
          },domProps:{"textContent":_vm._s(('0' + key).slice(-2))},on:{"click":function($event){return _vm.handleClick('minutes', {
              value: key,
              disabled: disabled,
              active: key === _vm.minutes && !_vm.isEmpty
            })}}})}),0),_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSeconds),expression:"showSeconds"}],ref:"seconds",staticClass:"el-time-spinner__wrapper",attrs:{"wrap-style":"max-height: inherit;","view-class":"el-time-spinner__list","tag":"ul"},nativeOn:{"mouseenter":function($event){return _vm.emitSelectRange('seconds')}}},_vm._l((_vm.secondsList),function(disabled,key){return _c('li',{key:key,staticClass:"el-time-spinner__item",class:{
            active: key === _vm.seconds && !_vm.isEmpty,
            disabled: disabled
          },domProps:{"textContent":_vm._s(('0' + key).slice(-2))},on:{"click":function($event){return _vm.handleClick('seconds', {
              value: key,
              disabled: disabled,
              active: key === _vm.seconds && !_vm.isEmpty
            })}}})}),0)]:_vm._e(),(_vm.arrowControl)?[_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){return _vm.emitSelectRange('hours')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow h-icon-angle-sm-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow h-icon-angle_down_sm"}),_c('ul',{ref:"hours",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowHourList),function(hour,key){return _c('li',{key:key,staticClass:"el-time-spinner__item",class:{ active: hour === _vm.hours, disabled: _vm.hoursList[hour] },domProps:{"textContent":_vm._s(
              hour === undefined
                ? ''
                : ('0' + (_vm.amPmMode ? hour % 12 || 12 : hour)).slice(-2) +
                  _vm.amPm(hour)
            )}})}),0)]),_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){return _vm.emitSelectRange('minutes')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow h-icon-angle-sm-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow h-icon-angle_down_sm\n"}),_c('ul',{ref:"minutes",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowMinuteList),function(minute,key){return _c('li',{key:key,staticClass:"el-time-spinner__item",class:{ active: minute === _vm.minutes },domProps:{"textContent":_vm._s(minute === undefined ? '' : ('0' + minute).slice(-2))}})}),0)]),(_vm.showSeconds)?_c('div',{staticClass:"el-time-spinner__wrapper is-arrow",on:{"mouseenter":function($event){return _vm.emitSelectRange('seconds')}}},[_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.decrease),expression:"decrease"}],staticClass:"el-time-spinner__arrow h-icon-angle-sm-up"}),_c('i',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.increase),expression:"increase"}],staticClass:"el-time-spinner__arrow h-icon-angle_down_sm"}),_c('ul',{ref:"seconds",staticClass:"el-time-spinner__list"},_vm._l((_vm.arrowSecondList),function(second,key){return _c('li',{key:key,staticClass:"el-time-spinner__item",class:{ active: second === _vm.seconds },domProps:{"textContent":_vm._s(second === undefined ? '' : ('0' + second).slice(-2))}})}),0)]):_vm._e()]:_vm._e()],2)}
var time_spinnervue_type_template_id_43bf86a7_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=43bf86a7&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var time_spinnervue_type_script_lang_js_ = ({
  components: {
    ElScrollbar: scrollbar
  },
  directives: {
    repeatClick: repeat_click
  },
  mixins: [locale],
  props: {
    date: {
      default: null,
      validator: dateValidator
    },
    defaultValue: {
      default: null,
      validator: dateValidator
    },
    // reserved for future use
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: {
      type: Boolean,
      default: false
    },
    amPmMode: {
      type: String,
      default: '' // 'a': am/pm; 'A': AM/PM
    },
    visible: {
      type: Boolean,
      default: false
    },
    isEmpty: {
      type: Boolean,
      default: true
    },
    unlinkRange: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      selectableRange: [],
      currentScrollbar: null
    };
  },
  computed: {
    internalDate() {
      return toDate(this.date);
    },
    hours() {
      return this.internalDate.getHours();
    },
    minutes() {
      return this.internalDate.getMinutes();
    },
    seconds() {
      return this.internalDate.getSeconds();
    },
    hoursList() {
      return util_getRange('hours', this.selectableRange);
    },
    minutesList() {
      return util_getRange('minutes', this.selectableRange, this.internalDate);
    },
    secondsList() {
      return util_getRange('seconds', this.selectableRange, this.internalDate);
    },
    arrowHourList() {
      const hours = this.hours;
      return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];
    },
    arrowMinuteList() {
      const minutes = this.minutes;
      return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];
    },
    arrowSecondList() {
      const seconds = this.seconds;
      return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];
    }
  },
  methods: {
    increase() {
      this.scrollDown(1);
    },
    decrease() {
      this.scrollDown(-1);
    },
    modifyDateField(type, value) {
      let data;
      switch (type) {
        case 'hours':
          data = modifyTime(this.internalDate, value, this.minutes, this.seconds);
          break;
        case 'minutes':
          data = modifyTime(this.internalDate, this.hours, value, this.seconds);
          break;
        case 'seconds':
          data = modifyTime(this.internalDate, this.hours, this.minutes, value);
          break;
      }
      if (this.selectableRange.length > 0) {
        const start = this.selectableRange[0][0];
        const selectableRangeLength = this.selectableRange.length;
        const end = this.selectableRange[selectableRangeLength - 1][1];
        const dataHours = data.getHours();
        const dataMinutes = data.getMinutes();
        const dataSeconds = data.getSeconds();
        const startHours = start.getHours();
        const startMinutes = start.getMinutes();
        const startSeconds = start.getSeconds();
        const endHours = end.getHours();
        const endMinutes = end.getMinutes();
        const endSeconds = end.getSeconds();
        if (dataHours === startHours && dataMinutes < startMinutes) {
          data.setMinutes(startMinutes);
          this.adjustSpinner('minutes', startMinutes, 120);
          data.setSeconds(startSeconds);
          this.adjustSpinner('seconds', startSeconds, 120);
        } else if (dataHours === startHours && dataMinutes === startMinutes && dataSeconds < startSeconds) {
          data.setSeconds(startSeconds);
          this.adjustSpinner('seconds', startSeconds, 120);
        }
        if (dataHours === endHours && dataMinutes > endMinutes) {
          data.setMinutes(endMinutes);
          this.adjustSpinner('minutes', endMinutes, 120);
          data.setSeconds(endSeconds);
          this.adjustSpinner('seconds', endSeconds, 120);
        } else if (dataHours === endHours && dataMinutes === endMinutes && dataSeconds > endSeconds) {
          data.setSeconds(endSeconds);
          this.adjustSpinner('seconds', endSeconds, 120);
        }
      }
      this.$emit('change', data);
    },
    handleClick(type, {
      value,
      disabled,
      active
    }) {
      if (!disabled) {
        if (type === 'hours') {
          if (isDate(this.internalDate)) {
            const hours = modifyTime(this.internalDate, value, this.minutes, this.seconds);
            if (hours.getHours() !== value) {
              this.$message({
                message: this.t('el.datepicker.dstInfo'),
                type: 'info'
              });
            }
            value = hours.getHours();
          }
        }
        this.modifyDateField(type, value);
        this.$nextTick(() => {
          this.adjustSpinner('hours', this.hours, 120);
          this.adjustSpinner('minutes', this.minutes, 120);
          this.adjustSpinner('seconds', this.seconds, 120);
          this.emitSelectRange(type);
        });
      }
    },
    emitSelectRange(type) {
      if (this.visible) {
        if (type === 'hours') {
          this.$emit('select-range', 0, 2);
        } else if (type === 'minutes') {
          this.$emit('select-range', 3, 5);
        } else if (type === 'seconds') {
          this.$emit('select-range', 6, 8);
        }
        this.currentScrollbar = type;
      }
    },
    // NOTE: used by datetime / date-range panel
    //       renamed from adjustScrollTop
    //       should try to refactory it
    adjustSpinners() {
      this.adjustSpinner('hours', this.hours);
      this.adjustSpinner('minutes', this.minutes);
      this.adjustSpinner('seconds', this.seconds);
    },
    adjustCurrentSpinner(type) {
      this.adjustSpinner(type, this[type], 120);
    },
    adjustSpinner(type, value, duration = 0) {
      if (this.arrowControl) return;
      const el = this.$refs[type];
      if (el) {
        el.setScroll(value * this.typeItemHeight(type), 0, duration);
      }
    },
    scrollDown(step) {
      if (!this.currentScrollbar) {
        this.emitSelectRange('hours');
      }
      const label = this.currentScrollbar;
      const hoursList = this.hoursList;
      let now = this[label];
      // HUI fix circulation
      if (this.currentScrollbar === 'hours') {
        if (now === 0 && step < 0) {
          return;
        } else if (now === 23 && step > 0) {
          return;
        }
      } else {
        if (now === 0 && step < 0) {
          return;
        } else if (now === 59 && step > 0) {
          return;
        }
      }
      if (this.currentScrollbar === 'hours') {
        let total = Math.abs(step);
        step = step > 0 ? 1 : -1;
        let length = hoursList.length;
        while (length-- && total) {
          now = (now + step + hoursList.length) % hoursList.length;
          if (hoursList[now]) {
            continue;
          }
          total--;
        }
        if (hoursList[now]) return;
      } else {
        now = (now + step + 60) % 60;
      }
      this.modifyDateField(label, now);
      this.adjustSpinner(label, now);
      this.$nextTick(() => {
        this.emitSelectRange(this.currentScrollbar);
      });
    },
    amPm(hour) {
      const shouldShowAmPm = this.amPmMode.toLowerCase() === 'a';
      if (!shouldShowAmPm) return '';
      const isCapital = this.amPmMode === 'A';
      let content = hour < 12 ? ' am' : ' pm';
      if (isCapital) content = content.toUpperCase();
      return content;
    },
    typeItemHeight(type) {
      return this.$refs[type].$el.querySelector('li').offsetHeight;
    },
    scrollBarHeight(type) {
      return this.$refs[type].$el.offsetHeight;
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&
 /* harmony default export */ var basic_time_spinnervue_type_script_lang_js_ = (time_spinnervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue





/* normalize component */

var time_spinner_component = normalizeComponent(
  basic_time_spinnervue_type_script_lang_js_,
  time_spinnervue_type_template_id_43bf86a7_render,
  time_spinnervue_type_template_id_43bf86a7_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var time_spinner = (time_spinner_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var timevue_type_script_lang_js_ = ({
  components: {
    TimeSpinner: time_spinner,
    ElButton: packages_button
  },
  mixins: [locale],
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    timeArrowControl: {
      type: Boolean,
      default: false
    },
    unlinkRange: {
      type: Boolean,
      default: true
    },
    unlink: {
      type: Boolean,
      default: true
    },
    timeType: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      popperClass: '',
      format: 'HH:mm:ss',
      value: util_now(),
      defaultValue: null,
      date: util_now(),
      selectableRange: [],
      selectionRange: [0, 2],
      disabled: false,
      arrowControl: false,
      needInitAdjust: true,
      type: 'datetime'
    };
  },
  computed: {
    showSeconds() {
      return (this.format || '').indexOf('ss') !== -1;
    },
    useArrow() {
      return this.arrowControl || this.timeArrowControl || false;
    },
    amPmMode() {
      if ((this.format || '').indexOf('A') !== -1) return 'A';
      if ((this.format || '').indexOf('a') !== -1) return 'a';
      return '';
    },
    isEmpty() {
      return !this.defaultValue && util_isEmpty(this.value);
    }
  },
  watch: {
    visible(val) {
      if (val) {
        this.$nextTick(() => {
          this.adjustSpinners();
          this.$refs.spinner.emitSelectRange('hours');
        });
      } else {
        this.needInitAdjust = true;
        if (util_isEmpty(this.value)) {
          this.$emit('pick', this.isEmpty ? null : this.date, false, !this.unlink);
        }
      }
    },
    value(newVal, oldVal) {
      this.date = this.getTime();
      if (this.visible && this.needInitAdjust) {
        this.needInitAdjust = false;
      }
      this.$nextTick(() => {
        this.adjustChangeSpinners(newVal, oldVal);
      });
    },
    selectableRange(val) {
      this.$refs.spinner.selectableRange = val;
    },
    defaultValue(val) {
      if (util_isEmpty(this.value)) {
        this.date = toDate(val);
      }
    }
  },
  mounted() {
    this.$emit('mounted');
  },
  methods: {
    adjustChangeSpinners(newVal, oldVal) {
      if (this.adjustCurrentSpinner && isDate(newVal) && isDate(oldVal)) {
        this.changeInput = true;
        if (newVal.getHours() !== oldVal.getHours()) {
          this.adjustCurrentSpinner('hours');
        } else if (newVal.getMinutes() !== oldVal.getMinutes()) {
          this.adjustCurrentSpinner('minutes');
        } else if (newVal.getSeconds() !== oldVal.getSeconds()) {
          this.adjustCurrentSpinner('seconds');
        }
      }
    },
    handleClear() {
      this.date = toDate(this.defaultValue);
      this.$emit('input', null);
      this.$emit('pick', null);
    },
    getDefaultValue() {
      return toDate(this.defaultValue);
    },
    getTime() {
      const value = isDate(this.value) ? this.value : this.getDefaultValue();
      return limitTimeRange(value, this.selectableRange, this.format);
    },
    handleChange(date) {
      // this.visible avoids edge cases, when use scrolls during panel closing animation
      if (this.visible) {
        this.date = clearMilliseconds(date);
        this.$emit('pick', this.date, true, !this.unlink);
      }
    },
    setSelectionRange(start, end) {
      this.$emit('select-range', start, end, this.timeType);
      this.selectionRange = [start, end];
    },
    handleConfirm() {
      const date = clearMilliseconds(limitTimeRange(this.date, this.selectableRange, this.format));
      this.$emit('pick', date, false);
    },
    handleKeydown(event) {
      const keyCode = event.keyCode;
      const mapping = {
        38: -1,
        40: 1,
        37: -1,
        39: 1
      };

      // Left or Right
      if (keyCode === 37 || keyCode === 39) {
        const step = mapping[keyCode];
        this.changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      // Up or Down
      if (keyCode === 38 || keyCode === 40) {
        const step = mapping[keyCode];
        this.$refs.spinner.scrollDown(step);
        event.preventDefault();
      }
    },
    isValidValue(date) {
      return timeWithinRange(date, this.selectableRange, this.format);
    },
    adjustSpinners() {
      return this.$refs.spinner.adjustSpinners();
    },
    adjustCurrentSpinner(type) {
      this.$nextTick(() => {
        this.$refs.spinner.adjustCurrentSpinner(type);
      });
    },
    changeSelectionRange(step) {
      const list = [0, 3].concat(this.showSeconds ? [6] : []);
      const mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
      const index = list.indexOf(this.selectionRange[0]);
      const next = (index + step + list.length) % list.length;
      this.$refs.spinner.emitSelectRange(mapping[next]);
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_timevue_type_script_lang_js_ = (timevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue





/* normalize component */

var time_component = normalizeComponent(
  panel_timevue_type_script_lang_js_,
  timevue_type_template_id_74b68b78_render,
  timevue_type_template_id_74b68b78_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var panel_time = (time_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=d75bd996&
var year_tablevue_type_template_id_d75bd996_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"el-year-table"},[_c('tbody',_vm._l((_vm.rows),function(row,rowKey){return _c('tr',{key:rowKey},_vm._l((row),function(cell,cellKey){return _c('td',{key:cellKey,class:_vm.getCellStyle(cell),on:{"click":function($event){return _vm.handleYearTableClick(cell)}}},[(_vm.$slots.year || _vm.$scopedSlots.year)?_vm._t("year",null,null,_vm.buildData(cell)):(
            (_vm.$slots.startYear || _vm.$scopedSlots.startYear) &&
              _vm.tableType === 'min'
          )?_vm._t("startYear",null,null,_vm.buildData(cell)):(
            (_vm.$slots.endYear || _vm.$scopedSlots.endYear) && _vm.tableType === 'max'
          )?_vm._t("endYear",null,null,_vm.buildData(cell)):_c('span',{staticClass:"cell",domProps:{"textContent":_vm._s(cell.showValue)}})],2)}),0)}),0)])}
var year_tablevue_type_template_id_d75bd996_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=d75bd996&

// CONCATENATED MODULE: ./packages/date-picker/src/mixins/range.js

/* harmony default export */ var mixins_range = ({
  computed: {
    showPrompt() {
      // 如果存在没有赋值的情况，则调过这个步骤，相关issues：831
      // 处理issues:1432,1554问题。初始化的时候value不一定有值，如果判断value和value.length；初始化的时候不执行customValidation
      if (typeof this.customValidation === 'function' && (this.minDate && this.maxDate || this.value && this.value.length > 0)) return this.customValidation(this.calcMinDate, this.calcMaxDate);
      return true;
    },
    prompt() {
      if (this.showAbnormalInfo) {
        return locale_default.a.t('el.datepicker.abnormalInfo');
      }
      return this.customPrompt;
    },
    disabledConfirm() {
      if (this.showAbnormalInfo || !this.showPrompt) {
        return true;
      }
      return !(this.leftDate && this.rightDate && !this.selecting && this.isValidValue([this.leftDate, this.rightDate]));
    },
    isUnlinkRange() {
      if (!this.unlink) {
        return false;
      }
      return this.unlinkRange;
    }
  },
  methods: {
    emitRange({
      newDate,
      opts
    }) {
      if (this.unlinkRange) {
        if (this.tableType === 'min') {
          if (newDate < this.maxDate || this.minDate === null && this.maxDate === null || this.unlinkRange) {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: this.maxDate
            }, opts);
          } else {
            this.$emit('pick', {
              minDate: null,
              maxDate: this.maxDate
            }, opts);
          }
        } else {
          if (newDate > this.minDate || this.minDate === null && this.maxDate === null || this.unlinkRange) {
            this.$emit('pick', {
              minDate: this.minDate,
              maxDate: newDate
            }, opts);
          } else {
            this.$emit('pick', {
              minDate: this.minDate,
              maxDate: null
            }, opts);
          }
        }
      } else {
        if (!this.rangeState.selecting) {
          this.$emit('pick', {
            minDate: newDate,
            maxDate: null
          }, opts);
          this.rangeState.selecting = true;
        } else {
          if (newDate >= this.minDate) {
            this.$emit('pick', {
              minDate: this.minDate,
              maxDate: newDate
            }, opts);
          } else {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: this.minDate
            }, opts);
          }
          this.rangeState.selecting = false;
        }
      }
    }
  },
  data() {
    return {
      customValidation: () => true,
      customPrompt: locale_default.a.t('el.datepicker.abnormalInfo')
    };
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




const datesInYear = year => {
  const numOfDays = getDayCountOfYear(year);
  const firstDay = new Date(year, 0, 1);
  return range(numOfDays).map(n => nextDate(firstDay, n));
};
/* harmony default export */ var year_tablevue_type_script_lang_js_ = ({
  mixins: [mixins_range],
  props: {
    disabledDate: {
      type: Function,
      default: () => {
        return false;
      }
    },
    minDate: {
      type: null,
      default: null
    },
    maxDate: {
      type: null,
      default: null
    },
    defaultValue: {
      default: null,
      validator: dateValidator
    },
    date: {
      default: null,
      validator: dateValidator
    },
    value: {
      default: null,
      validator: dateValidator
    },
    unlinkRange: {
      type: Boolean,
      default: true
    },
    calendarType: {
      type: String,
      default: ''
    },
    tableType: {
      type: String,
      default: null
    },
    rangeState: {
      type: Object,
      default() {
        return {
          endDate: null,
          selecting: false
        };
      }
    },
    selectionMode: {
      type: String,
      default: 'year'
    }
  },
  data() {
    return {
      lastRow: null,
      lastColumn: null
    };
  },
  computed: {
    startYear() {
      return Math.floor(this.date.getFullYear() / 10) * 10;
    },
    rows() {
      // TODO: refactory rows / getCellClasses
      const rows = [[], [], []];
      const disabledDate = this.disabledDate;
      const today = new Date();
      for (let i = 0; i < 3; i++) {
        const row = rows[i];
        for (let j = 0; j < 4; j++) {
          let cell = row[j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: 'normal'
            };
          }
          const index = this.getIndex(i, j);
          const year = this.startYear + +index - 1;
          const offset = src_util_getOffset(this.calendarType);
          cell.value = year;
          cell.showValue = year + offset;
          const time = clearDateAndMonth(new Date(year + '')).getTime();
          cell.inRange = time >= this.getYearstamp(this.minDate) && time <= this.getYearstamp(this.maxDate);
          cell.start = this.minDate && time === this.getYearstamp(this.minDate);
          cell.end = this.maxDate && time === this.getYearstamp(this.maxDate);
          const isToday = today.getFullYear() === year;
          if (isToday) {
            cell.type = 'today';
          }
          if (+index === 0) {
            cell.type = 'prev-year';
          }
          if (+index === 11) {
            cell.type = 'next-year';
          }
          cell.disabled = datesInYear(year).every(disabledDate);
          cell.selected = arrayFindIndex(coerceTruthyValueToArray(this.value), date => date.getFullYear() === year) >= 0;
          this.$set(row, j, cell);
        }
      }
      return rows;
    }
  },
  methods: {
    buildData(cell) {
      const data = {};
      const openKeys = ['value', 'type', 'disabled', 'selected'];
      openKeys.forEach(item => {
        data[item] = cell[item];

        // 特殊处理 date
        const value = toDate(this.value);
        const date = new Date(value.getFullYear(), 1, 1, 0, 0, 0);
        data.date = date;
      });
      return data;
    },
    cellMatchesDate(cell, date) {
      const value = new Date(date);
      return cell.value === value.getFullYear();
    },
    getIndex(row, column) {
      return row * 4 + column;
    },
    getYearstamp(date) {
      return getTimestamp(date, 'clearDateAndMonth');
    },
    getCellStyle(cell) {
      const style = {};
      const defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
      style[cell.type] = true;
      style.default = defaultValue.some(date => this.cellMatchesDate(cell, date));
      style.disabled = cell.disabled;
      style.selected = cell.selected;
      style.today = cell.type === 'today';
      if (cell.start && (this.unlinkRange ? this.tableType !== 'max' : true)) {
        style['start-date'] = true;
      }
      if (cell.end && (this.unlinkRange ? this.tableType !== 'min' : true)) {
        style['end-date'] = true;
      }
      if (cell.inRange && !this.unlinkRange) {
        style['in-range'] = true;
      }
      return style;
    },
    handleYearTableClick(cell) {
      if (cell.disabled) {
        return;
      }
      const column = cell.column;
      const row = cell.row;
      const year = this.getIndex(row, column);
      const newDate = new Date(this.startYear + year - 1, 1, 1);
      const opts = {
        type: this.tableType,
        cell: cell
      };
      if (this.selectionMode === 'range') {
        this.emitRange({
          newDate,
          opts
        });
      } else {
        this.$emit('pick', cell.value);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&
 /* harmony default export */ var basic_year_tablevue_type_script_lang_js_ = (year_tablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue





/* normalize component */

var year_table_component = normalizeComponent(
  basic_year_tablevue_type_script_lang_js_,
  year_tablevue_type_template_id_d75bd996_render,
  year_tablevue_type_template_id_d75bd996_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var year_table = (year_table_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=77ba0138&
var month_tablevue_type_template_id_77ba0138_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"el-month-table"},[_c('tbody',_vm._l((_vm.rows),function(row,rowKey){return _c('tr',{key:rowKey},_vm._l((row),function(cell,cellKey){return _c('td',{key:cellKey,class:_vm.getCellStyle(cell),on:{"click":function($event){return _vm.handleMonthTableClick(cell)},"mousemove":function($event){return _vm.handleMouseMove(cell)}}},[(_vm.$slots.month || _vm.$scopedSlots.month)?_vm._t("month",null,null,_vm.buildData(cell)):(
            (_vm.$slots.startMonth || _vm.$scopedSlots.startMonth) &&
              _vm.tableType === 'min'
          )?_vm._t("startMonth",null,null,_vm.buildData(cell)):(
            (_vm.$slots.endMonth || _vm.$scopedSlots.endMonth) && _vm.tableType === 'max'
          )?_vm._t("endMonth",null,null,_vm.buildData(cell)):_c('span',{staticClass:"cell",domProps:{"textContent":_vm._s(cell.value + 1)}})],2)}),0)}),0)])}
var month_tablevue_type_template_id_77ba0138_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=77ba0138&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* 月份 i18n
el.datepicker.months.jan
el.datepicker.months.feb
el.datepicker.months.mar
el.datepicker.months.apr
el.datepicker.months.may
el.datepicker.months.jun
el.datepicker.months.jul
el.datepicker.months.aug
el.datepicker.months.sep
el.datepicker.months.oct
el.datepicker.months.nov
el.datepicker.months.dec
 */



const datesInMonth = (year, month) => {
  const numOfDays = getDayCountOfMonth(year, month);
  const firstDay = new Date(year, month, 1);
  return range(numOfDays).map(n => nextDate(firstDay, n));
};
/* harmony default export */ var month_tablevue_type_script_lang_js_ = ({
  mixins: [mixins_range],
  props: {
    disabledDate: {
      type: null,
      default: () => {
        return false;
      }
    },
    minDate: {
      type: null,
      default: null
    },
    maxDate: {
      type: null,
      default: null
    },
    defaultValue: {
      default: null,
      validator: dateValidator
    },
    date: {
      default: util_now('clearDate'),
      validator: dateValidator
    },
    value: {
      default: null,
      validator: dateValidator
    },
    selectionMode: {
      type: String,
      default: 'month'
    },
    rangeState: {
      type: Object,
      default() {
        return {
          endDate: null,
          selecting: false
        };
      }
    },
    unlinkRange: {
      type: Boolean,
      default: true
    },
    tableType: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      lastRow: null,
      lastColumn: null
    };
  },
  computed: {
    customValidationResult() {
      if (typeof this.customValidation === 'function') {
        const disabledMaxDate = new Date(this.maxDate);
        disabledMaxDate.setHours(0);
        disabledMaxDate.setMinutes(0);
        disabledMaxDate.setSeconds(0);
        return this.customValidation(new Date(this.minDate), disabledMaxDate);
      }
      return true;
    },
    rows() {
      // TODO: refactory rows / getCellClasses
      const rows = [[], []];
      const disabledDate = this.disabledDate;
      const year = this.date.getFullYear();
      const selectedDate = (cell, month) => {
        return arrayFindIndex(coerceTruthyValueToArray(this.value), date => date.getFullYear() === year && date.getMonth() === month) >= 0;
      };
      for (let i = 0; i < 2; i++) {
        const row = rows[i];
        for (let j = 0; j < 6; j++) {
          let cell = row[j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: 'normal',
              inRange: false,
              start: false,
              end: false,
              tableType: this.tableType
            };
          }
          const index = this.getIndex(i, j);
          const time = clearDate(new Date(this.date.getFullYear(), index)).getTime();
          cell.inRange = time >= this.getMonthstamp(this.minDate) && time <= this.getMonthstamp(this.maxDate);
          cell.start = this.minDate && time === this.getMonthstamp(this.minDate);
          cell.end = this.maxDate && time === this.getMonthstamp(this.maxDate);
          const isToday = time === this.getMonthstamp(util_now('clearDate'));
          if (isToday) {
            cell.type = 'today';
          }
          cell.value = index;
          cell.disabled = datesInMonth(year, index).every(disabledDate);
          cell.selected = selectedDate(cell, cell.value);
          this.$set(row, j, cell);
        }
      }
      return rows;
    }
  },
  watch: {
    'rangeState.endDate'(newVal) {
      this.markRange(this.minDate, newVal);
    },
    minDate(newVal, oldVal) {
      if (this.getMonthstamp(newVal) !== this.getMonthstamp(oldVal)) {
        this.markRange(this.minDate, this.maxDate);
      }
    },
    maxDate(newVal, oldVal) {
      if (this.getMonthstamp(newVal) !== this.getMonthstamp(oldVal)) {
        this.markRange(this.minDate, this.maxDate);
      }
    }
  },
  methods: {
    buildData(cell) {
      const data = {};
      const openKeys = ['value', 'type', 'disabled', 'selected'];
      openKeys.forEach(item => {
        data[item] = cell[item];

        // 特殊处理 date
        const value = toDate(this.value);
        const date = new Date(value.getFullYear(), value.getMonth(), 1, 0, 0, 0);
        data.date = date;
      });
      return data;
    },
    getMonthstamp(date) {
      return getTimestamp(date, 'clearDate');
    },
    getIndex(row, column) {
      return row * 6 + column;
    },
    cellMatchesDate(cell, date) {
      const value = new Date(date);
      return this.date.getFullYear() === value.getFullYear() && +cell.value === value.getMonth();
    },
    markRange(minDate, maxDate) {
      minDate = this.getMonthstamp(minDate);
      maxDate = this.getMonthstamp(maxDate) || (this.unlinkRange ? NaN : minDate);
      if (!this.unlinkRange) {
        [minDate, maxDate] = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
      }
      const rows = this.rows;
      for (let i = 0, k = rows.length; i < k; i++) {
        const row = rows[i];
        for (let j = 0, l = row.length; j < l; j++) {
          const cell = row[j];
          const index = this.getIndex(i, j);
          const time = new Date(this.date.getFullYear(), index).getTime();
          cell.inRange = minDate && time >= minDate && time <= maxDate;
          cell.start = minDate && time === minDate;
          cell.end = maxDate && time === maxDate;
        }
      }
    },
    handleMouseMove(cell) {
      if (!this.rangeState.selecting) {
        return;
      }
      const row = cell.row;
      const column = cell.column;
      // can not select disabled date
      if (cell.disabled) {
        return;
      }

      // only update rangeState when mouse moves to a new cell
      // this avoids frequent Date object creation and improves performance
      if (row !== this.lastRow || column !== this.lastColumn) {
        this.lastRow = row;
        this.lastColumn = column;
        this.$emit('changerange', {
          minDate: this.minDate,
          maxDate: this.maxDate,
          rangeState: {
            selecting: true,
            endDate: this.getMonthOfCell(this.getIndex(row, column))
          }
        });
      }
    },
    getCellStyle(cell) {
      const style = {};
      const defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
      style[cell.type] = true;
      style.default = defaultValue.some(date => this.cellMatchesDate(cell, date));
      style.disabled = cell.disabled;
      style.selected = cell.selected;
      style.today = cell.type === 'today';
      if (cell.start && (this.unlinkRange ? this.tableType !== 'max' : true)) {
        style['start-date'] = true;
      }
      if (cell.end && (this.unlinkRange ? this.tableType !== 'min' : true)) {
        style['end-date'] = true;
      }
      if (cell.inRange && !this.unlinkRange) {
        style['in-range'] = true;
      }
      return style;
    },
    getMonthOfCell(month) {
      const year = this.date.getFullYear();
      return new Date(year, month, 1);
    },
    handleMonthTableClick(cell) {
      if (cell.disabled) {
        return;
      }
      const column = cell.column;
      const row = cell.row;
      const month = this.getIndex(row, column);
      const newDate = this.getMonthOfCell(month);
      const opts = {
        type: this.tableType,
        cell: cell
      };
      if (this.selectionMode === 'range') {
        this.emitRange({
          newDate,
          opts
        });
      } else {
        this.$emit('pick', month);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&
 /* harmony default export */ var basic_month_tablevue_type_script_lang_js_ = (month_tablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue





/* normalize component */

var month_table_component = normalizeComponent(
  basic_month_tablevue_type_script_lang_js_,
  month_tablevue_type_template_id_77ba0138_render,
  month_tablevue_type_template_id_77ba0138_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var month_table = (month_table_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5e09d4ad&
var date_tablevue_type_template_id_5e09d4ad_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"el-date-table el-date-table__week"},[(_vm.showWeekNumber)?_c('div',[_vm._v(_vm._s(_vm.t('el.datepicker.week')))]):_vm._e(),_vm._l((_vm.WEEKS),function(week,key){return _c('div',{key:key,staticClass:"el-date-table__week-cell",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.weeks.' + week))}})})],2),_c('table',{staticClass:"el-date-table el-date-table__calendar",class:{
      'is-week-mode': _vm.selectionMode === 'week',
      'is-unlink': _vm.unlinkRange
    },attrs:{"cellspacing":"0","cellpadding":"0"}},[_c('tbody',_vm._l((_vm.rows),function(row,key){return _c('tr',{key:key,staticClass:"el-date-table__row",class:{
          selected: _vm.isWeekActive(row[1])
        }},_vm._l((row),function(cell,rowKey){return _c('td',{key:rowKey,class:_vm.getCellClasses(cell),on:{"click":function($event){return _vm.handleClick(cell)},"mousemove":function($event){return _vm.handleMouseMove(cell)}}},[(_vm.$slots.date || _vm.$scopedSlots.date)?_vm._t("date",null,null,_vm.buildData(cell)):(
              (_vm.$slots.startDate || _vm.$scopedSlots.startDate) &&
                _vm.tableType === 'min'
            )?_vm._t("startDate",null,null,_vm.buildData(cell)):(
              (_vm.$slots.endDate || _vm.$scopedSlots.endDate) && _vm.tableType === 'max'
            )?_vm._t("endDate",null,null,_vm.buildData(cell)):_c('span',{staticClass:"cell",class:cell.renderClasses,domProps:{"textContent":_vm._s(cell.value)}})],2)}),0)}),0)])])}
var date_tablevue_type_template_id_5e09d4ad_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5e09d4ad&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






// remove the first element that satisfies `pred` from arr
// return a new array if modification occurs
// return the original array otherwise
const removeFromArray = function (arr, pred) {
  const idx = typeof pred === 'function' ? arrayFindIndex(arr, pred) : arr.indexOf(pred);
  return idx >= 0 ? [...arr.slice(0, idx), ...arr.slice(idx + 1)] : arr;
};
const date_tablevue_type_script_lang_js_WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
/* harmony default export */ var date_tablevue_type_script_lang_js_ = ({
  mixins: [locale, mixins_range],
  props: {
    firstDayOfWeek: {
      default: 1,
      type: Number,
      validator: val => val >= 1 && val <= 7
    },
    minDate: {
      type: null,
      default: null
    },
    maxDate: {
      type: null,
      default: null
    },
    defaultValue: {
      default: null,
      validator: dateValidator
    },
    date: {
      default: null,
      validator: dateValidator
    },
    value: {
      default: null,
      validator: dateValidator
    },
    selectionMode: {
      type: String,
      default: 'day'
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function,
      default: () => {
        return false;
      }
    },
    dateClassRender: {
      type: Function,
      default: () => {
        return '';
      }
    },
    rangeState: {
      type: null,
      default() {
        return {
          endDate: null,
          selecting: false
        };
      }
    },
    tableType: {
      type: String,
      default: null
    },
    unlinkRange: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      lastRow: null,
      lastColumn: null
    };
  },
  computed: {
    offsetDay() {
      const week = this.firstDayOfWeek;
      // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置
      return week > this.firstDayOfMonth ? 7 - week : -week;
    },
    WEEKS() {
      const week = this.firstDayOfWeek;
      return date_tablevue_type_script_lang_js_WEEKS.concat(date_tablevue_type_script_lang_js_WEEKS).slice(week, week + 7);
    },
    year() {
      return this.date.getFullYear();
    },
    month() {
      return this.date.getMonth();
    },
    monthDate() {
      return this.date.getDate();
    },
    startDate() {
      return getStartDateOfMonth(this.year, this.month);
    },
    firstDayOfMonth() {
      const date = new Date(this.year, this.month, 1);
      return getFirstDayOfMonth(date);
    },
    rows() {
      // TODO: refactory rows / getCellClasses
      const rows = [[], [], [], [], [], []];
      const date = new Date(this.year, this.month, 1);
      const day = getFirstDayOfMonth(date); // day of first day
      const selectionMode = this.selectionMode;
      const dateCountOfMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth());
      const dateCountOfLastMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);
      const selectedDate = (cell, cellDate) => {
        if (this.selectionMode === 'dates') {
          return !!arrayFind(coerceTruthyValueToArray(this.value), date => clearTime(date).getTime() === clearTime(cellDate).getTime());
        } else if (selectionMode === 'day') {
          return (cell.type === 'normal' || cell.type === 'today') && this.cellMatchesDate(cell, this.value);
        } else {
          return false;
        }
      };
      const offset = this.offsetDay;
      let count = 1;
      const startDate = this.startDate;
      const disabledDate = this.disabledDate;
      const dateClassRender = this.dateClassRender;
      for (let i = 0; i < 6; i++) {
        const row = rows[i];
        if (this.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: 'week',
              value: getWeekNumber(nextDate(startDate, i * 7 + 1))
            };
          }
        }
        for (let j = 0; j < 7; j++) {
          let cell = row[this.showWeekNumber ? j + 1 : j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: 'normal',
              inRange: false,
              start: false,
              end: false,
              tableType: this.tableType
            };
          }
          cell.type = 'normal';
          const index = i * 7 + j;
          const time = nextDate(startDate, index - offset).getTime();
          cell.inRange = time >= getTimestamp(this.minDate) && time <= getTimestamp(this.maxDate);
          cell.start = this.minDate && time === getTimestamp(this.minDate);
          cell.end = this.maxDate && time === getTimestamp(this.maxDate);
          const isToday = time === getTimestamp(util_now());
          if (isToday) {
            cell.type = 'today';
          }
          if (i >= 0 && i <= 1) {
            if (j + i * 7 >= day + offset) {
              cell.value = count++;
            } else {
              cell.value = dateCountOfLastMonth - (day + offset - j % 7) + 1 + i * 7;
              cell.type = 'prev-month';
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.value = count++;
            } else {
              cell.value = count++ - dateCountOfMonth;
              cell.type = 'next-month';
            }
          }
          const cellDate = new Date(time);
          cell.disabled = disabledDate(cellDate);
          cell.renderClasses = dateClassRender ? dateClassRender(cellDate) : '';
          cell.selected = selectedDate(cell, cellDate);
          this.$set(row, this.showWeekNumber ? j + 1 : j, cell);
        }
        if (this.selectionMode === 'week') {
          const start = this.showWeekNumber ? 1 : 0;
          const end = this.showWeekNumber ? 7 : 6;
          const isWeekActive = this.isWeekActive(row[start + 1]);
          row[start].inRange = isWeekActive;
          row[start].start = isWeekActive;
          row[end].inRange = isWeekActive;
          row[end].end = isWeekActive;
        }
      }
      return rows;
    },
    weekDate() {
      let date = util_now();
      const startDate = this.startDate;
      const offset = this.offsetDay;
      this.rows.forEach(item => {
        item.forEach(cell => {
          if (cell.start) {
            date = nextDate(startDate, cell.row * 7 - offset);
          }
        });
      });
      return date;
    }
  },
  watch: {
    'rangeState.endDate'(newVal) {
      this.markRange(this.minDate, newVal);
    },
    minDate(newVal, oldVal) {
      if (getTimestamp(newVal) !== getTimestamp(oldVal)) {
        this.markRange(this.minDate, this.maxDate);
      }
    },
    maxDate(newVal, oldVal) {
      if (getTimestamp(newVal) !== getTimestamp(oldVal)) {
        this.markRange(this.minDate, this.maxDate);
      }
    }
  },
  methods: {
    buildData(cell) {
      const data = {};
      const openKeys = ['value', 'type', 'disabled', 'selected'];
      openKeys.forEach(item => {
        data[item] = cell[item];

        // 特殊处理 date
        const value = new Date(this.year, this.month);
        if (cell.type === 'next-month') value.setMonth(value.getMonth() + 1);else if (cell.type === 'prev-month') value.setMonth(value.getMonth() - 1);
        const date = new Date(value.getFullYear(), value.getMonth(), cell.value, 0, 0, 0);
        data.date = date;
      });
      return data;
    },
    cellMatchesDate(cell, date) {
      const value = new Date(date);
      return this.year === value.getFullYear() && this.month === value.getMonth() && +cell.value === value.getDate();
    },
    getCellClasses(cell) {
      const style = {};
      const selectionMode = this.selectionMode;
      const defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
      style[cell.type] = true;
      style.default = cell.type === 'normal' && defaultValue.some(date => this.cellMatchesDate(cell, date));
      style.disabled = cell.disabled;
      style.selected = cell.selected;
      if (selectionMode === 'week') {
        if (cell.start) {
          style['start-date'] = true;
        }
        if (cell.end) {
          style['end-date'] = true;
        }
      } else if (cell.type === 'normal' || cell.type === 'today') {
        if (cell.start && (this.unlinkRange ? this.tableType !== 'max' : true)) {
          style['start-date'] = true;
        }
        if (cell.end && (this.unlinkRange ? this.tableType !== 'min' : true)) {
          style['end-date'] = true;
        }
        if (cell.inRange && !this.unlinkRange) {
          style['in-range'] = true;
        }
      }
      return style;
    },
    getDateOfCell(row, column) {
      const offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;
      return nextDate(this.startDate, offsetFromStart);
    },
    isWeekActive(cell) {
      if (this.selectionMode !== 'week') return false;
      let newDate = new Date(this.year, this.month, 1);
      const year = newDate.getFullYear();
      const month = newDate.getMonth();
      if (cell.type === 'prev-month') {
        newDate = setYear(newDate, month === 0 ? year - 1 : year);
        newDate = setMonth(newDate, month === 0 ? 11 : month - 1);
      }
      if (cell.type === 'next-month') {
        newDate = setYear(newDate, month === 11 ? year + 1 : year);
        newDate = setMonth(newDate, month === 11 ? 0 : month + 1);
      }
      newDate = setDate(newDate, parseInt(cell.value, 10));
      if (isDate(this.value)) {
        const dayOffset = (this.value.getDay() - this.firstDayOfWeek + 7) % 7 - 1;
        const weekDate = prevDate(this.value, dayOffset);
        return weekDate.getTime() === newDate.getTime();
      }
      return false;
    },
    markRange(minDate, maxDate) {
      minDate = getTimestamp(minDate);
      maxDate = getTimestamp(maxDate) || (this.unlinkRange ? NaN : minDate);
      if (!this.unlinkRange) {
        [minDate, maxDate] = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
      }
      const startDate = this.startDate;
      const rows = this.rows;
      for (let i = 0, k = rows.length; i < k; i++) {
        const row = rows[i];
        for (let j = 0, l = row.length; j < l; j++) {
          if (this.showWeekNumber && j === 0) continue;
          const cell = row[j];
          const index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
          const time = nextDate(startDate, index - this.offsetDay).getTime();
          cell.inRange = minDate && time >= minDate && time <= maxDate;
          cell.start = minDate && time === minDate;
          cell.end = maxDate && time === maxDate;
        }
      }
    },
    handleMouseMove(cell) {
      // can not select disabled date
      if (!this.rangeState.selecting || cell.disabled || this.unlinkRange) {
        return;
      }

      // HUI modification
      const row = cell.row;
      const column = cell.column;

      // only update rangeState when mouse moves to a new cell
      // this avoids frequent Date object creation and improves performance
      if (row !== this.lastRow || column !== this.lastColumn) {
        this.lastRow = row;
        this.lastColumn = column;
        this.$emit('changerange', {
          minDate: this.minDate,
          maxDate: this.maxDate,
          rangeState: {
            selecting: true,
            endDate: this.getDateOfCell(row, column)
          }
        });
      }
    },
    handleClick(cell) {
      // HUI modification
      const row = cell.row;
      const column = this.selectionMode === 'week' ? 1 : cell.column;
      if (cell.disabled || cell.type === 'week') return;
      const newDate = this.getDateOfCell(row, column);
      const opts = {
        type: this.tableType,
        cell: cell
      };
      if (this.selectionMode === 'range') {
        this.emitRange({
          newDate,
          opts
        });
      } else if (this.selectionMode === 'day') {
        this.$emit('pick', newDate, opts);
      } else if (this.selectionMode === 'week') {
        const weekNumber = getWeekNumber(newDate);
        this.$emit('pick', {
          year: newDate.getFullYear(),
          week: weekNumber,
          date: prevDate(newDate)
        }, opts);
      } else if (this.selectionMode === 'dates') {
        const value = Array.isArray(this.value) ? this.value : this.value ? [this.value] : [];
        const newValue = cell.selected ? removeFromArray(value, date => date.getTime() === newDate.getTime()) : [...value, newDate];
        this.$emit('pick', newValue, opts);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&
 /* harmony default export */ var basic_date_tablevue_type_script_lang_js_ = (date_tablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue





/* normalize component */

var date_table_component = normalizeComponent(
  basic_date_tablevue_type_script_lang_js_,
  date_tablevue_type_template_id_5e09d4ad_render,
  date_tablevue_type_template_id_5e09d4ad_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var date_table = (date_table_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











/* harmony default export */ var datevue_type_script_lang_js_ = ({
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    TimePicker: panel_time,
    YearTable: year_table,
    MonthTable: month_table,
    DateTable: date_table,
    ElInput: packages_input,
    ElButton: packages_button
  },
  mixins: [locale],
  data() {
    return {
      closeOnClickModal: true,
      popperClass: '',
      date: util_now(),
      time: null,
      value: '',
      defaultValue: null,
      // use getDefaultValue() for time computation
      defaultTime: null,
      showTime: false,
      selectionMode: 'day',
      type: '',
      shortcuts: '',
      visible: false,
      currentView: 'date',
      disabledDate: () => {
        return false;
      },
      dateClassRender: null,
      selectableRange: [],
      firstDayOfWeek: 1,
      showWeekNumber: false,
      timePickerVisible: false,
      format: '',
      arrowControl: false,
      userInputDate: null,
      userInputTime: null,
      unlink: true,
      displayValue: '',
      calendarType: ''
    };
  },
  computed: {
    isEn() {
      const reg = /^[a-zA-Z]+$/;
      return reg.test(this.monthLabel);
    },
    btnDisabled() {
      if (!!this.value && this.disabledDate(this.value)) {
        return true;
      }
      return !this.value;
    },
    transitionName() {
      return false;
    },
    nowI18nKey() {
      switch (this.selectionMode) {
        case 'year':
          return 'el.datepicker.currentYear';
        case 'month':
          return 'el.datepicker.currentMonth';
        case 'week':
          return 'el.datepicker.currentWeek';
        case 'day':
          if (this.type === 'datetime') {
            return 'el.datepicker.now';
          } else {
            return 'el.datepicker.today';
          }
        default:
          return 'el.datepicker.now';
      }
    },
    hasSidebar() {
      return this.$slots.sidebar || this.shortcuts;
    },
    visibleFooter() {
      return this.unlink || this.showTime;
    },
    year() {
      return this.date.getFullYear();
    },
    month() {
      return this.date.getMonth();
    },
    week() {
      return getWeekNumber(this.date);
    },
    monthDate() {
      return this.date.getDate();
    },
    visibleDateTable() {
      return this.currentView === 'date' || this.selectionMode === 'day' || this.selectionMode === 'dates' || this.selectionMode === 'week';
    },
    visibleTime() {
      if (this.userInputTime !== null) {
        return this.userInputTime;
      }
      const time = toDate(this.time);
      if (this.time) {
        return formatAsFormatAndType(time, this.timeFormat, this.type);
      } else {
        return this.defaultTime || '';
      }
    },
    visibleDate() {
      if (this.userInputDate !== null) {
        return this.userInputDate;
      } else {
        return formatAsFormatAndType(this.value || this.defaultValue, this.dateFormat, this.type);
      }
    },
    yearLabel() {
      const yearTranslation = this.t('el.datepicker.year');
      if (this.currentView === 'year') {
        const startYear = Math.floor(this.year / 10) * 10;
        if (yearTranslation) {
          return startYear + this.offsetYear + yearTranslation + ' - ' + (startYear + this.offsetYear + 9) + yearTranslation;
        }
        return startYear + this.offsetYear + ' - ' + (startYear + this.offsetYear + 9);
      }
      return this.year + this.offsetYear + yearTranslation;
    },
    monthLabel() {
      return this.t(`el.datepicker.month${this.month + 1}`);
    },
    timeFormat() {
      if (this.format) {
        return extractTimeFormat(this.format);
      } else {
        return 'HH:mm:ss';
      }
    },
    dateFormat() {
      if (this.format) {
        return extractDateFormat(this.format);
      } else {
        return 'yyyy/MM/dd';
      }
    },
    refInput() {
      if (this.$refs.input.$el) {
        return [].slice.call(this.$refs.input.$el.querySelectorAll('input'))[0];
      }
      return [];
    },
    disabledNow() {
      return !((!this.disabledDate || !this.disabledDate(util_now())) && this.checkDateWithinRange(util_now()));
    },
    weekOffsetDay() {
      const week = this.firstDayOfWeek;
      return week > this.date.getDay() ? 7 - week : -week;
    },
    offsetYear() {
      return src_util_getOffset(this.calendarType);
    }
  },
  watch: {
    visible(val) {
      if (!val) {
        this.closeModal();
      } else {
        if (this.selectionMode === 'month') {
          this.currentView = 'month';
        } else if (this.selectionMode === 'year') {
          this.currentView = 'year';
        } else {
          this.currentView = 'date';
        }
      }
    },
    showTime(val) {
      /* istanbul ignore if */
      if (!val) return;
      this.$nextTick(() => {
        const inputElm = this.$refs.input.$el;
        if (inputElm) {
          this.pickerWidth = inputElm.getBoundingClientRect().width + 10;
        }
      });
    },
    value(newVal, oldVal) {
      if (this.selectionMode === 'dates' && this.value) return;
      if (isDate(newVal)) {
        this.date = this.type === 'datetime' ? new Date(newVal) : clearTime(newVal);
        if (this.$refs.timepicker && isDate(oldVal)) {
          this.$refs.timepicker.adjustCurrentSpinner('hours');
          this.$refs.timepicker.adjustCurrentSpinner('minutes');
          this.$refs.timepicker.adjustCurrentSpinner('seconds');
        }
      } else {
        this.date = this.getDefaultValue();
      }
      this.time = newVal;
    },
    defaultValue(val) {
      if (!isDate(this.value)) {
        this.resetView();
      }
    },
    defaultTime(val) {
      if (!isDate(this.value)) {
        this.resetView();
      }
    },
    timePickerVisible(val) {
      if (val) {
        if (this.defaultTime) {
          this.time = this.getTime();
        }
        this.$nextTick(() => this.$refs.timepicker.adjustSpinners());
        this.openModal(this.$refs.pickerHeader);
      } else {
        if (!this.time) {
          this.time = this.getTime();
        }
        this.closeModal();
      }
    },
    selectionMode(newVal) {
      if (newVal === 'month') {
        /* istanbul ignore next */
        if (this.currentView !== 'year' || this.currentView !== 'month') {
          this.currentView = 'month';
        }
      } else if (newVal === 'dates') {
        this.currentView = 'date';
      }
    },
    currentView(val) {
      if (val === 'date') {
        this.closeModal();
      }
    }
  },
  beforeMount() {
    this._popupId = `popup-date-${this._uid}`;
    popup_manager.register(this._popupId, this);
  },
  beforeDestroy() {
    popup_manager.deregister(this._popupId);
    popup_manager.closeModal(this._popupId);
  },
  methods: {
    proxyTimePickerDataProperties() {
      const format = timeFormat => {
        this.$refs.timepicker.format = timeFormat;
      };
      const value = value => {
        this.$refs.timepicker.value = value;
      };
      const time = time => {
        this.$refs.timepicker.date = time;
      };
      const selectableRange = selectableRange => {
        this.$refs.timepicker.selectableRange = selectableRange;
      };
      const defaultValue = defaultValue => {
        this.$refs.timepicker.defaultValue = defaultValue;
      };
      this.$watch('timeFormat', format);
      this.$watch('value', value);
      this.$watch('time', time);
      this.$watch('selectableRange', selectableRange);
      this.$watch('defaultValue', defaultValue);
      this.$watch('defaultTime', defaultValue);
      format(this.timeFormat);
      value(this.value);
      time(this.time);
      selectableRange(this.selectableRange);
      defaultValue(this.defaultValue || this.defaultTime);
    },
    handleClear() {
      this.date = this.getDefaultValue();
      this.time = null;
      this.emit(null);
    },
    emit(value, ...args) {
      if (util_isEmpty(value)) {
        this.$emit('pick', value, ...args);
      } else if (Array.isArray(value)) {
        const dates = value.map(date => this.showTime ? clearMilliseconds(date) : clearTime(date));
        this.$emit('pick', dates, ...args);
      } else {
        this.$emit('pick', this.showTime ? clearMilliseconds(value) : clearTime(value), ...args);
      }
      this.userInputDate = null;
      this.userInputTime = null;
    },
    openModal(dom) {
      popup_manager.openModal({
        id: this._popupId,
        zIndex: 10,
        dom: dom,
        modalClass: '',
        modalFade: true,
        multiModal: true
      });
    },
    closeModal() {
      popup_manager.closeModal(this._popupId);
    },
    close() {
      this.currentView = 'date';
      this.closeModal();
    },
    showYearPicker() {
      this.currentView = 'year';
      if (this.selectionMode !== 'year' && this.selectionMode !== 'month') {
        this.$nextTick(() => {
          this.openModal(this.$refs.yearTable.$el);
        });
      }
    },
    showMonthPicker() {
      this.currentView = 'month';
      if (this.selectionMode !== 'year' && this.selectionMode !== 'month') {
        this.$nextTick(() => {
          this.openModal(this.$refs.monthTable.$el);
        });
      }
    },
    setValue(emit) {
      if (this.value && this.selectionMode !== 'dates') {
        this.value = this.date;
      }
      if (emit) {
        this.emit(this.value, true);
      }
    },
    prevMonth() {
      this.date = prevMonth(this.date);
      // this.setValue(true);
    },
    nextMonth() {
      this.date = util_nextMonth(this.date);
      // this.setValue(true);
    },
    prevYear() {
      if (this.currentView === 'year') {
        this.date = prevYear(this.date, 10);
      } else {
        this.date = prevYear(this.date);
      }
      // this.setValue(true);
    },
    nextYear() {
      if (this.currentView === 'year') {
        this.date = nextYear(this.date, 10);
      } else {
        this.date = nextYear(this.date);
      }
      // this.setValue(true);
    },
    handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
      this.closeModal();
    },
    handleTimePick(value, visible) {
      if (visible) {
        if (isDate(value)) {
          const newDate = !util_isEmpty(this.date) ? modifyTime(this.date, value.getHours(), value.getMinutes(), value.getSeconds()) : modifyTime(this.date, value.getHours(), value.getMinutes(), value.getSeconds());
          this.time = newDate;
          if (this.date) {
            this.emit(newDate, true, false);
          }
        } else {
          this.emit(value, true, false);
        }
      }
    },
    handleTimePickClose() {
      this.timePickerVisible = false;
    },
    handleYearPick(year) {
      if (this.selectionMode === 'year') {
        this.date = modifyDate(this.date, year, 0, 1);
        this.emit(this.date, this.visibleFooter);
      } else {
        this.date = setYear(this.date, year);
        // TODO: should emit intermediate value ??
        if (this.selectionMode === 'month') {
          this.currentView = 'month';
        } else {
          this.currentView = 'date';
        }
        if (this.type !== 'dates') this.emit(this.date, true);
      }
      this.setValue();
      this.closeModal();
    },
    handleMonthPick(month) {
      if (this.selectionMode === 'month') {
        this.date = modifyDate(this.date, this.year, month, 1);
        this.emit(this.date, this.visibleFooter);
      } else {
        this.date = setMonth(this.date, month);
        // TODO: should emit intermediate value ??
        this.currentView = 'date';
        if (this.type !== 'dates') this.emit(this.date, true);
      }
      this.setValue();
      this.closeModal();
    },
    handleDatePick(value) {
      if (this.selectionMode === 'day') {
        let newDate = this.date ? modifyDate(this.date, value.getFullYear(), value.getMonth(), value.getDate()) : modifyWithTimeString(value, this.defaultTime);
        // change default time while out of selectableRange
        if (!this.checkDateWithinRange(newDate)) {
          newDate = modifyDate(this.selectableRange[0][0], value.getFullYear(), value.getMonth(), value.getDate());
        }
        if (util_isEmpty(this.time)) {
          this.time = this.getTime();
        }
        this.date = newDate;
        this.emit(this.date, this.visibleFooter);
      } else if (this.selectionMode === 'week') {
        this.emit(value.date, this.visibleFooter);
      } else if (this.selectionMode === 'dates') {
        this.emit(value, true); // set false to keep panel open
      }
    },
    changeToNow() {
      // NOTE: not a permanent solution
      //       consider disable "now" button in the future
      if (!this.disabledNow) {
        const now = new Date();
        this.date = now;
        this.time = now;
        if (this.type === 'week') {
          const week = this.date.getDay();
          const dayOffset = week + this.weekOffsetDay;
          this.date = prevDate(this.date, dayOffset);
        }
        if (this.timePickerVisible) {
          this.$nextTick(() => this.$refs.timepicker.adjustSpinners());
        }
        this.emit(this.date, true, false);
      }
    },
    confirm() {
      if (this.selectionMode === 'dates') {
        this.emit(this.value, false, true);
      } else {
        // value were emitted in handle{Date,Time}Pick, nothing to update here
        // deal with the scenario where: user opens the picker, then confirm without doing anything
        this.emit(this.getTime(), false, true);
      }
    },
    getSingleValue() {
      let value = this.value;
      if (Array.isArray(value)) {
        value = value[this.value.length - 1];
      }
      return value;
    },
    getTime() {
      const value = this.getSingleValue();
      let newValue = value || this.getDefaultValue();
      if (this.time) {
        newValue = dateMergeTime(newValue, this.time);
      }
      if (this.selectionMode === 'week') {
        newValue = this.$refs.dateTable.weekDate;
      }
      return newValue;
    },
    getDate() {
      if (this.type === 'datetime') {
        return this.getTime();
      } else {
        return clearTime(this.getTime());
      }
    },
    resetView() {
      this.date = this.getDate();
      this.time = isDate(this.value) ? this.getTime() : null;
    },
    handleEnter() {
      document.body.addEventListener('keydown', this.handleKeydown);
    },
    handleLeave() {
      this.$emit('dodestroy');
      document.body.removeEventListener('keydown', this.handleKeydown);
    },
    handleKeydown(event) {
      if (this.selectionMode === 'dates') {
        return;
      }
      const keyCode = event.keyCode;
      const list = [38, 40, 37, 39];
      if (this.showTime && this.timePickerVisible) {
        this.$refs.timepicker.handleKeydown(event);
      }
      if (this.visible && !this.timePickerVisible) {
        if (list.indexOf(keyCode) !== -1) {
          this.handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }
        if (keyCode === 13 && this.userInputDate === null && this.userInputTime === null) {
          // Enter
          this.emit(this.date, false);
        }
      }
    },
    setSelectionRange(start, end) {
      this.refInput.setSelectionRange(start, end);
      this.refInput.focus();
    },
    handleKeyControl(keyCode) {
      const mapping = {
        year: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date, step) => setYear(date, date.getFullYear() + step)
        },
        month: {
          38: -6,
          40: 6,
          37: -1,
          39: 1,
          offset: (date, step) => setMonth(date, date.getMonth() + step)
        },
        week: {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: (date, step) => setDate(date, date.getDate() + step * 7)
        },
        day: {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: (date, step) => setDate(date, date.getDate() + step)
        }
      };
      const mode = this.selectionMode;
      const year = 3.1536e10;
      const now = this.date.getTime();
      const newDate = new Date(this.date.getTime());
      while (Math.abs(now - newDate.getTime()) <= year) {
        const map = mapping[mode];
        map.offset(newDate, map[keyCode]);
        if (this.disabledDate(newDate)) {
          continue;
        }
        this.date = newDate;
        this.emit(newDate, true);
        break;
      }
    },
    handleVisibleTimeBlur() {
      this.userInputTime = null;
    },
    handleVisibleTimeChange(value) {
      const time = parseDate(value, this.timeFormat);
      if (time && this.checkDateWithinRange(time)) {
        this.time = modifyDate(time, this.year, this.month, this.monthDate);
        this.userInputTime = null;
        this.$refs.timepicker.value = this.time;
        this.emit(this.time, true, false);
      }
    },
    // handleVisibleDateChange(value) {
    //   const date = parseDate(value, this.dateFormat);
    //   if (date) {
    //     if (
    //       typeof this.disabledDate === 'function' &&
    //       this.disabledDate(date)
    //     ) {
    //       return;
    //     }
    //     this.date = modifyTime(
    //       date,
    //       this.date.getHours(),
    //       this.date.getMinutes(),
    //       this.date.getSeconds()
    //     );
    //     this.userInputDate = null;
    //     this.resetView();
    //     this.emit(this.date, true);
    //   }
    // },

    isValidValue(value) {
      if (Array.isArray(value)) {
        return value.every(item => isDate(item) && !this.disabledDate(item));
      } else {
        return isDate(value) && !this.disabledDate(value) && this.checkDateWithinRange(value);
      }
    },
    getDatesValue() {
      let value = this.value;
      if (Array.isArray(value)) {
        value = value[this.value.length - 1];
      }
      return value;
    },
    getDefaultValue() {
      let nowDate = util_now();
      if (this.selectionMode === 'dates') {
        nowDate = this.getDatesValue() || nowDate;
      }
      // if default-value is set, return it
      // otherwise, return now (the moment this method gets called)
      return this.defaultValue ? modifyWithTimeString(clearTime(toDate(this.defaultValue)), this.defaultTime) : modifyWithTimeString(nowDate, this.defaultTime);
    },
    checkDateWithinRange(date) {
      return this.selectableRange.length > 0 ? timeWithinRange(date, this.selectableRange, this.format || 'HH:mm:ss') : true;
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_datevue_type_script_lang_js_ = (datevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue





/* normalize component */

var date_component = normalizeComponent(
  panel_datevue_type_script_lang_js_,
  datevue_type_template_id_753e8fa0_render,
  datevue_type_template_id_753e8fa0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var panel_date = (date_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=68d045c4&
var date_rangevue_type_template_id_68d045c4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-bottom"},on:{"after-enter":_vm.handleEnter,"after-leave":_vm.handleLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-range-picker el-popper",class:[
      {
        'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts,
        'has-time': _vm.showTime
      },
      _vm.popperClass
    ]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_vm._t("sidebar"),(_vm.shortcuts)?_c('div',{staticClass:"el-picker-panel__sidebar"},_vm._l((_vm.shortcuts),function(shortcut,key){return _c('button',{key:key,staticClass:"el-picker-panel__shortcut",attrs:{"type":"button"},domProps:{"textContent":_vm._s(shortcut.text)},on:{"click":function($event){return _vm.handleShortcutClick(shortcut)}}})}),0):_vm._e(),_c('div',{staticClass:"el-picker-panel__body is-date-range"},[_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-left"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.startTime'))}}),_c('div',{ref:"leftPickerHeader",staticClass:"el-date-range-picker__header"},[_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",attrs:{"type":"button"},on:{"click":_vm.leftPrevYear}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.leftCurrentView !== 'year'),expression:"leftCurrentView !== 'year'"}],staticClass:"el-picker-panel__icon-btn h-icon-angle_left_sm",attrs:{"type":"button"},on:{"click":_vm.leftPrevMonth}}),(_vm.isUnlinkRange)?_c('span',{staticClass:"el-picker-panel__header-label-wrapper",class:[("is-" + _vm.leftCurrentView), { 'is-en': _vm.isEn }]},[_c('span',{staticClass:"el-picker-panel__header-label",attrs:{"title":_vm.leftYearLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.leftYearLabel)},on:{"click":function($event){return _vm.showYearPicker('left')}}}),_c('span',{directives:[{name:"show",rawName:"v-show",value:(
                  _vm.leftCurrentView === 'date' || _vm.leftCurrentView === 'month'
                ),expression:"\n                  leftCurrentView === 'date' || leftCurrentView === 'month'\n                "}],staticClass:"el-picker-panel__header-label",attrs:{"title":_vm.leftMonthLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.leftMonthLabel)},on:{"click":function($event){return _vm.showMonthPicker('left')}}})]):_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.leftLabel)}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.leftCurrentView !== 'year'),expression:"leftCurrentView !== 'year'"}],staticClass:"el-picker-panel__icon-btn h-icon-angle_right_sm",class:{
                'is-disabled': !_vm.enableMonthArrow,
                'is-hide': !_vm.unlinkPanels && _vm.leftCurrentView === 'date'
              },attrs:{"disabled":!_vm.enableMonthArrow,"type":"button"},on:{"click":_vm.leftNextMonth}}),_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",class:{
                'is-disabled': !_vm.enableMonthArrow,
                'is-hide': !_vm.unlinkPanels && _vm.leftCurrentView === 'date'
              },attrs:{"disabled":!_vm.enableMonthArrow,"type":"button"},on:{"click":_vm.leftNextYear}})]),_c('div',{staticClass:"el-picker-panel__content has-modal"},[_c('date-table',{attrs:{"date":_vm.leftDate,"unlink-range":_vm.isUnlinkRange,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"first-day-of-week":_vm.firstDayOfWeek,"date-class-render":_vm.dateClassRender,"selection-mode":"range","table-type":"min"},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick},scopedSlots:_vm._u([{key:!!(_vm.$slots.date || _vm.$scopedSlots.date) ? 'date' : null,fn:function(data){return [_vm._t("date",null,null,data)]}},{key:!!(_vm.$slots.startDate || _vm.$scopedSlots.startDate)
                    ? 'startDate'
                    : null,fn:function(data){return [_vm._t("startDate",null,null,data)]}}],null,true)}),(_vm.leftCurrentView === 'year')?_c('year-table',{ref:"leftYearTable",attrs:{"date":_vm.leftDate,"value":_vm.minDate,"default-value":_vm.defaultValue ? _vm.getDefaultValue(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType,"table-type":"min"},on:{"pick":_vm.handleLeftYearPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.year || _vm.$scopedSlots.year) ? 'year' : null,fn:function(data){return [_vm._t("year",null,null,data)]}},{key:!!(_vm.$slots.startYear || _vm.$scopedSlots.startYear)
                    ? 'startYear'
                    : null,fn:function(data){return [_vm._t("startYear",null,null,data)]}}],null,true)}):_vm._e(),(_vm.leftCurrentView === 'month')?_c('month-table',{ref:"leftMonthTable",attrs:{"date":_vm.leftDate,"value":_vm.minDate,"disabled-date":_vm.disabledDate,"table-type":"min"},on:{"pick":_vm.handleLeftMonthPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.month || _vm.$scopedSlots.month) ? 'month' : null,fn:function(data){return [_vm._t("month",null,null,data)]}},{key:!!(_vm.$slots.startMonth || _vm.$scopedSlots.startMonth)
                    ? 'startMonth'
                    : null,fn:function(data){return [_vm._t("startMonth",null,null,data)]}}],null,true)}):_vm._e()],1)]),_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-right"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.endTime'))}}),_c('div',{ref:"rightPickerHeader",staticClass:"el-date-range-picker__header"},[_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",class:{
                'is-disabled': !_vm.enableMonthArrow,
                'is-hide': !_vm.unlinkPanels && _vm.rightCurrentView === 'date'
              },attrs:{"disabled":!_vm.enableMonthArrow,"type":"button"},on:{"click":_vm.rightPrevYear}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.rightCurrentView !== 'year'),expression:"rightCurrentView !== 'year'"}],staticClass:"el-picker-panel__icon-btn h-icon-angle_left_sm",class:{
                'is-disabled': !_vm.enableMonthArrow,
                'is-hide': !_vm.unlinkPanels && _vm.rightCurrentView === 'date'
              },attrs:{"disabled":!_vm.enableMonthArrow,"type":"button"},on:{"click":_vm.rightPrevMonth}}),(_vm.isUnlinkRange)?_c('span',{staticClass:"el-picker-panel__header-label-wrapper",class:[("is-" + _vm.rightCurrentView), { 'is-en': _vm.isEn }]},[_c('span',{staticClass:"el-picker-panel__header-label",attrs:{"title":_vm.rightYearLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.rightYearLabel)},on:{"click":function($event){return _vm.showYearPicker('right')}}}),_c('span',{directives:[{name:"show",rawName:"v-show",value:(
                  _vm.rightCurrentView === 'date' || _vm.rightCurrentView === 'month'
                ),expression:"\n                  rightCurrentView === 'date' || rightCurrentView === 'month'\n                "}],staticClass:"el-picker-panel__header-label",attrs:{"title":_vm.rightMonthLabel,"role":"button"},domProps:{"textContent":_vm._s(_vm.rightMonthLabel)},on:{"click":function($event){return _vm.showMonthPicker('right')}}})]):_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.rightLabel)}}),_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.rightCurrentView !== 'year'),expression:"rightCurrentView !== 'year'"}],staticClass:"el-picker-panel__icon-btn h-icon-angle_right_sm",attrs:{"type":"button"},on:{"click":_vm.rightNextMonth}}),_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",attrs:{"type":"button"},on:{"click":_vm.rightNextYear}})]),_c('div',{staticClass:"el-picker-panel__content has-modal"},[_c('date-table',{attrs:{"date":_vm.rightDate,"unlink-range":_vm.isUnlinkRange,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"first-day-of-week":_vm.firstDayOfWeek,"date-class-render":_vm.dateClassRender,"selection-mode":"range","table-type":"max"},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick},scopedSlots:_vm._u([{key:!!(_vm.$slots.date || _vm.$scopedSlots.date) ? 'date' : null,fn:function(data){return [_vm._t("date",null,null,data)]}},{key:!!(_vm.$slots.endDate || _vm.$scopedSlots.endDate)
                    ? 'endDate'
                    : null,fn:function(data){return [_vm._t("endDate",null,null,data)]}}],null,true)}),(_vm.rightCurrentView === 'year')?_c('year-table',{ref:"rightYearTable",attrs:{"date":_vm.rightDate,"value":_vm.maxDate,"default-value":_vm.defaultValue ? _vm.getDefaultValue(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType,"table-type":"max"},on:{"pick":_vm.handleRightYearPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.year || _vm.$scopedSlots.year) ? 'year' : null,fn:function(data){return [_vm._t("year",null,null,data)]}},{key:!!(_vm.$slots.endYear || _vm.$scopedSlots.endYear)
                    ? 'endYear'
                    : null,fn:function(data){return [_vm._t("endYear",null,null,data)]}}],null,true)}):_vm._e(),(_vm.rightCurrentView === 'month')?_c('month-table',{ref:"rightMonthTable",attrs:{"date":_vm.rightDate,"value":_vm.maxDate,"disabled-date":_vm.disabledDate,"table-type":"max"},on:{"pick":_vm.handleRightMonthPick},scopedSlots:_vm._u([{key:!!(_vm.$slots.month || _vm.$scopedSlots.month) ? 'month' : null,fn:function(data){return [_vm._t("month",null,null,data)]}},{key:!!(_vm.$slots.endMonth || _vm.$scopedSlots.endMonth)
                    ? 'endMonth'
                    : null,fn:function(data){return [_vm._t("endMonth",null,null,data)]}}],null,true)}):_vm._e()],1)]),(_vm.showTime)?_c('div',{staticClass:"el-date-range-picker__time-header"},[_c('span',{staticClass:"el-date-range-picker__editors-wrap is-left"},[_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('span',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:({
                  fn: _vm.handleMinTimeClose,
                  excludes: _vm.$refs.changeToNow ? [_vm.$refs.changeToNow.$el] : []
                }),expression:"{\n                  fn: handleMinTimeClose,\n                  excludes: $refs.changeToNow ? [$refs.changeToNow.$el] : []\n                }"}]},[_c('el-input',{ref:"minInput",staticClass:"el-date-range-picker__editor",attrs:{"disabled":_vm.rangeState.selecting,"placeholder":_vm.t('el.datepicker.startTime'),"value":_vm.minVisibleTime,"maxlength":"10"},on:{"focus":function($event){_vm.minTimePickerVisible = true},"blur":function($event){return _vm.handleVisibleTimeBlur('min')},"input":function (val) { return _vm.handleTimeInput(val, 'min'); },"change":function (val) { return _vm.handleTimeChange(val, 'min'); }}}),_c('time-picker',{ref:"minTimePicker",attrs:{"unlink-range":_vm.unlink,"unlink":false,"time-arrow-control":_vm.arrowControl,"visible":_vm.minTimePickerVisible,"time-type":"min"},on:{"pick":_vm.handleMinTimePick,"mounted":function($event){return _vm.proxyTimePickerDataProperties('min')},"select-range":_vm.setSelectionRange}})],1)])]),_c('span',{staticClass:"el-date-range-picker__editors-wrap is-right"},[_c('span',{staticClass:"el-date-range-picker__time-picker-wrap"},[_c('span',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:({
                  fn: _vm.handleMaxTimeClose,
                  excludes: _vm.$refs.changeToNow ? [_vm.$refs.changeToNow.$el] : []
                }),expression:"{\n                  fn: handleMaxTimeClose,\n                  excludes: $refs.changeToNow ? [$refs.changeToNow.$el] : []\n                }"}]},[_c('el-input',{ref:"maxInput",staticClass:"el-date-range-picker__editor",attrs:{"disabled":_vm.rangeState.selecting,"placeholder":_vm.t('el.datepicker.endTime'),"value":_vm.maxVisibleTime,"maxlength":"10"},on:{"focus":function($event){_vm.maxTimePickerVisible = true},"blur":function($event){return _vm.handleVisibleTimeBlur('max')},"input":function (val) { return _vm.handleTimeInput(val, 'max'); },"change":function (val) { return _vm.handleTimeChange(val, 'max'); }}}),_c('time-picker',{ref:"maxTimePicker",attrs:{"unlink-range":_vm.unlink,"unlink":false,"time-arrow-control":_vm.arrowControl,"visible":_vm.maxTimePickerVisible,"time-type":"max"},on:{"pick":_vm.handleMaxTimePick,"mounted":function($event){return _vm.proxyTimePickerDataProperties('max')},"select-range":_vm.setSelectionRange}})],1)])])]):_vm._e()])],2),(_vm.unlink || _vm.showTime)?_c('div',{staticClass:"el-picker-panel__footer"},[(!_vm.showPrompt || _vm.showAbnormalInfo)?_c('span',{staticClass:"el-picker-panel__footer-message is-warning",attrs:{"title":_vm.prompt},domProps:{"textContent":_vm._s(_vm.prompt)}}):(
          _vm.minVisibleDate !== '' &&
            _vm.minVisibleTime !== '' &&
            _vm.maxVisibleDate !== '' &&
            _vm.maxVisibleTime !== ''
        )?_c('span',{staticClass:"el-picker-panel__footer-message",attrs:{"title":(_vm.minVisibleDate + " " + (_vm.showTime ? _vm.minVisibleTime : '') + " " + _vm.rangeSeparator + " " + _vm.maxVisibleDate + " " + (_vm.showTime ? _vm.maxVisibleTime : ''))}},[_c('span',{domProps:{"textContent":_vm._s(_vm.minVisibleDate)}}),(_vm.showTime)?_c('span',{domProps:{"textContent":_vm._s(_vm.minVisibleTime)}}):_vm._e(),_c('span',{domProps:{"textContent":_vm._s(_vm.rangeSeparator)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.maxVisibleDate)}}),(_vm.showTime)?_c('span',{domProps:{"textContent":_vm._s(_vm.maxVisibleTime)}}):_vm._e()]):_c('span',{staticClass:"el-picker-panel__footer-message"}),(!_vm.disabledNow)?_c('el-button',{ref:"changeToNow",staticClass:"el-picker-panel__link-btn el-picker-panel__now",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.today'))},on:{"click":_vm.changeToNow}}):_vm._e(),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"disabled":_vm.disabledConfirm,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":function($event){return _vm.handleConfirm(false)}}})],1):_vm._e()])])}
var date_rangevue_type_template_id_68d045c4_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=68d045c4&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//












const calcDefaultValue = defaultValue => {
  if (Array.isArray(defaultValue)) {
    return [toDate(defaultValue[0]), toDate(defaultValue[1])];
  } else if (defaultValue) {
    return [toDate(defaultValue), nextDate(toDate(defaultValue), 1)];
  } else {
    return [util_now(), nextDate(util_now(), 1)];
  }
};
/* harmony default export */ var date_rangevue_type_script_lang_js_ = ({
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    TimePicker: panel_time,
    DateTable: date_table,
    ElInput: packages_input,
    ElButton: packages_button,
    YearTable: year_table,
    MonthTable: month_table
  },
  mixins: [locale, mixins_range],
  data() {
    return {
      closeOnClickModal: true,
      popperClass: '',
      value: [],
      defaultValue: null,
      defaultTime: null,
      minDate: util_now(),
      maxDate: util_now(),
      leftDate: util_now(),
      rightDate: util_now(),
      rangeState: {
        endDate: null,
        selecting: false,
        row: null,
        column: null
      },
      showTime: false,
      shortcuts: '',
      visible: '',
      disabledDate: () => {
        return false;
      },
      dateClassRender: null,
      firstDayOfWeek: 1,
      minTimePickerVisible: false,
      maxTimePickerVisible: false,
      format: '',
      arrowControl: false,
      unlinkPanels: false,
      unlink: true,
      unlinkRange: true,
      dateUserInput: {
        min: null,
        max: null
      },
      timeUserInput: {
        min: null,
        max: null
      },
      rangeSeparator: '-',
      startPlaceholder: '',
      endPlaceholder: '',
      leftCurrentView: 'date',
      rightCurrentView: 'date',
      leftFirstVisibleTime: true,
      rightFirstVisibleTime: true,
      selectableRange: [],
      calendarType: ''
    };
  },
  computed: {
    isEn() {
      const reg = /^[a-zA-Z]+$/;
      return reg.test(this.leftMonthLabel) || reg.test(this.rightMonthLabel);
    },
    now: () => util_now(),
    calcMinDate() {
      const minDate = this.minDate || calcDefaultValue(this.defaultValue)[0];
      return toDate(minDate);
    },
    calcMaxDate() {
      const maxDate = this.maxDate || calcDefaultValue(this.defaultValue)[1];
      return toDate(maxDate);
    },
    disabledNow() {
      const start = dateMergeTime(this.now, MIN_TIME);
      const end = dateMergeTime(this.now, MAX_TIME);
      return this.disabledDate(start) || this.disabledDate(end);
    },
    leftLabel() {
      return this.leftDate.getFullYear() + this.offsetYear + this.t('el.datepicker.year') + ' ' + this.t(`el.datepicker.month${this.leftDate.getMonth() + 1}`);
    },
    rightLabel() {
      return this.rightDate.getFullYear() + this.offsetYear + this.t('el.datepicker.year') + ' ' + this.t(`el.datepicker.month${this.rightDate.getMonth() + 1}`);
    },
    leftYearLabel() {
      const yearTranslation = this.t('el.datepicker.year');
      if (this.leftCurrentView === 'year') {
        const startYear = Math.floor(this.leftDate.getFullYear() / 10) * 10;
        if (yearTranslation) {
          return startYear + this.offsetYear + yearTranslation + ' - ' + (startYear + this.offsetYear + 9) + yearTranslation;
        }
        return startYear + this.offsetYear + ' - ' + (startYear + this.offsetYear + 9);
      }
      return (this.leftCurrentView === 'year' ? this.calcMinDate.getFullYear() : this.leftYearVal) + this.offsetYear + yearTranslation;
    },
    leftMonthLabel() {
      return this.t(`el.datepicker.month${this.leftDate.getMonth() + 1}`);
    },
    rightYearLabel() {
      const yearTranslation = this.t('el.datepicker.year');
      if (this.rightCurrentView === 'year') {
        const startYear = Math.floor(this.rightDate.getFullYear() / 10) * 10;
        if (yearTranslation) {
          return startYear + this.offsetYear + ' ' + yearTranslation + ' - ' + (startYear + this.offsetYear + 9) + yearTranslation;
        }
        return startYear + this.offsetYear + ' - ' + (startYear + this.offsetYear + 9);
      }
      return (this.rightCurrentView === 'year' ? this.calcMaxDate.getFullYear() : this.rightYearVal) + this.offsetYear + yearTranslation;
    },
    rightMonthLabel() {
      return this.t(`el.datepicker.month${this.rightDate.getMonth() + 1}`);
    },
    leftYearVal() {
      return this.leftDate.getFullYear();
    },
    leftMonthVal() {
      return this.leftDate.getMonth();
    },
    leftDateVal() {
      return this.leftDate.getDate();
    },
    rightYearVal() {
      return this.rightDate.getFullYear();
    },
    rightMonthVal() {
      return this.rightDate.getMonth();
    },
    rightDateVal() {
      return this.rightDate.getDate();
    },
    minVisibleDate() {
      if (this.dateUserInput.min !== null) {
        return this.dateUserInput.min;
      }
      if (this.minDate) {
        return formatDate(this.minDate, this.dateFormat, this.calendarType);
      }
      return '';
    },
    maxVisibleDate() {
      if (this.dateUserInput.max !== null) {
        return this.dateUserInput.max;
      }
      if (this.maxDate) {
        return formatDate(this.maxDate || this.minDate, this.dateFormat, this.calendarType);
      }
      return '';
    },
    minVisibleTime() {
      if (this.timeUserInput.min !== null) {
        return this.timeUserInput.min;
      } else if (util_isEmpty(this.minDate) && this.leftFirstVisibleTime && !this.defaultTime) {
        return '';
      } else if (this.leftDate) {
        return formatDate(this.leftDate, this.timeFormat);
      }
      return '';
    },
    maxVisibleTime() {
      if (this.timeUserInput.max !== null) {
        return this.timeUserInput.max;
      } else if (util_isEmpty(this.maxDate) && this.rightFirstVisibleTime && !this.defaultTime) {
        return '';
      } else if (this.rightDate) {
        return formatDate(this.rightDate, this.timeFormat);
      }
      return '';
    },
    timeFormat() {
      if (this.format) {
        return extractTimeFormat(this.format);
      } else {
        return 'HH:mm:ss';
      }
    },
    dateFormat() {
      if (this.format) {
        return extractDateFormat(this.format);
      } else {
        return 'yyyy/MM/dd';
      }
    },
    enableMonthArrow() {
      if (!this.unlink) {
        const nextMonth = (this.leftMonthVal + (this.unlink ? 0 : 1)) % 12;
        const yearOffset = this.leftMonthVal + (this.unlink ? 0 : 1) >= 12 ? 1 : 0;
        return this.isUnlinkRange && toDate(this.leftYearVal + yearOffset, nextMonth) < toDate(this.rightYearVal, this.rightMonthVal);
      } else {
        return true;
      }
    },
    enableYearArrow() {
      return this.isUnlinkRange && this.rightYearVal * 12 + this.rightMonthVal - (this.leftYearVal * 12 + this.leftMonthVal + (this.unlink ? 0 : 1)) >= 12 || this.leftCurrentView === 'year';
    },
    showAbnormalInfo() {
      if (this.isUnlinkRange && this.minDate && this.maxDate) {
        if (this.showTime) {
          return clearMilliseconds(this.leftDate).getTime() > clearMilliseconds(this.rightDate).getTime();
        } else {
          return clearTime(this.leftDate).getTime() > clearTime(this.rightDate).getTime();
        }
      }
      return false;
    },
    minRefInput() {
      if (this.$refs.minInput.$el) {
        return [].slice.call(this.$refs.minInput.$el.querySelectorAll('input'))[0];
      }
      return [];
    },
    maxRefInput() {
      if (this.$refs.maxInput.$el) {
        return [].slice.call(this.$refs.maxInput.$el.querySelectorAll('input'))[0];
      }
      return [];
    },
    minTimeEmpty() {
      if (!this.isUnlinkRange) {
        return false;
      }
      return isEmptyDate(this.value) && isEmptyDate(this.defaultTime);
    },
    maxTimeEmpty() {
      if (!this.isUnlinkRange) {
        return false;
      }
      return isEmptyDate(this.value) && isEmptyDate(this.defaultTime);
    },
    emitDate() {
      return [this.leftDate, this.rightDate];
    },
    offsetYear() {
      return src_util_getOffset(this.calendarType);
    }
  },
  watch: {
    visible(val) {
      if (!val) {
        this.closeModal();
      }
    },
    minDate(val) {
      this.dateUserInput.min = null;
      this.timeUserInput.min = null;
      if (isDate(val) && this.$refs.minTimePicker) {
        this.$refs.minTimePicker.date = val;
        this.$refs.minTimePicker.value = val;
      }
    },
    maxDate(val) {
      this.dateUserInput.max = null;
      this.timeUserInput.max = null;
      if (isDate(val) && this.$refs.maxTimePicker) {
        this.$refs.maxTimePicker.date = val;
        this.$refs.maxTimePicker.value = val;
      }
    },
    minTimePickerVisible(val) {
      if (val) {
        this.$refs.minTimePicker.date = this.minDate || this.leftDate;
        this.$refs.minTimePicker.value = this.minDate || this.leftDate;
        this.$nextTick(() => {
          this.$refs.minTimePicker.adjustSpinners();
          this.openModal(this._popupLeftId, this.$refs.leftPickerHeader, 'is-time');
        });
      } else {
        popup_manager.closeModal(this._popupLeftId);
      }
    },
    maxTimePickerVisible(val) {
      if (val) {
        this.$refs.maxTimePicker.date = this.maxDate || this.rightDate;
        this.$refs.maxTimePicker.value = this.maxDate || this.rightDate;
        this.$nextTick(() => {
          this.$refs.maxTimePicker.adjustSpinners();
          this.openModal(this._popupRightId, this.$refs.rightPickerHeader, 'is-time');
        });
      } else {
        popup_manager.closeModal(this._popupRightId);
      }
    },
    value(newVal) {
      if (!newVal) {
        this.minDate = this.now;
        this.maxDate = this.now;
      } else if (Array.isArray(newVal)) {
        this.minDate = toDate(newVal[0]);
        this.maxDate = toDate(newVal[1]);
      }
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
    },
    defaultValue(val) {
      if (!Array.isArray(this.value)) {
        const [leftDate, rightDate] = calcDefaultValue(val);
        this.leftDate = leftDate;
        this.rightDate = this.getDefaultRightDate(rightDate);
      }
    }
  },
  beforeMount() {
    this._popupLeftId = `popup-date-range-left-${this._uid}`;
    this._popupRightId = `popup-date-range-right-${this._uid}`;
    popup_manager.register(this._popupLeftId, this);
    popup_manager.register(this._popupRightId, this);
  },
  beforeDestroy() {
    popup_manager.deregister(this._popupLeftId, this);
    popup_manager.deregister(this._popupRightId, this);
    this.closeModal();
  },
  methods: {
    getDefaultValue(val) {
      return calcDefaultValue(val);
    },
    proxyTimePickerDataProperties(type) {
      const ref = type === 'min' ? 'minTimePicker' : 'maxTimePicker';
      const format = timeFormat => {
        this.$refs[ref].format = timeFormat;
      };
      const selectableRange = selectableRange => {
        this.$refs[ref].selectableRange = selectableRange;
      };
      this.$watch('timeFormat', format);
      this.$watch('selectableRange', selectableRange);
      format(this.timeFormat);
      selectableRange(this.selectableRange);
    },
    getDefaultRightDate(val) {
      const minDateYear = this.calcMinDate.getFullYear();
      const minDateMonth = this.calcMinDate.getMonth();
      const maxDateYear = this.calcMaxDate.getFullYear();
      const maxDateMonth = this.calcMaxDate.getMonth();
      const toNext = minDateYear === maxDateYear && minDateMonth === maxDateMonth;
      if (!this.isUnlinkRange && toNext) {
        return util_nextMonth(val);
      } else {
        return val;
      }
    },
    handleLeftYearPick(year) {
      this.leftDate = setYear(this.leftDate, year);
      this.leftCurrentView = 'date';
      this.setLeftValue();
      this.emit(this.emitDate, true);
      popup_manager.closeModal(this._popupLeftId);
    },
    handleLeftMonthPick(month) {
      this.leftDate = setYear(this.leftDate, this.leftDate.getFullYear());
      this.leftDate = setMonth(this.leftDate, month);
      this.leftCurrentView = 'date';
      this.setLeftValue();
      this.emit(this.emitDate, true);
      popup_manager.closeModal(this._popupLeftId);
    },
    handleRightYearPick(year) {
      this.rightDate = setYear(this.rightDate, year);
      this.rightCurrentView = 'date';
      this.setRightValue();
      this.emit(this.emitDate, true);
      popup_manager.closeModal(this._popupRightId);
    },
    handleRightMonthPick(month) {
      this.rightDate = setYear(this.rightDate, this.rightDate.getFullYear());
      this.rightDate = setMonth(this.rightDate, month);
      this.rightCurrentView = 'date';
      this.setRightValue();
      this.emit(this.emitDate, true);
      popup_manager.closeModal(this._popupRightId);
    },
    openModal(id, dom, cls) {
      popup_manager.openModal({
        id: id,
        zIndex: 10,
        dom: dom,
        modalClass: cls,
        modalFade: true,
        multiModal: true
      });
    },
    closeLeftModal() {
      popup_manager.closeModal(this._popupLeftId);
      this.leftCurrentView = 'date';
    },
    closeRightModal() {
      popup_manager.closeModal(this._popupRightId);
      this.rightCurrentView = 'date';
    },
    closeModal() {
      this.closeLeftModal();
      this.closeRightModal();
    },
    close(id) {
      if (id.indexOf('popup-date-range-left') !== -1) {
        this.leftCurrentView = 'date';
      } else {
        this.rightCurrentView = 'date';
      }
      popup_manager.closeModal(id);
    },
    showYearPicker(pos) {
      if (pos === 'left') {
        this.closeRightModal();
        this.leftCurrentView = 'year';
        this.$nextTick(() => {
          this.openModal(this._popupLeftId, this.$refs.leftYearTable.$el, 'is-year');
        });
      } else {
        this.closeLeftModal();
        this.rightCurrentView = 'year';
        this.$nextTick(() => {
          this.openModal(this._popupRightId, this.$refs.rightYearTable.$el, 'is-year');
        });
      }
    },
    showMonthPicker(pos) {
      if (pos === 'left') {
        this.closeRightModal();
        this.leftCurrentView = 'month';
        this.$nextTick(() => {
          this.openModal(this._popupLeftId, this.$refs.leftMonthTable.$el, 'is-month');
        });
      } else {
        this.closeLeftModal();
        this.rightCurrentView = 'month';
        this.$nextTick(() => {
          this.openModal(this._popupRightId, this.$refs.rightMonthTable.$el, 'is-month');
        });
      }
    },
    changeToNow() {
      this.closeModal();
      const start = dateMergeTime(util_now(), MIN_TIME);
      const end = dateMergeTime(util_now(), MAX_TIME);
      this.minDate = start;
      this.leftDate = start;
      this.maxDate = end;
      this.rightDate = end;
      this.handleMinTimeClose();
      this.handleMaxTimeClose();
      this.emit([start, end], true);
    },
    // HUI reserved
    handleClear() {
      this.minDate = null;
      this.maxDate = null;
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
      this.emit(null);
    },
    handleChangeRange(val) {
      this.minDate = val.minDate;
      this.maxDate = val.maxDate;
      this.rangeState = val.rangeState;
    },
    /**
     * 预留手动输入日期逻辑
     */
    // handleDateInput(value, type) {
    //   this.dateUserInput[type] = value;
    //   const parsedValue = parseDate(value, this.dateFormat);
    //   if (parsedValue) {
    //     if (
    //       typeof this.disabledDate === 'function' &&
    //       this.disabledDate(toDate(parsedValue))
    //     ) {
    //       return;
    //     }
    //     if (type === 'min') {
    //       this.minDate = modifyDate(
    //         this.minDate || toDate(),
    //         parsedValue.getFullYear(),
    //         parsedValue.getMonth(),
    //         parsedValue.getDate()
    //       );
    //       this.leftDate = toDate(parsedValue);
    //       if (!this.isUnlinkRange) {
    //         this.rightDate = this.unlink
    //           ? this.leftDate
    //           : nextMonth(this.leftDate);
    //       }
    //     } else {
    //       this.maxDate = modifyDate(
    //         this.maxDate || toDate(),
    //         parsedValue.getFullYear(),
    //         parsedValue.getMonth(),
    //         parsedValue.getDate()
    //       );
    //       this.rightDate = toDate(parsedValue);
    //       if (!this.isUnlinkRange) {
    //         this.leftDate = prevMonth(parsedValue);
    //       }
    //     }
    //   }
    // },
    // handleDateChange(value, type) {
    //   const parsedValue = parseDate(value, this.dateFormat);
    //   if (parsedValue) {
    //     if (type === 'min') {
    //       this.minDate = modifyDate(
    //         this.minDate,
    //         parsedValue.getFullYear(),
    //         parsedValue.getMonth(),
    //         parsedValue.getDate()
    //       );
    //       if (this.minDate > this.maxDate) {
    //         this.maxDate = this.minDate;
    //       }
    //     } else {
    //       this.maxDate = modifyDate(
    //         this.maxDate,
    //         parsedValue.getFullYear(),
    //         parsedValue.getMonth(),
    //         parsedValue.getDate()
    //       );
    //       if (this.maxDate < this.minDate) {
    //         this.minDate = this.maxDate;
    //       }
    //     }
    //   }
    // },
    handleTimeInput(value, type) {
      const parsedValue = parseDate(value, this.timeFormat);
      if (parsedValue) {
        this.timeUserInput[type] = value;
        if (type === 'min') {
          this.minDate = toDate(this.minDate);
          this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          this.$nextTick(() => this.$refs.minTimePicker.adjustSpinners());
        } else {
          this.maxDate = toDate(this.maxDate);
          this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          this.$nextTick(() => this.$refs.maxTimePicker.adjustSpinners());
        }
      }
    },
    handleTimeChange(value, type) {
      const parsedValue = parseDate(value, this.timeFormat);
      if (parsedValue) {
        if (type === 'min') {
          this.minDate = toDate(this.minDate);
          this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          if (!this.isUnlinkRange && this.minDate > this.maxDate) {
            this.maxDate = this.minDate;
          }
          this.$refs.minTimePicker.value = this.minDate;
          this.leftDate = this.minDate;
        } else {
          this.maxDate = toDate(this.maxDate);
          this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
          if (!this.isUnlinkRange && this.maxDate < this.minDate) {
            this.minDate = this.maxDate;
          }
          this.$refs.maxTimePicker.value = this.maxDate;
          this.rightDate = this.maxDate;
        }
      }
    },
    handleVisibleTimeBlur(type) {
      this.timeUserInput[type] = null;
    },
    handleRangePick(val, {
      type,
      cell
    }) {
      this.closeModal();
      const defaultTime = this.defaultTime || [];
      this.onPick && this.onPick(val);
      let minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
      let maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
      const leftDate = minDate ? modifyDate(this.leftDate, minDate.getFullYear(), minDate.getMonth(), minDate.getDate()) : this.leftDate;
      const rightDate = maxDate ? modifyDate(this.rightDate, maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate()) : this.rightDate;
      if (this.isUnlinkRange) {
        this.leftDate = leftDate;
        this.rightDate = rightDate;
        if (type === 'min') {
          if (!this.minTimeEmpty) {
            minDate = dateMergeTime(setDate(leftDate, minDate.getDate()), leftDate);
          } else {
            minDate = setDate(leftDate, minDate.getDate());
          }
          this.minDate = minDate;
          if (defaultTime.length !== 0) {
            this.maxDate = maxDate;
          }
        } else {
          if (!this.maxTimeEmpty) {
            maxDate = dateMergeTime(setDate(rightDate, maxDate.getDate()), rightDate);
          } else {
            maxDate = setDate(rightDate, maxDate.getDate());
          }
          if (defaultTime.length !== 0) {
            this.minDate = minDate;
          }
          this.maxDate = maxDate;
        }
      } else {
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
        this.minDate = minDate;
        this.maxDate = maxDate;
      }
      if (!this.isUnlinkRange && this.showTime) {
        return;
      }
      this.handleConfirm(!!this.unlink);
    },
    handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
    },
    handleMinTimeClose() {
      this.minTimePickerVisible = false;
    },
    handleMinTimePick(value, visible, first) {
      this.leftFirstVisibleTime = false;
      const leftDate = this.minDate || this.leftDate;
      if (value) {
        const newVal = modifyTime(leftDate, value.getHours(), value.getMinutes(), value.getSeconds());
        if (this.minDate) {
          this.minDate = newVal;
        }
        this.leftDate = newVal;
      }
      if (!first) {
        this.minTimePickerVisible = visible;
      }
      if (!this.isUnlinkRange) {
        if (!this.maxDate || this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {
          this.maxDate = toDate(this.minDate);
        }
      }
      if (!this.unlink) {
        this.emit(this.emitDate, true);
      }
    },
    handleMaxTimePick(value, visible, first) {
      this.rightFirstVisibleTime = false;
      const rightDate = this.maxDate || this.rightDate;
      if (value) {
        const newVal = modifyTime(rightDate, value.getHours(), value.getMinutes(), value.getSeconds());
        if (this.maxDate) {
          this.maxDate = newVal;
        }
        this.rightDate = newVal;
      }
      if (!first) {
        this.maxTimePickerVisible = visible;
      }
      if (!this.isUnlinkRange) {
        if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {
          this.minDate = toDate(this.maxDate);
        }
      }
      if (!this.unlink) {
        this.emit(this.emitDate, true);
      }
    },
    handleMaxTimeClose() {
      this.maxTimePickerVisible = false;
    },
    // leftPrev*, rightNext* need to take care of `unlinkPanels`
    setLeftValue() {
      if (this.minDate) {
        this.minDate = this.leftDate;
      }
    },
    setRightValue() {
      if (this.maxDate) {
        this.maxDate = this.rightDate;
      }
    },
    leftPrevYear() {
      if (this.leftCurrentView === 'year') {
        this.leftDate = prevYear(this.leftDate, 10);
      } else {
        this.leftDate = prevYear(this.leftDate);
        if (!this.isUnlinkRange) {
          this.rightDate = util_nextMonth(this.leftDate);
        }
      }
      this.setLeftValue();
      this.emit(this.emitDate, true);
    },
    leftPrevMonth() {
      this.leftDate = prevMonth(this.leftDate);
      if (!this.isUnlinkRange) {
        this.rightDate = util_nextMonth(this.leftDate);
      }
      this.setLeftValue();
      this.emit(this.emitDate, true);
    },
    // leftNext*, rightPrev* are called when `unlinkPanels` is true
    leftNextYear() {
      if (this.leftCurrentView === 'year') {
        this.leftDate = nextYear(this.leftDate, 10);
      } else {
        this.leftDate = nextYear(this.leftDate);
      }
      if (!this.isUnlinkRange) {
        this.setLeftValue();
        this.emit(this.emitDate, true);
      }
    },
    leftNextMonth() {
      this.leftDate = util_nextMonth(this.leftDate);
      if (!this.isUnlinkRange) {
        this.setLeftValue();
        this.emit(this.emitDate, true);
      }
    },
    rightNextYear() {
      if (this.rightCurrentView === 'year') {
        this.rightDate = nextYear(this.rightDate, 10);
      } else {
        if (!this.isUnlinkRange) {
          this.leftDate = nextYear(this.leftDate);
          this.rightDate = util_nextMonth(this.leftDate);
        } else {
          this.rightDate = nextYear(this.rightDate);
          this.setRightValue();
          this.emit(this.emitDate, true);
        }
      }
    },
    rightNextMonth() {
      if (!this.isUnlinkRange) {
        this.leftDate = util_nextMonth(this.leftDate);
        this.rightDate = util_nextMonth(this.leftDate);
      } else {
        this.rightDate = util_nextMonth(this.rightDate);
        this.setRightValue();
        this.emit(this.emitDate, true);
      }
    },
    rightPrevYear() {
      if (this.rightCurrentView === 'year') {
        this.rightDate = prevYear(this.rightDate, 10);
      } else {
        this.rightDate = prevYear(this.rightDate);
        this.setRightValue();
        this.emit(this.emitDate, true);
      }
    },
    rightPrevMonth() {
      this.rightDate = prevMonth(this.rightDate);
      this.setRightValue();
      this.emit(this.emitDate, true);
    },
    handleConfirm(visible = false) {
      let date = [this.leftDate, this.rightDate];
      if (this.unlink) date = [this.minDate, this.maxDate];
      if (this.isValidValue(date)) {
        this.$emit('pick', date, visible);
      } else {
        this.$emit('pick', date, visible, false);
      }
    },
    emit(value, ...args) {
      if (!isEmptyDate(this.value)) {
        if (isEmptyDate(value)) {
          this.$emit('pick', null);
        } else {
          this.$emit('pick', value, ...args);
        }
      }
    },
    isValidValue(value) {
      return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && (this.showTime ? clearMilliseconds(value[0]).getTime() <= clearMilliseconds(value[1]).getTime() : clearTime(value[0]).getTime() <= clearTime(value[1]).getTime()) && !this.disabledDate(value[0]) && !this.disabledDate(value[1]);
    },
    resetView() {
      this.leftFirstVisibleTime = true;
      this.rightFirstVisibleTime = true;
      if (this.minDate && this.maxDate === null) {
        this.rangeState.selecting = false;
      }
      this.$nextTick(() => {
        if (isEmptyDate(this.value)) {
          // remove with bug 1111
          // this.minDate = null;
          // this.maxDate = null;
          const defaultValue = this.defaultValue;
          const defaultTime = this.defaultTime;
          if (defaultValue) {
            const [leftDate, rightDate] = calcDefaultValue(defaultValue);
            this.minDate = leftDate;
            this.maxDate = rightDate;
            this.leftDate = leftDate;
            this.rightDate = rightDate;
          }
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
          if (defaultTime) {
            this.leftDate = modifyWithTimeString(this.leftDate, defaultTime[0]);
            this.rightDate = modifyWithTimeString(this.rightDate, defaultTime[1]);
            this.minDate = modifyWithTimeString(this.minDate, defaultTime[0]);
            this.maxDate = modifyWithTimeString(this.maxDate, defaultTime[1]);
          }
        } else {
          this.minDate = toDate(this.value[0]);
          this.maxDate = toDate(this.value[1]);
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
        }
      });
    },
    handleEnter() {
      document.body.addEventListener('keydown', this.handleKeydown);
    },
    handleLeave() {
      this.$emit('dodestroy');
      document.body.removeEventListener('keydown', this.handleKeydown);
    },
    handleKeydown(event) {
      if (this.showTime) {
        if (this.minTimePickerVisible) {
          this.$refs.minTimePicker.handleKeydown(event);
        }
        if (this.maxTimePickerVisible) {
          this.$refs.maxTimePicker.handleKeydown(event);
        }
      }
    },
    setSelectionRange(start, end, pos) {
      if (pos === 'min') {
        this.minRefInput.setSelectionRange(start, end);
        this.minRefInput.focus();
      } else {
        this.maxRefInput.setSelectionRange(start, end);
        this.maxRefInput.focus();
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_date_rangevue_type_script_lang_js_ = (date_rangevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue





/* normalize component */

var date_range_component = normalizeComponent(
  panel_date_rangevue_type_script_lang_js_,
  date_rangevue_type_template_id_68d045c4_render,
  date_rangevue_type_template_id_68d045c4_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var date_range = (date_range_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=38ca75a1&
var month_rangevue_type_template_id_38ca75a1_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":function($event){return _vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-range-picker el-popper",class:[
      {
        'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts
      },
      _vm.popperClass
    ]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_vm._t("sidebar"),(_vm.shortcuts)?_c('div',{staticClass:"el-picker-panel__sidebar"},_vm._l((_vm.shortcuts),function(shortcut,key){return _c('button',{key:key,staticClass:"el-picker-panel__shortcut",attrs:{"type":"button"},on:{"click":function($event){return _vm.handleShortcutClick(shortcut)}}},[_vm._v(" "+_vm._s(shortcut.text)+" ")])}),0):_vm._e(),_c('div',{staticClass:"el-picker-panel__body is-month-range"},[_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-left"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.startTime'))}}),_c('div',{staticClass:"el-date-range-picker__header"},[_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",attrs:{"type":"button"},on:{"click":_vm.leftPrevYear}}),_c('span',{staticClass:"el-picker-panel__header-label-wrapper",class:[("is-" + _vm.leftCurrentView)]},[_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.leftLabel)},on:{"click":function($event){return _vm.showYearPicker('left')}}})]),(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"disabled":!_vm.enableYearArrow,"type":"button"},on:{"click":_vm.leftNextYear}}):_vm._e()]),(_vm.leftCurrentView === 'month')?_c('month-table',{attrs:{"date":_vm.leftDate,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"value":_vm.minDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"unlink-range":_vm.isUnlinkRange,"selection-mode":"range","table-type":"min"},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick},scopedSlots:_vm._u([{key:!!(_vm.$slots.month || _vm.$scopedSlots.month) ? 'month' : null,fn:function(data){return [_vm._t("month",null,null,data)]}},{key:!!(_vm.$slots.startMonth || _vm.$scopedSlots.startMonth)
                  ? 'startMonth'
                  : null,fn:function(data){return [_vm._t("startMonth",null,null,data)]}}],null,true)}):_vm._e(),_c('div',{staticClass:"el-picker-panel__content has-modal"},[(_vm.leftCurrentView === 'year')?_c('year-table',{ref:"leftYearTable",attrs:{"date":_vm.leftDate,"value":_vm.minDate,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType},on:{"pick":_vm.handleLeftYearPick}}):_vm._e()],1)],1),_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-right"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.endTime'))}}),_c('div',{staticClass:"el-date-range-picker__header"},[(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"disabled":!_vm.enableYearArrow,"type":"button"},on:{"click":_vm.rightPrevYear}}):_vm._e(),_c('span',{staticClass:"el-picker-panel__header-label-wrapper",class:[("is-" + _vm.rightCurrentView)]},[_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.rightLabel)},on:{"click":function($event){return _vm.showYearPicker('right')}}})]),_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",attrs:{"type":"button"},on:{"click":_vm.rightNextYear}})]),(_vm.rightCurrentView === 'month')?_c('month-table',{attrs:{"date":_vm.rightDate,"default-value":_vm.defaultValue,"min-date":_vm.minDate,"max-date":_vm.maxDate,"value":_vm.maxDate,"range-state":_vm.rangeState,"disabled-date":_vm.disabledDate,"unlink-range":_vm.isUnlinkRange,"selection-mode":"range","table-type":"max"},on:{"changerange":_vm.handleChangeRange,"pick":_vm.handleRangePick},scopedSlots:_vm._u([{key:!!(_vm.$slots.month || _vm.$scopedSlots.month) ? 'month' : null,fn:function(data){return [_vm._t("month",null,null,data)]}},{key:!!(_vm.$slots.endMonth || _vm.$scopedSlots.endMonth)
                  ? 'endMonth'
                  : null,fn:function(data){return [_vm._t("endMonth",null,null,data)]}}],null,true)}):_vm._e(),_c('div',{staticClass:"el-picker-panel__content has-modal"},[(_vm.rightCurrentView === 'year')?_c('year-table',{ref:"rightYearTable",attrs:{"date":_vm.rightDate,"value":_vm.maxDate,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType},on:{"pick":_vm.handleRightYearPick}}):_vm._e()],1)],1)]),(_vm.unlink)?_c('div',{staticClass:"el-picker-panel__footer"},[(!_vm.showPrompt || _vm.showAbnormalInfo)?_c('span',{staticClass:"el-picker-panel__footer-message is-warning",attrs:{"title":_vm.prompt},domProps:{"textContent":_vm._s(_vm.prompt)}}):(_vm.minVisibleMonth !== '' && _vm.maxVisibleMonth !== '')?_c('span',{staticClass:"el-picker-panel__footer-message"},[_c('span',{domProps:{"textContent":_vm._s(_vm.minVisibleMonth)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.rangeSeparator)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.maxVisibleMonth)}})]):_c('span',{staticClass:"el-picker-panel__footer-message"}),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"disabled":_vm.disabledConfirm,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":function($event){return _vm.handleConfirm(false)}}})],1):_vm._e()],2)])])}
var month_rangevue_type_template_id_38ca75a1_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=38ca75a1&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







const month_rangevue_type_script_lang_js_calcDefaultValue = defaultValue => {
  if (Array.isArray(defaultValue)) {
    return [new Date(defaultValue[0]), new Date(defaultValue[1])];
  } else if (defaultValue) {
    return [new Date(defaultValue), util_nextMonth(new Date(defaultValue))];
  } else {
    return [util_now('clearDate'), util_nextMonth(util_now('clearDate'))];
  }
};
/* harmony default export */ var month_rangevue_type_script_lang_js_ = ({
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    MonthTable: month_table,
    YearTable: year_table
  },
  mixins: [locale, mixins_range],
  data() {
    return {
      popperClass: '',
      value: [],
      defaultValue: null,
      defaultTime: null,
      minDate: util_now('clearDate'),
      maxDate: util_now('clearDate'),
      leftDate: util_now('clearDate'),
      rightDate: util_now('clearDate'),
      rangeState: {
        endDate: null,
        selecting: false,
        row: null,
        column: null
      },
      shortcuts: '',
      visible: '',
      disabledDate: () => {
        return false;
      },
      format: 'yyyy/MM',
      arrowControl: false,
      unlinkPanels: false,
      unlink: true,
      unlinkRange: true,
      rangeSeparator: '-',
      leftCurrentView: 'month',
      rightCurrentView: 'month',
      calendarType: ''
    };
  },
  computed: {
    now: () => util_now('clearDate'),
    calcMinDate() {
      const minDate = this.minDate || month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
      return toDate(minDate);
    },
    calcMaxDate() {
      const maxDate = this.maxDate || month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[1];
      return toDate(maxDate);
    },
    btnDisabled() {
      return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
    },
    leftLabel() {
      return this.leftDate.getFullYear() + src_util_getOffset(this.calendarType) + ' ' + this.t('el.datepicker.year');
    },
    rightLabel() {
      return this.rightDate.getFullYear() + src_util_getOffset(this.calendarType) + ' ' + this.t('el.datepicker.year');
    },
    leftYear() {
      return this.leftDate.getFullYear();
    },
    rightYear() {
      return this.rightDate.getFullYear() === this.leftDate.getFullYear() ? this.leftDate.getFullYear() + 1 : this.rightDate.getFullYear();
    },
    enableYearArrow() {
      if (!this.unlink) {
        return this.unlinkPanels && this.rightYear > this.leftYear + 1;
      } else {
        return true;
      }
    },
    minVisibleMonth() {
      if (this.minDate) {
        return formatDate(this.minDate, this.format, this.calendarType);
      }
      return '';
    },
    maxVisibleMonth() {
      if (this.maxDate) {
        return formatDate(this.maxDate, this.format, this.calendarType);
      }
      return '';
    },
    showAbnormalInfo() {
      if (this.isUnlinkRange) {
        if (this.minDate && this.maxDate && clearDate(this.minDate).getTime() > clearDate(this.maxDate).getTime()) {
          return true;
        }
      }
      return false;
    }
  },
  watch: {
    visible(val) {
      if (!val) {
        this.leftCurrentView = 'month';
        this.rightCurrentView = 'month';
      }
    },
    value(newVal) {
      if (!newVal) {
        this.minDate = this.now;
        this.maxDate = this.now;
      } else if (Array.isArray(newVal)) {
        this.minDate = toDate(newVal[0]);
        this.maxDate = toDate(newVal[1]);
      }
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
    },
    defaultValue(val) {
      if (!Array.isArray(this.value)) {
        const [leftDate, rightDate] = month_rangevue_type_script_lang_js_calcDefaultValue(val);
        this.leftDate = leftDate;
        this.rightDate = this.getDefaultRightDate(rightDate);
      }
    }
  },
  methods: {
    getDefaultRightDate(val) {
      const minDateYear = this.calcMinDate.getFullYear();
      const maxDateYear = this.calcMaxDate.getFullYear();
      const toNext = minDateYear === maxDateYear;
      if (!this.isUnlinkRange && toNext) {
        return nextYear(val);
      } else {
        return val;
      }
    },
    handleLeftYearPick(year) {
      this.leftDate = setYear(this.leftDate, year);
      this.leftCurrentView = 'month';
    },
    handleRightYearPick(year) {
      this.rightDate = setYear(this.rightDate, year);
      this.rightCurrentView = 'month';
    },
    showYearPicker(pos) {
      if (this.isUnlinkRange) {
        if (pos === 'left') {
          this.leftCurrentView = 'year';
        } else {
          this.rightCurrentView = 'year';
        }
      }
    },
    handleClear() {
      this.minDate = null;
      this.maxDate = null;
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
      this.$emit('pick', null);
    },
    handleChangeRange(val) {
      this.minDate = val.minDate;
      this.maxDate = val.maxDate;
      this.rangeState = val.rangeState;
    },
    handleRangePick(val, {
      type,
      cell
    }) {
      const defaultTime = this.defaultTime || [];
      const minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
      const maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
      if (this.isUnlinkRange) {
        if (type === 'min') {
          this.minDate = minDate;
          this.leftDate = minDate;
        } else {
          this.maxDate = maxDate;
          this.rightDate = maxDate;
        }
      } else {
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
        this.onPick && this.onPick(val);
        this.maxDate = maxDate;
        this.minDate = minDate;
      }
      this.handleConfirm(!!this.unlink);
    },
    handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
    },
    // leftPrev*, rightNext* need to take care of `unlinkPanels`
    leftPrevYear() {
      this.leftDate = prevYear(this.leftDate);
      if (!this.unlinkPanels) {
        this.rightDate = prevYear(this.rightDate);
      }
    },
    rightNextYear() {
      if (!this.unlinkPanels) {
        this.leftDate = nextYear(this.leftDate);
      }
      this.rightDate = nextYear(this.rightDate);
    },
    // leftNext*, rightPrev* are called when `unlinkPanels` is true
    leftNextYear() {
      this.leftDate = nextYear(this.leftDate);
    },
    rightPrevYear() {
      this.rightDate = prevYear(this.rightDate);
    },
    handleConfirm(visible = false) {
      if (this.isValidValue([this.minDate, this.maxDate])) {
        this.$emit('pick', [this.minDate, this.maxDate], visible);
      }
    },
    isValidValue(value) {
      return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && clearDate(value[0]).getTime() <= clearDate(value[1]).getTime() && !this.disabledDate(value[0]) && !this.disabledDate(value[1]);
    },
    resetView() {
      this.$nextTick(() => {
        if (isEmptyDate(this.value)) {
          this.minDate = null;
          this.maxDate = null;
          const defaultValue = this.defaultValue;
          if (defaultValue) {
            const [leftDate, rightDate] = month_rangevue_type_script_lang_js_calcDefaultValue(defaultValue);
            this.minDate = leftDate;
            this.maxDate = rightDate;
            this.leftDate = leftDate;
            this.rightDate = rightDate;
          }
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
        } else {
          this.minDate = toDate(this.value[0]);
          this.maxDate = toDate(this.value[1]);
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_month_rangevue_type_script_lang_js_ = (month_rangevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue





/* normalize component */

var month_range_component = normalizeComponent(
  panel_month_rangevue_type_script_lang_js_,
  month_rangevue_type_template_id_38ca75a1_render,
  month_rangevue_type_template_id_38ca75a1_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var month_range = (month_range_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/year-range.vue?vue&type=template&id=24df01a2&
var year_rangevue_type_template_id_24df01a2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":function($event){return _vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-picker-panel el-date-range-picker el-popper",class:[
      {
        'has-sidebar': _vm.$slots.sidebar || _vm.shortcuts
      },
      _vm.popperClass
    ]},[_c('div',{staticClass:"el-picker-panel__body-wrapper"},[_c('div',{staticClass:"el-picker-panel__body is-year-range"},[_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-left"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.startTime'))}}),_c('div',{staticClass:"el-date-range-picker__header"},[_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",attrs:{"type":"button"},on:{"click":_vm.leftPrevYear}}),_c('span',{staticClass:"el-picker-panel__header-label-wrapper is-year"},[_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.leftLabel)}})]),(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"disabled":!_vm.enableYearArrow,"type":"button"},on:{"click":_vm.leftNextYear}}):_vm._e()]),_c('year-table',{ref:"leftYearTable",attrs:{"date":_vm.leftDate,"value":_vm.minDate,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType,"unlink-range":_vm.isUnlinkRange,"selection-mode":"range","table-type":"min"},on:{"pick":_vm.handleRangePick}})],1),_c('div',{staticClass:"el-picker-panel__content el-date-range-picker__content is-right"},[_c('p',{staticClass:"el-date-range-picker__title",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.endTime'))}}),_c('div',{staticClass:"el-date-range-picker__header"},[(_vm.unlinkPanels)?_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_left_sm",class:{ 'is-disabled': !_vm.enableYearArrow },attrs:{"disabled":!_vm.enableYearArrow,"type":"button"},on:{"click":_vm.rightPrevYear}}):_vm._e(),_c('span',{staticClass:"el-picker-panel__header-label-wrapper is-year"},[_c('span',{staticClass:"el-picker-panel__header-label",domProps:{"textContent":_vm._s(_vm.rightLabel)}})]),_c('button',{staticClass:"el-picker-panel__icon-btn h-icon-angles_right_sm",attrs:{"type":"button"},on:{"click":_vm.rightNextYear}})]),_c('year-table',{ref:"rightYearTable",attrs:{"date":_vm.rightDate,"value":_vm.maxDate,"min-date":_vm.minDate,"max-date":_vm.maxDate,"range-state":_vm.rangeState,"default-value":_vm.defaultValue ? new Date(_vm.defaultValue) : null,"disabled-date":_vm.disabledDate,"calendar-type":_vm.calendarType,"unlink-range":_vm.isUnlinkRange,"selection-mode":"range","table-type":"max"},on:{"pick":_vm.handleRangePick}})],1)]),(_vm.unlink)?_c('div',{staticClass:"el-picker-panel__footer"},[(!_vm.showPrompt || _vm.showAbnormalInfo)?_c('span',{staticClass:"el-picker-panel__footer-message is-warning",attrs:{"title":_vm.prompt},domProps:{"textContent":_vm._s(_vm.prompt)}}):(_vm.minVisibleYear !== '' && _vm.maxVisibleYear !== '')?_c('span',{staticClass:"el-picker-panel__footer-message"},[_c('span',{domProps:{"textContent":_vm._s(_vm.minVisibleYear)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.rangeSeparator)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.maxVisibleYear)}})]):_c('span',{staticClass:"el-picker-panel__footer-message"}),_c('el-button',{staticClass:"el-picker-panel__link-btn",attrs:{"disabled":_vm.disabledConfirm,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":function($event){return _vm.handleConfirm(false)}}})],1):_vm._e()])])])}
var year_rangevue_type_template_id_24df01a2_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/year-range.vue?vue&type=template&id=24df01a2&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/year-range.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






const year_rangevue_type_script_lang_js_calcDefaultValue = defaultValue => {
  if (Array.isArray(defaultValue)) {
    return [new Date(defaultValue[0]), new Date(defaultValue[1])];
  } else if (defaultValue) {
    return [new Date(defaultValue), nextYear(new Date(defaultValue))];
  } else {
    return [util_now('clearDate'), nextYear(util_now('clearDate'))];
  }
};
/* harmony default export */ var year_rangevue_type_script_lang_js_ = ({
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    YearTable: year_table
  },
  mixins: [locale, mixins_range],
  data() {
    return {
      popperClass: '',
      value: [],
      defaultValue: null,
      defaultTime: null,
      minDate: util_now('clearDate'),
      maxDate: util_now('clearDate'),
      leftDate: util_now('clearDate'),
      rightDate: util_now('clearDate'),
      rangeState: {
        endDate: null,
        selecting: false,
        row: null,
        column: null
      },
      shortcuts: '',
      visible: '',
      disabledDate: () => {
        return false;
      },
      format: 'yyyy',
      arrowControl: false,
      unlinkPanels: false,
      unlink: true,
      unlinkRange: true,
      rangeSeparator: '-',
      calendarType: ''
    };
  },
  computed: {
    now: () => util_now('clearDate'),
    calcMinDate() {
      const minDate = this.minDate || year_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];
      return toDate(minDate);
    },
    calcMaxDate() {
      const maxDate = this.maxDate || year_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[1];
      return toDate(maxDate);
    },
    btnDisabled() {
      return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
    },
    leftLabel() {
      return this.leftDate.getFullYear() + src_util_getOffset(this.calendarType) + ' ' + this.t('el.datepicker.year');
    },
    rightLabel() {
      return this.rightDate.getFullYear() + src_util_getOffset(this.calendarType) + ' ' + this.t('el.datepicker.year');
    },
    leftYear() {
      return this.leftDate.getFullYear();
    },
    rightYear() {
      return this.rightDate.getFullYear() === this.leftDate.getFullYear() ? this.leftDate.getFullYear() + 1 : this.rightDate.getFullYear();
    },
    enableYearArrow() {
      return this.unlink || this.unlinkPanels && this.rightYear > this.leftYear + 1;
    },
    minVisibleYear() {
      return this.minDate ? formatDate(this.minDate, this.format, this.calendarType) : '';
    },
    maxVisibleYear() {
      return this.maxDate ? formatDate(this.maxDate, this.format, this.calendarType) : '';
    },
    showAbnormalInfo() {
      if (this.isUnlinkRange) {
        if (this.minDate && this.maxDate && clearDate(this.minDate).getTime() > clearDate(this.maxDate).getTime()) {
          return true;
        }
      }
      return false;
    }
  },
  watch: {
    value(newVal) {
      if (!newVal) {
        this.minDate = this.now;
        this.maxDate = this.now;
      } else if (Array.isArray(newVal)) {
        this.minDate = toDate(newVal[0]);
        this.maxDate = toDate(newVal[1]);
      }
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
    },
    defaultValue(val) {
      if (!Array.isArray(this.value)) {
        const [leftDate, rightDate] = year_rangevue_type_script_lang_js_calcDefaultValue(val);
        this.leftDate = leftDate;
        this.rightDate = this.getDefaultRightDate(rightDate);
      }
    }
  },
  methods: {
    getDefaultRightDate(val) {
      const minDateYear = this.calcMinDate.getFullYear();
      const maxDateYear = this.calcMaxDate.getFullYear();
      const toNext = minDateYear === maxDateYear;
      if (!this.isUnlinkRange && toNext) {
        return nextYear(val);
      } else {
        return val;
      }
    },
    // handleLeftYearPick(year) {
    //   this.leftDate = setYear(this.leftDate, year);
    // },
    // handleRightYearPick(year) {
    //   this.rightDate = setYear(this.rightDate, year);
    // },
    handleClear() {
      this.minDate = null;
      this.maxDate = null;
      this.leftDate = this.calcMinDate;
      this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
      this.$emit('pick', null);
    },
    handleChangeRange(val) {
      this.minDate = val.minDate;
      this.maxDate = val.maxDate;
      this.rangeState = val.rangeState;
    },
    handleRangePick(val, {
      type,
      cell
    }) {
      const defaultTime = this.defaultTime || [];
      const minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
      const maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
      if (this.isUnlinkRange) {
        if (type === 'min') {
          this.minDate = minDate;
          this.leftDate = minDate;
        } else {
          this.maxDate = maxDate;
          this.rightDate = maxDate;
        }
      } else {
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
        this.onPick && this.onPick(val);
        this.maxDate = maxDate;
        this.minDate = minDate;
      }
      this.handleConfirm(!!this.unlink);
    },
    handleShortcutClick(shortcut) {
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
    },
    // leftPrev*, rightNext* need to take care of `unlinkPanels`
    leftPrevYear() {
      this.leftDate = prevYear(this.leftDate, 12);
      if (!this.unlinkPanels) {
        this.rightDate = prevYear(this.rightDate, 12);
      }
    },
    rightNextYear() {
      if (!this.unlinkPanels) {
        this.leftDate = nextYear(this.leftDate, 12);
      }
      this.rightDate = nextYear(this.rightDate, 12);
    },
    // leftNext*, rightPrev* are called when `unlinkPanels` is true
    leftNextYear() {
      this.leftDate = nextYear(this.leftDate, 12);
    },
    rightPrevYear() {
      this.rightDate = prevYear(this.rightDate, 12);
    },
    handleConfirm(visible = false) {
      if (this.isValidValue([this.minDate, this.maxDate])) {
        this.$emit('pick', [this.minDate, this.maxDate], visible);
      }
    },
    isValidValue(value) {
      return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && clearDate(value[0]).getTime() <= clearDate(value[1]).getTime() && !this.disabledDate(value[0]) && !this.disabledDate(value[1]);
    },
    resetView() {
      this.$nextTick(() => {
        if (isEmptyDate(this.value)) {
          this.minDate = null;
          this.maxDate = null;
          const defaultValue = this.defaultValue;
          if (defaultValue) {
            const [leftDate, rightDate] = year_rangevue_type_script_lang_js_calcDefaultValue(defaultValue);
            this.minDate = leftDate;
            this.maxDate = rightDate;
            this.leftDate = leftDate;
            this.rightDate = rightDate;
          }
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
        } else {
          this.minDate = toDate(this.value[0]);
          this.maxDate = toDate(this.value[1]);
          this.leftDate = this.calcMinDate;
          this.rightDate = this.getDefaultRightDate(this.calcMaxDate);
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/year-range.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_year_rangevue_type_script_lang_js_ = (year_rangevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/year-range.vue





/* normalize component */

var year_range_component = normalizeComponent(
  panel_year_rangevue_type_script_lang_js_,
  year_rangevue_type_template_id_24df01a2_render,
  year_rangevue_type_template_id_24df01a2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var year_range = (year_range_component.exports);
// CONCATENATED MODULE: ./packages/date-picker/src/picker/date-picker.js





const getPanel = function (type) {
  if (type === 'daterange' || type === 'datetimerange') {
    return date_range;
  } else if (type === 'monthrange') {
    return month_range;
  } else if (type === 'yearrange') {
    return year_range;
  }
  return panel_date;
};
/* harmony default export */ var date_picker = ({
  mixins: [picker],
  name: 'ElDatePicker',
  props: {
    type: {
      type: String,
      default: 'date'
    },
    timeArrowControl: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    type(type) {
      if (this.picker) {
        this.unmountPicker();
        this.panel = getPanel(type);
        this.mountPicker();
      } else {
        this.panel = getPanel(type);
      }
    }
  },
  created() {
    this.panel = getPanel(this.type);
  }
});
// CONCATENATED MODULE: ./packages/date-picker/index.js


/* istanbul ignore next */
date_picker.install = function install(Vue) {
  Vue.component(date_picker.name, date_picker);
};
/* harmony default export */ var packages_date_picker = (date_picker);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-select.vue?vue&type=template&id=1b827c60&
var time_selectvue_type_template_id_1b827c60_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-bottom"},on:{"before-enter":_vm.handleMenuEnter,"after-leave":function($event){return _vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],ref:"popper",staticClass:"el-picker-panel time-select el-popper",class:_vm.popperClass,style:({ width: _vm.width + 'px' })},[_c('el-scrollbar',{attrs:{"wrap-class":"el-picker-panel__content"}},_vm._l((_vm.items),function(item){return _c('div',{key:item.value,staticClass:"time-select-item",class:{
          selected: _vm.value === item.value,
          disabled: item.disabled,
          default: item.value === _vm.defaultValue
        },attrs:{"disabled":item.disabled},domProps:{"textContent":_vm._s(item.value)},on:{"click":function($event){return _vm.handleClick(item)}}})}),0)],1)])}
var time_selectvue_type_template_id_1b827c60_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue?vue&type=template&id=1b827c60&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-select.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



const parseTime = function (time) {
  const values = (time || '').split(':');
  if (values.length >= 2) {
    const hours = parseInt(values[0], 10);
    const minutes = parseInt(values[1], 10);
    return {
      hours,
      minutes
    };
  }
  /* istanbul ignore next */
  return null;
};
const compareTime = function (time1, time2) {
  const value1 = parseTime(time1);
  const value2 = parseTime(time2);
  const minutes1 = value1.minutes + value1.hours * 60;
  const minutes2 = value2.minutes + value2.hours * 60;
  if (minutes1 === minutes2) {
    return 0;
  }
  return minutes1 > minutes2 ? 1 : -1;
};
const formatTime = function (time) {
  return (time.hours < 10 ? '0' + time.hours : time.hours) + ':' + (time.minutes < 10 ? '0' + time.minutes : time.minutes);
};
const nextTime = function (time, step) {
  const timeValue = parseTime(time);
  const stepValue = parseTime(step);
  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes
  };
  next.minutes += stepValue.minutes;
  next.hours += stepValue.hours;
  next.hours += Math.floor(next.minutes / 60);
  next.minutes = next.minutes % 60;
  return formatTime(next);
};
/* harmony default export */ var time_selectvue_type_script_lang_js_ = ({
  components: {
    ElScrollbar: scrollbar
  },
  data() {
    return {
      popperClass: '',
      start: '09:00',
      end: '18:00',
      step: '00:30',
      value: '',
      defaultValue: '',
      visible: false,
      minTime: '',
      maxTime: '',
      width: 0,
      range: []
    };
  },
  computed: {
    items() {
      const start = this.start;
      const end = this.end;
      const step = this.step;
      const result = [];
      if (start && end && step) {
        let current = start;
        while (compareTime(current, end) <= 0) {
          if (this.range.length) {
            let isInRange = true;
            (this.range || []).forEach(range => {
              const ranges = range.split('-');
              isInRange = isInRange && (compareTime(current, ranges[0]) < 0 || compareTime(current, ranges[1]) > 0);
            });
            result.push({
              value: current,
              disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0 || isInRange
            });
          } else {
            result.push({
              value: current,
              disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0
            });
          }
          current = nextTime(current, step);
        }
      }
      return result;
    }
  },
  watch: {
    value(val) {
      if (!val) return;
      this.$nextTick(() => this.scrollToOption());
    }
  },
  methods: {
    handleClick(item) {
      if (!item.disabled) {
        this.$emit('pick', item.value);
      }
    },
    handleClear() {
      this.$emit('pick', null);
    },
    scrollToOption(selector = '.selected') {
      const menu = this.$refs.popper.querySelector('.el-picker-panel__content');
      scrollIntoView(menu, menu.querySelector(selector));
    },
    handleMenuEnter() {
      const selected = this.items.map(item => item.value).indexOf(this.value) !== -1;
      const hasDefault = this.items.map(item => item.value).indexOf(this.defaultValue) !== -1;
      const option = selected && '.selected' || hasDefault && '.default' || '.time-select-item:not(.disabled)';
      this.$nextTick(() => this.scrollToOption(option));
    },
    scrollDown(step) {
      const items = this.items;
      const length = items.length;
      let total = items.length;
      let index = items.map(item => item.value).indexOf(this.value);
      while (total--) {
        index = (index + step + length) % length;
        if (!items[index].disabled) {
          this.$emit('pick', items[index].value, true);
          return;
        }
      }
    },
    isValidValue(date) {
      return this.items.filter(item => !item.disabled).map(item => item.value).indexOf(date) !== -1;
    },
    handleKeydown(event) {
      const keyCode = event.keyCode;
      if (keyCode === 38 || keyCode === 40) {
        const mapping = {
          40: 1,
          38: -1
        };
        const offset = mapping[keyCode.toString()];
        this.scrollDown(offset);
        event.stopPropagation();
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_time_selectvue_type_script_lang_js_ = (time_selectvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-select.vue





/* normalize component */

var time_select_component = normalizeComponent(
  panel_time_selectvue_type_script_lang_js_,
  time_selectvue_type_template_id_1b827c60_render,
  time_selectvue_type_template_id_1b827c60_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var time_select = (time_select_component.exports);
// CONCATENATED MODULE: ./packages/date-picker/src/picker/time-select.js


/* harmony default export */ var picker_time_select = ({
  mixins: [picker],
  name: 'ElTimeSelect',
  componentName: 'ElTimeSelect',
  props: {
    type: {
      type: String,
      default: 'time-select'
    }
  },
  beforeCreate() {
    this.panel = time_select;
  }
});
// CONCATENATED MODULE: ./packages/time-select/index.js


/* istanbul ignore next */
picker_time_select.install = function (Vue) {
  Vue.component(picker_time_select.name, picker_time_select);
};
/* harmony default export */ var packages_time_select = (picker_time_select);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-range.vue?vue&type=template&id=1b7e101a&
var time_rangevue_type_template_id_1b7e101a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-bottom"},on:{"after-leave":function($event){return _vm.$emit('dodestroy')}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-time-range-picker el-picker-panel el-popper",class:_vm.popperClass},[_c('div',{staticClass:"el-time-range-picker__content"},[_c('div',{staticClass:"el-time-range-picker__cell"},[_c('div',{staticClass:"el-time-range-picker__header",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.startTime'))}}),_c('div',{staticClass:"el-time-range-picker__body el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds, 'is-arrow': _vm.arrowControl }},[_c('time-spinner',{ref:"minSpinner",attrs:{"is-empty":_vm.isTimeEmpty,"show-seconds":_vm.showSeconds,"am-pm-mode":_vm.amPmMode,"arrow-control":_vm.arrowControl,"date":_vm.minDate},on:{"change":_vm.handleMinChange,"select-range":_vm.setMinSelectionRange}})],1)]),_c('div',{staticClass:"el-time-range-picker__cell"},[_c('div',{staticClass:"el-time-range-picker__header",domProps:{"textContent":_vm._s(_vm.t('el.datepicker.endTime'))}}),_c('div',{staticClass:"el-time-range-picker__body el-time-panel__content",class:{ 'has-seconds': _vm.showSeconds, 'is-arrow': _vm.arrowControl }},[_c('time-spinner',{ref:"maxSpinner",attrs:{"is-empty":_vm.isTimeEmpty,"unlink-range":_vm.unlinkRange,"show-seconds":_vm.showSeconds,"am-pm-mode":_vm.amPmMode,"arrow-control":_vm.arrowControl,"date":_vm.maxDate},on:{"change":_vm.handleMaxChange,"select-range":_vm.setMaxSelectionRange}})],1)])]),_c('div',{staticClass:"el-picker-panel__footer"},[(!_vm.showPrompt || _vm.showAbnormalInfo)?_c('span',{staticClass:"el-picker-panel__footer-message is-warning",attrs:{"title":_vm.compareTimesFunc ? _vm.customErrorInfo : _vm.prompt},domProps:{"textContent":_vm._s(_vm.compareTimesFunc ? _vm.customErrorInfo : _vm.prompt)}}):(_vm.minVisibleTime !== '' && _vm.maxVisibleTime !== '')?_c('span',{staticClass:"el-picker-panel__footer-message"},[_c('span',{domProps:{"textContent":_vm._s(_vm.minVisibleTime)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.rangeSeparator)}}),_c('span',{domProps:{"textContent":_vm._s(_vm.maxVisibleTime)}})]):_c('span',{staticClass:"el-picker-panel__footer-message"}),_c('el-button',{staticClass:"el-time-panel__btn confirm",attrs:{"disabled":_vm.showAbnormalInfo || _vm.isTimeEmpty,"type":"primary"},domProps:{"textContent":_vm._s(_vm.t('el.datepicker.confirm'))},on:{"click":function($event){return _vm.handleConfirm()}}})],1)])])}
var time_rangevue_type_template_id_1b7e101a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue?vue&type=template&id=1b7e101a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time-range.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






const minTimeOfDay = function (date) {
  return modifyDate(MIN_TIME, date.getFullYear(), date.getMonth(), date.getDate());
};
const maxTimeOfDay = function (date) {
  return modifyDate(MAX_TIME, date.getFullYear(), date.getMonth(), date.getDate());
};

// increase time by amount of milliseconds, but within the range of day
const advanceTime = function (date, amount) {
  return new Date(Math.min(date.getTime() + amount, maxTimeOfDay(date).getTime()));
};
/* harmony default export */ var time_rangevue_type_script_lang_js_ = ({
  components: {
    TimeSpinner: time_spinner,
    ElButton: packages_button
  },
  mixins: [locale, mixins_range],
  data() {
    return {
      popperClass: '',
      minDate: util_now(),
      maxDate: util_now(),
      value: [],
      defaultValue: null,
      format: 'HH:mm:ss',
      rangeSeparator: '-',
      visible: false,
      selectionRange: [0, 2],
      arrowControl: false,
      isRange: false,
      unlink: true,
      unlinkRange: true,
      selectableRange: [],
      compareTimesFunc: null
    };
  },
  computed: {
    showSeconds() {
      return (this.format || '').indexOf('ss') !== -1;
    },
    offset() {
      return this.showSeconds ? 11 : 8;
    },
    spinner() {
      return this.selectionRange[0] < this.offset ? this.$refs.minSpinner : this.$refs.maxSpinner;
    },
    showAbnormalInfo() {
      if (this.compareTimesFunc) {
        if (this.value.length === 0) {
          return false;
        } else if (this.compareTimesFunc(this.minDate, this.maxDate) !== true) {
          // 自定义方法中return值是true, 不展示warning span标签
          return true;
        } else {
          // 自定义方法中return值是错误描述, 展示warning span标签
          return false;
        }
      }
      if (this.isTimeEmpty) {
        return false;
      }
      return this.minDate.getTime() > this.maxDate.getTime();
    },
    customErrorInfo() {
      return this.compareTimesFunc(this.minDate, this.maxDate);
    },
    amPmMode() {
      if ((this.format || '').indexOf('A') !== -1) return 'A';
      if ((this.format || '').indexOf('a') !== -1) return 'a';
      return '';
    },
    minVisibleTime() {
      if (!this.isTimeEmpty) {
        return formatDate(this.minDate, this.format);
      }
      return '';
    },
    maxVisibleTime() {
      if (!this.isTimeEmpty) {
        return formatDate(this.maxDate, this.format);
      }
      return '';
    },
    isTimeEmpty() {
      if (!this.isUnlinkRange) {
        return false;
      }
      return isEmptyDate(this.value) && isEmptyDate(this.defaultTime);
    }
  },
  watch: {
    value(value) {
      if (Array.isArray(value)) {
        let defaultDate = util_now();
        if (!this.unlinkRange) {
          defaultDate = advanceTime(util_now(), 60 * 60 * 1000);
        }
        this.minDate = isDate(value[0]) ? new Date(value[0]) : defaultDate;
        this.maxDate = isDate(value[1]) ? new Date(value[1]) : defaultDate;
      } else {
        if (Array.isArray(this.defaultValue)) {
          this.minDate = new Date(this.defaultValue[0]);
          this.maxDate = new Date(this.defaultValue[1]);
        } else if (this.defaultValue) {
          this.minDate = new Date(this.defaultValue);
          this.maxDate = advanceTime(new Date(this.defaultValue), 60 * 60 * 1000);
        } else {
          this.minDate = util_now();
          if (!this.unlinkRange) {
            this.maxDate = advanceTime(util_now(), 60 * 60 * 1000);
          } else {
            this.maxDate = util_now();
          }
        }
      }
      if (this.isValidValue(value) && !this.unlinkRange) {
        if (this.$refs.minSpinner) {
          this.$refs.minSpinner.selectableRange = [[minTimeOfDay(value[0]), value[1]]];
        }
        if (this.$refs.maxSpinner) {
          this.$refs.maxSpinner.selectableRange = [[value[0], maxTimeOfDay(value[1])]];
        }
      }
    },
    visible(val) {
      if (val) {
        this.$nextTick(() => {
          this.$refs.minSpinner.emitSelectRange('hours');
          this.adjustSpinners();
        });
      }
    },
    selectableRange(val) {
      this.$refs.minSpinner.selectableRange = val;
      this.$refs.maxSpinner.selectableRange = val;
    }
  },
  methods: {
    handleClear() {
      this.$emit('pick', null);
    },
    handleCancel() {
      this.$emit('pick', this.oldValue);
    },
    handleMinChange(date) {
      this.minDate = clearMilliseconds(date);
      this.handleChange();
    },
    handleMaxChange(date) {
      this.maxDate = clearMilliseconds(date);
      this.handleChange();
    },
    handleChange() {
      if (this.isValidValue([this.minDate, this.maxDate])) {
        this.$emit('pick', [this.minDate, this.maxDate], this.arrowControl || this.isRange ? true : !this.isUnlinkRange);
      }
    },
    setMinSelectionRange(start, end) {
      this.$emit('select-range', start, end, 'min');
      this.selectionRange = [start, end];
    },
    setMaxSelectionRange(start, end) {
      this.$emit('select-range', start, end, 'max');
      this.selectionRange = [start + this.offset, end + this.offset];
    },
    handleConfirm(visible = false) {
      const minSelectableRange = this.$refs.minSpinner.selectableRange;
      const maxSelectableRange = this.$refs.maxSpinner.selectableRange;
      this.minDate = limitTimeRange(this.minDate, minSelectableRange, this.format);
      this.maxDate = limitTimeRange(this.maxDate, maxSelectableRange, this.format);
      this.$emit('pick', [this.minDate, this.maxDate], visible);
    },
    adjustSpinners() {
      this.$refs.minSpinner.adjustSpinners();
      this.$refs.maxSpinner.adjustSpinners();
    },
    adjustCurrentSpinner(type, pos) {
      this.$nextTick(() => {
        if (pos === 'min') {
          this.$refs.minSpinner.adjustCurrentSpinner(type);
        } else {
          this.$refs.maxSpinner.adjustCurrentSpinner(type);
        }
      });
    },
    changeSelectionRange(step) {
      const list = this.showSeconds ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      const mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
      const index = list.indexOf(this.selectionRange[0]);
      const next = (index + step + list.length) % list.length;
      const half = list.length / 2;
      if (next < half) {
        this.$refs.minSpinner.emitSelectRange(mapping[next]);
      } else {
        this.$refs.maxSpinner.emitSelectRange(mapping[next - half]);
      }
    },
    isValidValue(value) {
      return Array.isArray(value) && timeWithinRange(this.minDate, this.$refs.minSpinner.selectableRange) && timeWithinRange(this.maxDate, this.$refs.maxSpinner.selectableRange);
    },
    handleKeydown(event) {
      const keyCode = event.keyCode;
      const mapping = {
        38: -1,
        40: 1,
        37: -1,
        39: 1
      };

      // Left or Right
      if (keyCode === 37 || keyCode === 39) {
        const step = mapping[keyCode];
        this.changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      // Up or Down
      if (keyCode === 38 || keyCode === 40) {
        const step = mapping[keyCode];
        this.spinner.scrollDown(step);
        event.preventDefault();
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue?vue&type=script&lang=js&
 /* harmony default export */ var panel_time_rangevue_type_script_lang_js_ = (time_rangevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/date-picker/src/panel/time-range.vue





/* normalize component */

var time_range_component = normalizeComponent(
  panel_time_rangevue_type_script_lang_js_,
  time_rangevue_type_template_id_1b7e101a_render,
  time_rangevue_type_template_id_1b7e101a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var time_range = (time_range_component.exports);
// CONCATENATED MODULE: ./packages/date-picker/src/picker/time-picker.js



/* harmony default export */ var time_picker = ({
  mixins: [picker],
  name: 'ElTimePicker',
  props: {
    isRange: {
      type: Boolean,
      default: false
    },
    arrowControl: {
      type: Boolean,
      default: false
    },
    compareTimes: {
      type: Function,
      default: null
    }
  },
  data() {
    return {
      type: ''
    };
  },
  watch: {
    isRange(isRange) {
      if (this.picker) {
        this.unmountPicker();
        this.type = isRange ? 'timerange' : 'time';
        this.panel = isRange ? time_range : panel_time;
        this.mountPicker();
      } else {
        this.type = isRange ? 'timerange' : 'time';
        this.panel = isRange ? time_range : panel_time;
      }
    }
  },
  created() {
    this.type = this.isRange ? 'timerange' : 'time';
    this.panel = this.isRange ? time_range : panel_time;
  }
});
// CONCATENATED MODULE: ./packages/time-picker/index.js


/* istanbul ignore next */
time_picker.install = function (Vue) {
  Vue.component(time_picker.name, time_picker);
};
/* harmony default export */ var packages_time_picker = (time_picker);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/message-box/src/main.vue?vue&type=template&id=6376183f&
var mainvue_type_template_id_6376183f_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"msgbox-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-message-box__wrapper",attrs:{"tabindex":"-1"},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.handleWrapperClick.apply(null, arguments)}}},[_c('div',{staticClass:"el-message-box",class:[_vm.customClass, _vm.sizeClass]},[_c('div',{staticClass:"el-message-box__content"},[_c('div',{staticClass:"el-message-box__container"},[_c('h-feedback-icon',{staticClass:"el-message-box__status",attrs:{"icon-name":_vm.typeClass}}),(_vm.title)?_c('div',{staticClass:"el-message-box__titleWrapper",style:({
              'margin-top': !_vm.typeClass || _vm.message !== '' ? '0' : '8px'
            })},[_c('div',{staticClass:"el-message-box__title",style:({
                'margin-left': _vm.typeClass ? '56px' : '0',
                'min-height': _vm.message ? '' : '48px'
              })},[(!_vm.dangerouslyUseHTMLString)?_c('span',[_vm._v(_vm._s(_vm.title))]):_c('span',{domProps:{"innerHTML":_vm._s(_vm.title)}})])]):_vm._e(),(_vm.message !== '')?_c('div',{staticClass:"el-message-box__message",style:({
              'margin-left': _vm.typeClass ? '56px' : '0',
              'margin-top': _vm.title ? '4px' : '0'
            })},[_vm._t("default",function(){return [_c('el-scrollbar',[(!_vm.dangerouslyUseHTMLString)?_c('p',[_vm._v(" "+_vm._s(_vm.message)+" ")]):_c('p',{domProps:{"innerHTML":_vm._s(_vm.message)}})])]})],2):_vm._e(),(_vm.showInput)?_c('div',{staticClass:"el-message-box__input"},[_c('el-input',{ref:"input",attrs:{"type":_vm.inputType,"placeholder":_vm.inputPlaceholder},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.handleAction('confirm')}},model:{value:(_vm.inputValue),callback:function ($$v) {_vm.inputValue=$$v},expression:"inputValue"}}),_c('div',{staticClass:"el-message-box__errormsg",style:({
                visibility: !!_vm.editorErrorMessage ? 'visible' : 'hidden'
              })},[_vm._v(" "+_vm._s(_vm.editorErrorMessage)+" ")])],1):_vm._e()],1)]),_c('div',{staticClass:"el-message-box__btns"},[(_vm.buttons)?_c('div',_vm._l((_vm.buttons),function(item,index){return _c('el-button',{key:index,attrs:{"type":item.type},nativeOn:{"click":function($event){return _vm.handleAction(item.action)}}},[_vm._v(" "+_vm._s(item.name)+" ")])}),1):_c('div',[_c('el-button',{directives:[{name:"show",rawName:"v-show",value:(_vm.showConfirmButton),expression:"showConfirmButton"}],ref:"confirm",class:[_vm.confirmButtonClasses],attrs:{"loading":_vm.confirmButtonLoading},nativeOn:{"click":function($event){return _vm.handleAction('confirm')}}},[_vm._v(" "+_vm._s(_vm.confirmButtonText || _vm.t('el.messagebox.confirm'))+" ")]),_c('el-button',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCancelButton),expression:"showCancelButton"}],class:[_vm.cancelButtonClasses],attrs:{"loading":_vm.cancelButtonLoading},nativeOn:{"click":function($event){return _vm.handleAction('cancel')}}},[_vm._v(" "+_vm._s(_vm.cancelButtonText || _vm.t('el.messagebox.cancel'))+" ")])],1)])])])])}
var mainvue_type_template_id_6376183f_staticRenderFns = []


// CONCATENATED MODULE: ./packages/message-box/src/main.vue?vue&type=template&id=6376183f&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/message-box/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







const typeMap = {
  success: 'feedback_success_lg',
  info: 'feedback_info_lg',
  warning: 'feedback_warning_lg',
  question: 'feedback_question_lg',
  error: 'feedback_error_lg'
};
const mainvue_type_script_lang_js_sizeMap = {
  small: 'small',
  middle: 'middle',
  large: 'large'
};
/* harmony default export */ var message_box_src_mainvue_type_script_lang_js_ = ({
  components: {
    ElInput: packages_input,
    ElButton: packages_button
  },
  mixins: [popup, locale],
  props: {
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      uid: 1,
      title: undefined,
      message: '',
      type: '',
      size: '',
      customClass: '',
      showInput: false,
      inputValue: null,
      inputPlaceholder: '',
      inputType: 'text',
      inputPattern: null,
      inputValidator: null,
      inputErrorMessage: '',
      showConfirmButton: true,
      showCancelButton: false,
      action: '',
      confirmButtonText: '',
      cancelButtonText: '',
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonClass: '',
      confirmButtonDisabled: false,
      cancelButtonClass: '',
      editorErrorMessage: null,
      callback: null,
      dangerouslyUseHTMLString: false,
      buttons: null
    };
  },
  computed: {
    typeClass() {
      return this.type && typeMap[this.type] ? `h-icon-${typeMap[this.type]}` : '';
    },
    sizeClass() {
      return this.size && mainvue_type_script_lang_js_sizeMap[this.size] ? `el-message-box--${mainvue_type_script_lang_js_sizeMap[this.size]}` : 'el-message-box--small';
    },
    confirmButtonClasses() {
      return `el-button--primary ${this.confirmButtonClass}`;
    },
    cancelButtonClasses() {
      return `${this.cancelButtonClass}`;
    }
  },
  watch: {
    inputValue: {
      immediate: true,
      handler(val) {
        this.$nextTick(() => {
          if (this.$type === 'prompt' && val !== null) {
            this.validate();
          }
        });
      }
    },
    visible(val) {
      if (val) this.uid++;
      if (this.$type === 'alert' || this.$type === 'confirm') {
        this.$nextTick(() => {
          if (this.$refs.confirm) {
            this.$refs.confirm.$el.focus();
          }
        });
      }
      if (this.$type !== 'prompt') return;
      if (val) {
        setTimeout(() => {
          if (this.$refs.input && this.$refs.input.$el) {
            this.$refs.input.$el.querySelector('input').focus();
          }
        }, 500);
      } else {
        this.editorErrorMessage = '';
        removeClass(this.$refs.input.$el.querySelector('input'), 'invalid');
      }
    }
  },
  mounted() {
    if (this.closeOnHashChange) {
      window.addEventListener('hashchange', this.close);
    }
  },
  beforeDestroy() {
    if (this.closeOnHashChange) {
      window.removeEventListener('hashchange', this.close);
    }
  },
  methods: {
    getSafeClose() {
      const currentId = this.uid;
      return () => {
        this.$nextTick(() => {
          if (currentId === this.uid) this.doClose();
        });
      };
    },
    doClose() {
      if (!this.visible) return;
      this.visible = false;
      this._closing = true;
      this.onClose && this.onClose();
      if (this.lockScroll) {
        setTimeout(() => {
          if (this.modal && this.bodyOverflow !== 'hidden') {
            document.body.style.overflow = this.bodyOverflow;
            document.body.style.width = this.bodyPaddingRight;
          }
          this.bodyOverflow = null;
          this.bodyPaddingRight = null;
        }, 200);
      }
      this.opened = false;
      if (!this.transition) {
        this.doAfterClose();
      }
      if (this.action) this.callback(this.action, this);
    },
    handleWrapperClick() {
      if (this.closeOnClickModal) {
        this.handleAction('cancel');
      }
    },
    handleAction(action) {
      if (this.$type === 'prompt' && action === 'confirm' && !this.validate()) {
        return;
      }
      this.action = action;
      if (typeof this.beforeClose === 'function') {
        this.close = this.getSafeClose();
        this.beforeClose(action, this, this.close);
      } else {
        this.doClose();
      }
    },
    validate() {
      if (this.$type === 'prompt') {
        var inputPattern = this.inputPattern;
        if (inputPattern && !inputPattern.test(this.inputValue || '')) {
          this.editorErrorMessage = this.inputErrorMessage || Object(locale_["t"])('el.messagebox.error');
          addClass(this.$refs.input.$el.querySelector('input'), 'invalid');
          return false;
        }
        var inputValidator = this.inputValidator;
        if (typeof inputValidator === 'function') {
          var validateResult = inputValidator(this.inputValue);
          if (validateResult === false) {
            this.editorErrorMessage = this.inputErrorMessage || Object(locale_["t"])('el.messagebox.error');
            addClass(this.$refs.input.$el.querySelector('input'), 'invalid');
            return false;
          }
          if (typeof validateResult === 'string') {
            this.editorErrorMessage = validateResult;
            return false;
          }
        }
      }
      this.editorErrorMessage = '';
      removeClass(this.$refs.input.$el.querySelector('input'), 'invalid');
      return true;
    }
  }
});
// CONCATENATED MODULE: ./packages/message-box/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_message_box_src_mainvue_type_script_lang_js_ = (message_box_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/message-box/src/main.vue





/* normalize component */

var message_box_src_main_component = normalizeComponent(
  packages_message_box_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_6376183f_render,
  mainvue_type_template_id_6376183f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var message_box_src_main = (message_box_src_main_component.exports);
// CONCATENATED MODULE: ./src/utils/vdom.js

function isVNode(node) {
  return typeof node === 'object' && hasOwn(node, 'componentOptions');
}
function getFirstComponentChild(children) {
  return children && children.filter(c => c && c.tag)[0];
}
// CONCATENATED MODULE: ./packages/message-box/src/main.js





const main_defaults = {
  title: undefined,
  message: '',
  type: '',
  size: '',
  showInput: false,
  showClose: true,
  modalFade: true,
  lockScroll: true,
  closeOnClickModal: false,
  closeOnPressEscape: false,
  closeOnHashChange: true,
  inputValue: null,
  inputPlaceholder: '',
  inputType: 'text',
  inputPattern: null,
  inputValidator: null,
  inputErrorMessage: '',
  showConfirmButton: true,
  showCancelButton: false,
  confirmButtonPosition: 'right',
  confirmButtonHighlight: false,
  cancelButtonHighlight: false,
  confirmButtonText: '',
  cancelButtonText: '',
  confirmButtonClass: '',
  cancelButtonClass: '',
  customClass: '',
  beforeClose: null,
  dangerouslyUseHTMLString: false,
  buttons: null,
  onConfirm: null,
  onCancel: null
};
const MessageBoxConstructor = external_vue_default.a.extend(message_box_src_main);
let currentMsg, main_instance;
let msgQueue = [];
const defaultCallback = action => {
  if (currentMsg) {
    const callback = currentMsg.callback;
    if (typeof callback === 'function') {
      if (main_instance.showInput) {
        callback(main_instance.inputValue, action);
      } else {
        callback(action);
      }
    }
    if (currentMsg.resolve) {
      if (action !== 'cancel') {
        if (main_instance.showInput) {
          currentMsg.resolve({
            value: main_instance.inputValue,
            action
          });
        } else {
          currentMsg.resolve(action);
        }
        if (typeof currentMsg.options.onConfirm === 'function') {
          if (main_instance.showInput) {
            currentMsg.options.onConfirm({
              value: main_instance.inputValue,
              action
            });
          } else {
            currentMsg.options.onConfirm(action);
          }
        }
      } else if (currentMsg.reject) {
        if (typeof currentMsg.options.onCancel === 'function') {
          currentMsg.options.onCancel(action);
        } else {
          currentMsg.reject(action);
        }
      }
    }
  }
};
const initInstance = () => {
  main_instance = new MessageBoxConstructor({
    el: document.createElement('div')
  });
  main_instance.callback = defaultCallback;
};
const showNextMsg = () => {
  if (!main_instance) {
    initInstance();
  }
  main_instance.action = '';
  if (!main_instance.visible || main_instance.closeTimer) {
    if (msgQueue.length > 0) {
      currentMsg = msgQueue.shift();
      const options = currentMsg.options;
      for (const prop in options) {
        if (hasOwn(options, prop)) {
          main_instance[prop] = options[prop];
        }
      }

      // 如果msgbox默认没有使用title属性，则应该赋值title为空
      if (!options.title) {
        main_instance.title = '';
      }
      if (options.callback === undefined) {
        main_instance.callback = defaultCallback;
      }
      const oldCb = main_instance.callback;
      main_instance.callback = (action, instance) => {
        oldCb(action, instance);
        showNextMsg();
      };
      if (isVNode(main_instance.message)) {
        main_instance.$slots.default = [main_instance.message];
        main_instance.message = null;
      } else {
        delete main_instance.$slots.default;
      }
      ['modal', 'showClose', 'closeOnClickModal', 'closeOnPressEscape', 'closeOnHashChange'].forEach(prop => {
        if (main_instance[prop] === undefined) {
          main_instance[prop] = true;
        }
      });
      document.body.appendChild(main_instance.$el);
      external_vue_default.a.nextTick(() => {
        main_instance.visible = true;
      });
    }
  }
};
const MessageBox = function (options, callback) {
  if (external_vue_default.a.prototype.$isServer) return;
  if (typeof options === 'string' || isVNode(options)) {
    options = {
      message: options
    };
    if (typeof arguments[1] === 'string') {
      options.title = arguments[1];
    }
    if (arguments[2]) {
      options.type = arguments[2];
    }
  } else if (options.callback && !callback) {
    callback = options.callback;
  }
  if (typeof Promise !== 'undefined') {
    return new Promise((resolve, reject) => {
      // eslint-disable-line
      msgQueue.push({
        options: merge({}, main_defaults, MessageBox.defaults, options),
        callback: callback,
        resolve: resolve,
        reject: reject
      });
      showNextMsg();
    });
  } else {
    msgQueue.push({
      options: merge({}, main_defaults, MessageBox.defaults, options),
      callback: callback
    });
    showNextMsg();
  }
};
MessageBox.setDefaults = defaults => {
  MessageBox.defaults = defaults;
};
MessageBox.alert = (message, title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox(merge({
    title: title,
    message: message,
    $type: 'alert'
  }, options));
};
MessageBox.confirm = (title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox(merge({
    title: title,
    $type: 'confirm',
    type: 'question',
    showCancelButton: true
  }, options));
};
MessageBox.prompt = (message, title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }
  return MessageBox(merge({
    title: title,
    message: message,
    showCancelButton: true,
    showInput: true,
    $type: 'prompt'
  }, options));
};
MessageBox.close = () => {
  main_instance.doClose();
  main_instance.visible = false;
  msgQueue = [];
  currentMsg = null;
};
/* harmony default export */ var packages_message_box_src_main = (MessageBox);

// CONCATENATED MODULE: ./packages/message-box/index.js

/* harmony default export */ var message_box = (packages_message_box_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb.vue?vue&type=template&id=cda05f40&
var breadcrumbvue_type_template_id_cda05f40_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-breadcrumb"},[_vm._t("default")],2)}
var breadcrumbvue_type_template_id_cda05f40_staticRenderFns = []


// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue?vue&type=template&id=cda05f40&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb.vue?vue&type=script&lang=js&
//
//
//
//
//

/* harmony default export */ var breadcrumbvue_type_script_lang_js_ = ({
  name: 'ElBreadcrumb',
  provide() {
    return {
      breadcrumb: this
    };
  },
  props: {
    separator: {
      type: String,
      default: '/'
    },
    separatorClass: {
      type: String,
      default: 'h-icon-angle_right_sm'
    },
    // 面包屑子项最大宽度
    itemMaxWidth: {
      type: [String, Number],
      default: null
    }
  }
});
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_breadcrumbvue_type_script_lang_js_ = (breadcrumbvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.vue





/* normalize component */

var breadcrumb_component = normalizeComponent(
  src_breadcrumbvue_type_script_lang_js_,
  breadcrumbvue_type_template_id_cda05f40_render,
  breadcrumbvue_type_template_id_cda05f40_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var breadcrumb = (breadcrumb_component.exports);
// CONCATENATED MODULE: ./packages/breadcrumb/index.js


/* istanbul ignore next */
breadcrumb.install = function (Vue) {
  Vue.component(breadcrumb.name, breadcrumb);
};
/* harmony default export */ var packages_breadcrumb = (breadcrumb);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=template&id=33460fc4&
var breadcrumb_itemvue_type_template_id_33460fc4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{class:[
    'el-breadcrumb__item',
    _vm.to ? '' : 'el-breadcrumb__item__unclickable'
  ]},[(_vm.type === 'dropdown')?_c('el-dropdown',{attrs:{"trigger":"click","placement":"bottom-start"},on:{"command":_vm.gotoBread}},[_c('el-button',{staticClass:"el-breadcrumb__item__omit",attrs:{"type":"iconButton","icon":"h-icon-more_hori"}}),_c('el-dropdown-menu',{staticClass:"el-breadcrumb__dropdown__menu",attrs:{"slot":"dropdown","type":_vm.type},slot:"dropdown"},[_vm._t("default")],2)],1):(_vm.type === 'tooltip')?_c('el-popover',{attrs:{"placement":"top","trigger":"hover","effect":"light","popper-class":"el-tooltip__contain--breadcrumb"}},[_c('el-button',{staticClass:"el-breadcrumb__item__omit",attrs:{"slot":"reference","type":"iconButton","icon":"h-icon-more_hori"},slot:"reference"}),_c('el-breadcrumb',{attrs:{"item-max-width":_vm.subMaxWidth}},[_vm._t("default")],2)],1):_c('span',{ref:"link",staticClass:"el-breadcrumb__item__inner",style:({ 'max-width': _vm.linkMaxWidth }),attrs:{"title":_vm.linkTitle,"role":"link"}},[_vm._t("default")],2),_c('span',{class:['el-breadcrumb__separator', _vm.separatorClass]},[_vm._v(" "+_vm._s(_vm.separator)+" ")])],1)}
var breadcrumb_itemvue_type_template_id_33460fc4_staticRenderFns = []


// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=template&id=33460fc4&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var breadcrumb_itemvue_type_script_lang_js_ = ({
  name: 'ElBreadcrumbItem',
  inject: ['breadcrumb'],
  props: {
    to: {
      type: null,
      default: null
    },
    replace: {
      type: Boolean,
      default: null
    },
    type: {
      type: String,
      default: ''
    },
    // 面包屑子项最大宽度
    maxWidth: {
      type: [String, Number],
      default: null
    },
    // 被收起的面包屑子项最大宽度
    subMaxWidth: {
      type: [String, Number],
      default: null
    },
    itemClick: {
      type: Function,
      default: null
    }
  },
  data() {
    return {
      separator: '',
      separatorClass: '',
      ellipsisItems: [],
      linkTitle: ''
    };
  },
  computed: {
    // 子项最大宽度，优先级：自身 maxWidth > 父级 itemMaxWidth
    linkMaxWidth() {
      if (this.maxWidth) return `${parseInt(this.maxWidth)}px`;else if (this.breadcrumb.itemMaxWidth) return `${parseInt(this.breadcrumb.itemMaxWidth)}px`;else return null;
    }
  },
  mounted() {
    // let self = this;
    this.separator = this.breadcrumb.separatorClass.length ? '' : this.breadcrumb.separator;
    this.separatorClass = this.breadcrumb.separatorClass || 'h-icon-angle_right_sm';
    if (this.to || this.itemClick) {
      const link = this.$refs.link;
      link.addEventListener('click', () => {
        const {
          to,
          $router,
          itemClick
        } = this;
        if (itemClick) {
          itemClick();
        }
        if (!to || !$router) return;
        this.replace ? $router.replace(to) : $router.push(to);
      });
    }
    // 若设置了最大宽度，默认显示 title
    if (this.linkMaxWidth && this.$refs.link) this.linkTitle = this.$refs.link.innerText;
  },
  methods: {
    gotoBread(to) {
      const {
        $router
      } = this;
      if (!to || !$router) return;
      this.replace ? $router.replace(to) : $router.push(to);
    }
  }
});
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_breadcrumb_itemvue_type_script_lang_js_ = (breadcrumb_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.vue





/* normalize component */

var breadcrumb_item_component = normalizeComponent(
  src_breadcrumb_itemvue_type_script_lang_js_,
  breadcrumb_itemvue_type_template_id_33460fc4_render,
  breadcrumb_itemvue_type_template_id_33460fc4_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var breadcrumb_item = (breadcrumb_item_component.exports);
// CONCATENATED MODULE: ./packages/breadcrumb-item/index.js


/* istanbul ignore next */
breadcrumb_item.install = function (Vue) {
  Vue.component(breadcrumb_item.name, breadcrumb_item);
};
/* harmony default export */ var packages_breadcrumb_item = (breadcrumb_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form.vue?vue&type=template&id=37f16928&
var formvue_type_template_id_37f16928_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('form',{staticClass:"el-form",class:[
    _vm.gridLayout ? 'el-form--grid-layout' : '',
    _vm.labelPosition ? 'el-form--label-' + _vm.labelPosition : '',
    _vm.messagePosition !== 'bottom' ? 'el-form--error-' + _vm.messagePosition : '',
    _vm.textForm ? 'text-form' : '',
    { 'el-form--inline': _vm.inline }
  ]},[_vm._t("default")],2)}
var formvue_type_template_id_37f16928_staticRenderFns = []


// CONCATENATED MODULE: ./packages/form/src/form.vue?vue&type=template&id=37f16928&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var formvue_type_script_lang_js_ = ({
  name: 'ElForm',
  componentName: 'ElForm',
  provide() {
    return {
      elForm: this
    };
  },
  props: {
    model: {
      type: Object,
      default: null
    },
    rules: {
      type: Object,
      default: null
    },
    labelPosition: {
      type: String,
      default: null
    },
    labelWidth: {
      type: String,
      default: null
    },
    labelSuffix: {
      type: String,
      default: ''
    },
    inline: {
      type: Boolean,
      default: null
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    // 内容区域宽度
    contentWidth: {
      type: String,
      default: null
    },
    // 错误提示的位置(bottom/right)
    messagePosition: {
      type: String,
      default: 'bottom'
    },
    // 标签和内容栅格布局
    gridLayout: {
      type: Boolean,
      default: null
    },
    labelGrid: {
      type: Object,
      default() {
        return {};
      }
    },
    contentGrid: {
      type: Object,
      default() {
        return {};
      }
    },
    // 标签过长是否显示省略号
    labelOverflowTitle: {
      type: Boolean,
      default: true
    },
    gutter: {
      type: Number,
      default: null
    },
    textForm: {
      type: Boolean,
      default: null
    },
    // rules 变化时是否进行校验
    validateOnRuleChange: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      fields: []
    };
  },
  watch: {
    rules() {
      if (this.validateOnRuleChange) {
        this.validate(() => {});
      }
    }
  },
  created() {
    this.$on('el.form.addField', field => {
      if (field) {
        this.fields.push(field);
      }
    });
    /* istanbul ignore next */
    this.$on('el.form.removeField', field => {
      if (field.prop) {
        this.fields.splice(this.fields.indexOf(field), 1);
      }
    });
  },
  methods: {
    focusFirstField() {
      for (const field of this.fields) {
        if (field.validateState === 'error') {
          field.focusField();
          break;
        }
      }
    },
    resetFields(isEmpty = false) {
      if (!this.model) {
         false &&
        // eslint-disable-next-line
        false;
        return;
      }
      for (const field of this.fields) {
        field.resetField(isEmpty);
      }
    },
    resetValidates() {
      if (!this.model) {
         false && false;
        return;
      }
      for (const field of this.fields) {
        field.resetValidate();
      }
    },
    resetValidate(prop, isResetRule = false) {
      if (!this.model) {
         false && false;
        return;
      }
      var field = this.fields.filter(field => field.prop === prop)[0];
      if (!field) {
        throw new Error('must call validateField with valid prop string!');
      }
      field.resetValidate(isResetRule);
    },
    validate(callback) {
      if (!this.model) {
        console.warn('[HUI Warn][Form]model is required for validate to work!');
        return;
      }
      let promise;
      // if no callback, return promise
      if (typeof callback !== 'function' && window.Promise) {
        promise = new window.Promise((resolve, reject) => {
          callback = function (valid) {
            valid ? resolve(valid) : reject(valid);
          };
        });
      }
      let valid = true;
      let count = 0;
      if (this.fields.length === 0 && callback) {
        callback(valid);
      }
      let invalidFields = {};
      this.fields.forEach(field => {
        field.validate('', (message, field) => {
          if (message) {
            valid = false;
          }
          invalidFields = merge({}, invalidFields, field);
          if (typeof callback === 'function' && ++count === this.fields.length) {
            callback(valid, invalidFields);
          }
        });
      });
      if (promise) {
        return promise;
      }
    },
    validateField(prop, cb) {
      var field = this.fields.filter(field => field.prop === prop)[0];
      if (!field) {
        throw new Error('must call validateField with valid prop string!');
      }
      field.validate('', cb);
    }
  }
});
// CONCATENATED MODULE: ./packages/form/src/form.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_formvue_type_script_lang_js_ = (formvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/form/src/form.vue





/* normalize component */

var form_component = normalizeComponent(
  src_formvue_type_script_lang_js_,
  formvue_type_template_id_37f16928_render,
  formvue_type_template_id_37f16928_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_form = (form_component.exports);
// CONCATENATED MODULE: ./packages/form/index.js


/* istanbul ignore next */
src_form.install = function (Vue) {
  Vue.component(src_form.name, src_form);
};
/* harmony default export */ var packages_form = (src_form);
// EXTERNAL MODULE: external "async-validator"
var external_async_validator_ = __webpack_require__("3ee4");
var external_async_validator_default = /*#__PURE__*/__webpack_require__.n(external_async_validator_);

// CONCATENATED MODULE: ./packages/col/src/col.js
/* harmony default export */ var col = ({
  name: 'ElCol',
  props: {
    span: {
      type: Number,
      default: 24
    },
    tag: {
      type: String,
      default: 'div'
    },
    offset: Number,
    pull: Number,
    push: Number,
    xs: [Number, Object],
    sm: [Number, Object],
    md: [Number, Object],
    lg: [Number, Object],
    xl: [Number, Object]
  },
  computed: {
    gutter() {
      let parent = this.$parent;
      while (parent && parent.$options.componentName !== 'ElRow') {
        parent = parent.$parent;
      }
      return parent ? parent.gutter : 0;
    }
  },
  render(h) {
    const classList = [];
    const style = {};
    if (this.gutter) {
      style.paddingLeft = this.gutter / 2 + 'px';
      style.paddingRight = style.paddingLeft;
    }
    ['span', 'offset', 'pull', 'push'].forEach(prop => {
      if (this[prop]) {
        classList.push(prop !== 'span' ? `el-col-${prop}-${this[prop]}` : `el-col-${this[prop]}`);
      }
    });
    ['xs', 'sm', 'md', 'lg', 'xl'].forEach(size => {
      if (typeof this[size] === 'number') {
        classList.push(`el-col-${size}-${this[size]}`);
      } else if (typeof this[size] === 'object') {
        const props = this[size];
        Object.keys(props).forEach(prop => {
          classList.push(prop !== 'span' ? `el-col-${size}-${prop}-${props[prop]}` : `el-col-${size}-${props[prop]}`);
        });
      }
    });
    return h(this.tag, {
      class: ['el-col', classList],
      style
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./packages/col/index.js


/* istanbul ignore next */
col.install = function (Vue) {
  Vue.component(col.name, col);
};
/* harmony default export */ var packages_col = (col);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/form/src/form-item.vue?vue&type=script&lang=js&





/* harmony default export */ var form_itemvue_type_script_lang_js_ = ({
  name: 'ElFormItem',
  componentName: 'ElFormItem',
  inject: ['elForm'],
  components: {
    ElTooltip: packages_tooltip,
    ElCol: packages_col
  },
  mixins: [emitter],
  props: {
    label: {
      type: String,
      default: ''
    },
    labelWidth: {
      type: String,
      default: null
    },
    prop: {
      type: String,
      default: null
    },
    required: {
      type: Boolean,
      default: undefined
    },
    // 必填选项显示在文字右侧
    requiredRight: {
      type: Boolean
    },
    rules: {
      type: [Object, Array],
      default: null
    },
    error: {
      type: String,
      default: null
    },
    validateStatus: {
      type: String,
      default: null
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    description: {
      type: String,
      default: ''
    },
    descriptionRender: {
      type: Function,
      default: null
    },
    // 内容区域宽度(会覆盖父组件的 contentWidth)
    contentWidth: {
      type: String,
      default: null
    },
    introduction: {
      type: String,
      default: ''
    },
    introductionIcon: {
      type: String,
      default: 'h-icon-info'
    },
    introductionPlacement: {
      type: String,
      default: 'bottom'
    },
    introductionClass: {
      type: String,
      default: ''
    },
    itemGroup: {
      type: Boolean,
      default: false
    },
    labelGrid: {
      type: Object,
      default: null
    },
    contentGrid: {
      type: Object,
      default: null
    },
    // 标签过长是否显示省略号
    labelOverflowTitle: {
      type: Boolean,
      default: true
    },
    // 禁用时，将不再显示必填标识
    disabled: {
      type: Boolean,
      default: false
    },
    beforeValidate: {
      type: Function,
      default: null
    },
    showEllipsis: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      validateState: '',
      validateMessage: '',
      validateDisabled: false,
      validator: {},
      // 标签过长时显示的title
      labelTitle: ''
    };
  },
  computed: {
    // 表单项 style 样式
    itemStyle() {
      const ret = {};
      const defaultGutter = 20; // 默认间距为20px
      if (!this.form.gutter) return ret;
      ret.marginBottom = this.validateState !== 'error' ? `${this.form.gutter}px` : `${this.form.gutter - defaultGutter}px`;
      return ret;
    },
    labelStyle() {
      const ret = {};
      // 设置标签在上方或者栅格布局，label-width 将失效
      if (this.form.labelPosition === 'top' || this.form.gridLayout) return ret;
      const labelWidth = this.labelWidth || this.form.labelWidth;
      if (labelWidth) {
        ret.width = labelWidth;
      }
      return ret;
    },
    labelTextStyle() {
      const ret = {};
      let width = 0;
      // 表单项必填时，高亮红星占9px
      if (this.isRequired() || this.required || this.requiredRight) width += 9;
      // 有介绍信息时，图标占26px
      if (this.introduction) width += 26;
      if (width) ret.maxWidth = `calc(100% - ${width}px)`;
      return ret;
    },
    contentStyle() {
      const ret = {};
      // 设置栅格布局，content-width 将失效
      if (this.form.gridLayout) return ret;
      const label = this.label;
      const contentWidth = this.contentWidth || this.form.contentWidth;
      if (contentWidth) {
        ret.width = contentWidth;
      }
      if (this.form.labelPosition === 'top' || this.form.inline) return ret;
      if (!label && !this.labelWidth && this.isNested) return ret;
      const labelWidth = this.labelWidth || this.form.labelWidth;
      if (labelWidth) {
        ret.marginLeft = labelWidth;
      }
      return ret;
    },
    // 错误信息的样式
    errorStyle() {
      const ret = {};
      const labelWidth = this.labelWidth || this.form.labelWidth;
      const contentWidth = this.contentWidth || this.form.contentWidth;
      const label = this.label;
      // 判断错误信息出现在底部还是右侧
      if (this.form.messagePosition === 'right') {
        ret.position = 'absolute';
        if (!label && !this.labelWidth && this.isNested) {
          ret.left = parseInt(contentWidth, 10) + 8 + 'px';
        } else {
          ret.left = parseInt(labelWidth, 10) + parseInt(contentWidth, 10) + 8 + 'px';
        }
        // 错误信息出现在右侧时，top值设置6px
        ret.top = '6px';
      } else {
        // if (!label && !this.labelWidth && this.isNested) {
        //   ret.left = '0';
        // } else {
        //   ret.left = labelWidth;
        // }
      }
      return ret;
    },
    _labelGrid() {
      return this.labelGrid || this.form.labelGrid;
    },
    _contentGrid() {
      return this.contentGrid || this.form.contentGrid;
    },
    _labelOverflowTitle() {
      if (!this.labelOverflowTitle) return false;
      return this.form.labelOverflowTitle;
    },
    // 是否是嵌套的item
    isNested() {
      let parent = this.$parent;
      let parentName = parent.$options.componentName;
      while (parentName !== 'ElFormItem') {
        parent = parent.$parent;
        if (!parent || !parent.$options) break;
        parentName = parent.$options.componentName;
      }
      if (parentName === 'ElFormItem') return true;else return false;
    },
    form() {
      let parent = this.$parent;
      let parentName = parent.$options.componentName;
      while (parentName !== 'ElForm') {
        parent = parent.$parent;
        parentName = parent.$options.componentName;
      }
      return parent;
    },
    fieldValue: {
      cache: false,
      get() {
        var model = this.form.model;
        if (!model || !this.prop) {
          return;
        }
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        return getPropByPath(model, path, true).v;
      }
    }
  },
  watch: {
    error(value) {
      this.validateMessage = value;
      this.validateState = value ? 'error' : '';
    },
    validateStatus(value) {
      this.validateState = value;
    }
  },
  mounted() {
    if (this.prop) {
      this.dispatch('ElForm', 'el.form.addField', [this]);
      let initialValue = this.fieldValue;
      if (Array.isArray(initialValue)) {
        initialValue = [].concat(initialValue);
      }
      Object.defineProperty(this, 'initialValue', {
        value: initialValue
      });
      this.setItemRule();
    }
  },
  beforeDestroy() {
    this.dispatch('ElForm', 'el.form.removeField', [this]);
  },
  methods: {
    isRequired() {
      const rules = this.getRules();
      let isRequired = false;
      if (rules && rules.length) {
        rules.every(rule => {
          if (rule.required) {
            isRequired = true;
            return false;
          }
          return true;
        });
      }
      return isRequired;
    },
    focusField() {
      const elInput = findComponentsDownward(this, 'ElInput')[0];
      if (elInput) {
        elInput.$el.querySelector('input') && elInput.$el.querySelector('input').focus();
        elInput.$el.querySelector('textarea') && elInput.$el.querySelector('textarea').focus();
      }
    },
    validate(trigger, callback = noop) {
      this.validateDisabled = false;
      var rules = this.getFilteredRule(trigger);
      if ((!rules || rules.length === 0) && this.required === undefined) {
        callback();
        return true;
      }
      const todo = () => {
        this.validateState = 'validating';
        var descriptor = {};
        descriptor[this.prop] = rules;
        var validator = new external_async_validator_default.a(descriptor);
        var model = {};

        // 获取所有字段的值
        for (const field of this.form.fields) {
          model[field.prop] = field.fieldValue;
        }
        validator.validate(model, {
          firstFields: true
        }, (errors, invalidFields) => {
          this.validateState = !errors ? 'success' : 'error';
          this.validateMessage = errors ? errors[0].message : '';
          callback(this.validateMessage, invalidFields);
          this.elForm && this.elForm.$emit('validate', this.prop, !errors);
        });
      };
      if (this.beforeValidate) {
        let result = this.beforeValidate(this.fieldValue, rules);
        if (result === false) return;
        if (result === undefined) result = true;
        Promise.resolve(result).then(allowed => {
          if (allowed) {
            todo();
          }
        });
      } else {
        todo();
      }
    },
    resetField(isEmpty = false) {
      this.validateState = '';
      this.validateMessage = '';
      const model = this.form.model;
      const value = this.fieldValue;
      let path = this.prop;
      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }
      const prop = getPropByPath(model, path, true, path.indexOf('.') > -1);
      if (Array.isArray(value)) {
        this.validateDisabled = true;
        prop.o[prop.k] = isEmpty ? [] : [].concat(this.initialValue);
      } else {
        this.validateDisabled = true;
        prop.o[prop.k] = isEmpty ? '' : this.initialValue;
      }
    },
    resetValidate(isResetRule = false) {
      this.validateState = '';
      this.validateMessage = '';
      this.validateDisabled = false;
      isResetRule && this.setItemRule();
    },
    getRules() {
      var formRules = this.form.rules;
      var selfRules = this.rules;
      var requiredRule = this.required !== undefined ? {
        required: !!this.required
      } : [];
      formRules = formRules ? formRules[this.prop] : [];
      return [].concat(selfRules || formRules || []).concat(requiredRule);
    },
    getFilteredRule(trigger) {
      var rules = this.getRules();
      return rules.filter(rule => {
        return !rule.trigger || rule.trigger.indexOf(trigger) !== -1;
      });
    },
    onFieldBlur() {
      this.$nextTick(() => {
        this.validate('blur');
      });
    },
    onFieldChange() {
      if (this.validateDisabled) {
        this.validateDisabled = false;
        return;
      }
      this.$nextTick(() => {
        this.validate('change');
      });
    },
    hoverLabel() {
      const t = this.$refs.formLabelText;
      this.labelTitle = t.clientWidth <= t.scrollWidth ? t.innerText : '';
    },
    /**
     * @desc 获取 content 的断点
     * @param {String} grid 断点值，如xs、sm、md、lg、xl
     */
    getContentGrid(grid) {
      if (!this._contentGrid[grid]) return;
      const result = typeof this._contentGrid[grid] === 'number' ? {
        span: this._contentGrid[grid],
        offset: this._labelGrid[grid]
      } : this._contentGrid[grid];
      return result;
    },
    setItemRule() {
      const rules = this.getRules();
      if (rules.length || this.required !== undefined) {
        this.$off('el.form.blur', this.onFieldBlur);
        this.$off('el.form.change', this.onFieldChange);
        this.$on('el.form.blur', this.onFieldBlur);
        this.$on('el.form.change', this.onFieldChange);
      }
    }
  },
  render(h) {
    const labelCls = {
      'el-form-item__label': true,
      'text-wrap': !this._labelOverflowTitle // 若设置文字超长不显示省略号
    };
    // 表格标签：label
    let labelElm = h("label", {
      "attrs": {
        "for": this.prop
      },
      "class": labelCls,
      "style": this.labelStyle,
      "on": {
        "mouseenter": this.hoverLabel
      }
    }, [h("i", {
      "class": 'el-form-item__required'
    }, ["*"]), h("span", {
      "ref": 'formLabelText',
      "class": 'el-form-item__label-text',
      "attrs": {
        "title": this.labelTitle
      },
      "style": this.labelTextStyle
    }, [this.$slots.label || this.label + this.form.labelSuffix]), h("i", {
      "class": 'el-form-item__required-right'
    }, ["*"])]);

    // 介绍文字
    const introElm = h("el-tooltip", {
      "attrs": {
        "content": this.$slots.introduction ? '' : this.introduction,
        "placement": this.introductionPlacement,
        "popper-class": this.introductionClass
      }
    }, [h("template", {
      "slot": 'content'
    }, [this.$slots.introduction]), h("i", {
      "class": ['el-form-item__introduction', this.introductionIcon]
    })]);
    if (this.introduction !== '' || this.$slots.introduction) {
      this.form.labelPosition === 'top' ? labelElm.children.push(introElm) : labelElm.children.splice(0, 0, introElm);
    }

    // 表格内容：content
    let contentElm = h("div", {
      "class": 'el-form-item__content',
      "style": this.contentStyle
    }, [this.$slots.default]);
    const errorCls = {
      'el-form-item__error': true,
      'el-form-item__ellipsis': this.showEllipsis
    };
    // 错误信息
    const errorElm = h("transition", {
      "attrs": {
        "name": 'form-error-zoom'
      }
    }, [h("div", {
      "attrs": {
        "title": this.showEllipsis ? this.validateMessage : ''
      },
      "class": errorCls,
      "style": this.errorStyle
    }, [this.validateMessage])]);
    if (this.validateState === 'error' && this.showMessage && this.form.showMessage) {
      contentElm.children.push(errorElm);
    }

    // 描述信息
    const descElm = h("div", {
      "class": 'el-form-item__description'
    });
    if (this.description !== '') {
      descElm.children = [h("span", [this.description])];
      contentElm.children.push(descElm);
    }
    if (this.descriptionRender) {
      descElm.children = [this.descriptionRender.call(this._renderProxy, h)];
      contentElm.children.push(descElm);
    }

    // 使用栅格布局
    if (this.form.gridLayout) {
      labelElm = h("el-col", {
        "attrs": {
          "xs": this._labelGrid.xs,
          "sm": this._labelGrid.sm,
          "md": this._labelGrid.md,
          "lg": this._labelGrid.lg,
          "xl": this._labelGrid.xl
        }
      }, [labelElm]);
      // 没有 label，则内容进行偏移
      contentElm = this.$slots.label || this.label ? h("el-col", {
        "attrs": {
          "xs": this._contentGrid.xs,
          "sm": this._contentGrid.sm,
          "md": this._contentGrid.md,
          "lg": this._contentGrid.lg,
          "xl": this._contentGrid.xl
        }
      }, [contentElm]) : h("el-col", {
        "attrs": {
          "xs": this.getContentGrid('xs'),
          "sm": this.getContentGrid('sm'),
          "md": this.getContentGrid('md'),
          "lg": this.getContentGrid('lg'),
          "xl": this.getContentGrid('xl')
        }
      }, [contentElm]);
    }
    const cls = {
      'el-form-item': true,
      'is-item-group': this.itemGroup,
      'is-error': this.validateState === 'error',
      'is-show-error-message': this.validateState === 'error' && this.form.showMessage && this.showMessage,
      'is-validating': this.validateState === 'validating',
      'is-required': (this.isRequired() || this.required) &&
      // 后续默认定规定位置，考虑把requiredRight属性移除
      !this.requiredRight && this.form.labelPosition !== 'top' && !this.disabled,
      'is-required-right': (this.isRequired() || this.required) && (this.requiredRight || this.form.labelPosition === 'top') && !this.disabled,
      'has-introduction': this.introduction !== '',
      'has-description': this.description !== '' || this.descriptionRender
    };
    return this.label || this.$slots.label ? h("div", {
      "class": cls,
      "style": this.itemStyle
    }, [labelElm, contentElm]) : h("div", {
      "class": cls,
      "style": this.itemStyle
    }, [contentElm]);
  }
});
// CONCATENATED MODULE: ./packages/form/src/form-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_form_itemvue_type_script_lang_js_ = (form_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/form/src/form-item.vue
var form_item_render, form_item_staticRenderFns




/* normalize component */

var form_item_component = normalizeComponent(
  src_form_itemvue_type_script_lang_js_,
  form_item_render,
  form_item_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var form_item = (form_item_component.exports);
// CONCATENATED MODULE: ./packages/form-item/index.js


/* istanbul ignore next */
form_item.install = function (Vue) {
  Vue.component(form_item.name, form_item);
};
/* harmony default export */ var packages_form_item = (form_item);
// EXTERNAL MODULE: external "@vue/babel-helper-vue-jsx-merge-props"
var babel_helper_vue_jsx_merge_props_ = __webpack_require__("5a5e");
var babel_helper_vue_jsx_merge_props_default = /*#__PURE__*/__webpack_require__.n(babel_helper_vue_jsx_merge_props_);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=template&id=54a01e74&
var tab_barvue_type_template_id_54a01e74_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-tabs__active-bar",class:("is-" + (_vm.rootTabs.tabPosition)),style:(_vm.barStyle)})}
var tab_barvue_type_template_id_54a01e74_staticRenderFns = []


// CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=template&id=54a01e74&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//


/* harmony default export */ var tab_barvue_type_script_lang_js_ = ({
  name: 'TabBar',
  props: {
    tabs: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  inject: ['rootTabs'],
  computed: {
    barStyle: {
      get() {
        const style = {};
        let offset = 0;
        let tabSize = 0;
        const sizeName = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
        const sizeDir = sizeName === 'width' ? 'x' : 'y';
        const firstUpperCase = str => {
          return str.toLowerCase().replace(/( |^)[a-z]/g, L => L.toUpperCase());
        };
        // 此处取走了index, 因下面的语句块并未使用到Index
        this.tabs.every(tab => {
          const $el = arrayFind(this.$parent.$refs.tabs || [], t => t.id.replace('tab-', '') === tab.paneName);
          if (!$el) {
            return false;
          }
          if (!tab.active) {
            offset += $el[`client${firstUpperCase(sizeName)}`];
            return true;
          } else {
            tabSize = $el[`client${firstUpperCase(sizeName)}`];
            // if (sizeName === 'width' && this.tabs.length > 1) {
            //   tabSize -= index === 0 || index === this.tabs.length - 1 ? 0 : 24;
            // }
            return false;
          }
        });
        if (sizeName === 'width' && offset !== 0) {
          // offset += 24;
        }
        const transform = `translate${firstUpperCase(sizeDir)}(${offset}px)`;
        style[sizeName] = tabSize + 'px';
        style.transform = transform;
        style.msTransform = transform;
        style.webkitTransform = transform;
        return style;
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tab_barvue_type_script_lang_js_ = (tab_barvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue





/* normalize component */

var tab_bar_component = normalizeComponent(
  src_tab_barvue_type_script_lang_js_,
  tab_barvue_type_template_id_54a01e74_render,
  tab_barvue_type_template_id_54a01e74_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tab_bar = (tab_bar_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&


function tab_navvue_type_script_lang_js_noop() {}
const tab_navvue_type_script_lang_js_firstUpperCase = str => {
  return str.toLowerCase().replace(/( |^)[a-z]/g, L => L.toUpperCase());
};
/* harmony default export */ var tab_navvue_type_script_lang_js_ = ({
  name: 'TabNav',
  components: {
    TabBar: tab_bar
  },
  inject: ['rootTabs'],
  props: {
    panes: {
      type: Array,
      default() {
        return [];
      }
    },
    currentName: {
      type: String,
      default: ''
    },
    editable: {
      type: Boolean,
      default: null
    },
    onTabClick: {
      type: Function,
      default: tab_navvue_type_script_lang_js_noop
    },
    onScrollStatusChange: {
      type: Function,
      default: tab_navvue_type_script_lang_js_noop
    },
    onTabRemove: {
      type: Function,
      default: tab_navvue_type_script_lang_js_noop
    },
    type: {
      type: String,
      default: ''
    },
    stretch: {
      type: Boolean,
      default: null
    },
    labelMaxWidth: {
      type: Number,
      default: 192
    },
    fixWidth: {
      type: Number,
      default: null
    }
  },
  data() {
    return {
      scrollable: true,
      navOffset: 0,
      isFocus: false,
      focusable: true,
      scrollableNext: false,
      scrollablePrev: false
    };
  },
  computed: {
    navStyle() {
      const dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y';
      return {
        transform: `translate${dir}(-${this.navOffset}px)`
      };
    },
    sizeName() {
      return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';
    }
  },
  watch: {
    scrollable(value) {
      this.onScrollStatusChange(!!value);
    }
  },
  updated() {
    this.update();
  },
  mounted() {
    addResizeListener(this.$el, this.update);
    document.addEventListener('visibilitychange', this.visibilityChangeHandler);
    window.addEventListener('blur', this.windowBlurHandler);
    window.addEventListener('focus', this.windowFocusHandler);
    setTimeout(() => {
      this.scrollToActiveTab();
    }, 0);
  },
  beforeDestroy() {
    if (this.$el && this.update) removeResizeListener(this.$el, this.update);
    document.removeEventListener('visibilitychange', this.visibilityChangeHandler);
    window.removeEventListener('blur', this.windowBlurHandler);
    window.removeEventListener('focus', this.windowFocusHandler);
  },
  methods: {
    scrollPrev() {
      const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
      const currentOffset = this.navOffset;
      if (!currentOffset) {
        this.scrollable && this.scrollablePrev && this.$nextTick(function () {
          this.scrollablePrev = false;
          this.$set(this.scrollable, 'prev', false);
        });
        return;
      }
      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
      this.navOffset = newOffset;
    },
    scrollNext() {
      const navSize = this.$refs.nav[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
      const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)}`];
      const currentOffset = this.navOffset;
      if (navSize - currentOffset <= containerSize) {
        this.scrollable && this.scrollableNext && this.$nextTick(function () {
          this.scrollableNext = false;
          this.$set(this.scrollable, 'next', false);
        });
        return;
      }
      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
      this.navOffset = newOffset;
    },
    scrollToActiveTab() {
      if (!this.scrollable) return;
      const nav = this.$refs.nav;
      const activeTab = this.$el.querySelector('.is-active');
      if (!activeTab) return;
      const navScroll = this.$refs.navScroll;
      const isHorizontal = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1;
      const activeTabBounding = activeTab.getBoundingClientRect();
      const navScrollBounding = navScroll.getBoundingClientRect();
      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
      const currentOffset = this.navOffset;
      let newOffset = currentOffset;
      if (isHorizontal) {
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
      } else {
        if (activeTabBounding.top < navScrollBounding.top) {
          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
        }
        if (activeTabBounding.bottom > navScrollBounding.bottom) {
          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
        }
      }
      newOffset = Math.max(newOffset, 0);
      this.navOffset = Math.min(newOffset, maxOffset);
    },
    update() {
      if (!this.$refs.nav) return;
      const sizeName = this.sizeName;
      const navSize = this.$refs.nav[`offset${tab_navvue_type_script_lang_js_firstUpperCase(sizeName)}`];
      const containerSize = this.$refs.navScroll[`offset${tab_navvue_type_script_lang_js_firstUpperCase(sizeName)}`];
      const wrapSize = this.$refs.navWrap[`offset${tab_navvue_type_script_lang_js_firstUpperCase(sizeName)}`];
      const currentOffset = this.navOffset;
      // 出现滚动条就加入双向箭头
      if (wrapSize < navSize) {
        const currentOffset = this.navOffset;
        this.scrollable = this.scrollable || {};
        this.scrollablePrev = currentOffset;
        this.scrollableNext = currentOffset + containerSize < navSize;
        if (navSize - currentOffset < containerSize) {
          this.navOffset = navSize - containerSize;
        }
      } else {
        this.scrollable = false;
        if (currentOffset > 0) {
          this.navOffset = 0;
        }
      }
    },
    changeTab(e) {
      const keyCode = e.keyCode;
      let nextIndex;
      let currentIndex, tabList;
      if ([37, 38, 39, 40].indexOf(keyCode) !== -1) {
        // 左右上下键更换tab
        tabList = e.currentTarget.querySelectorAll('[role=tab]');
        currentIndex = Array.prototype.indexOf.call(tabList, e.target);
      } else {
        return;
      }
      if (keyCode === 37 || keyCode === 38) {
        // left
        if (currentIndex === 0) {
          // first
          nextIndex = tabList.length - 1;
        } else {
          nextIndex = currentIndex - 1;
        }
      } else {
        // right
        if (currentIndex < tabList.length - 1) {
          // not last
          nextIndex = currentIndex + 1;
        } else {
          nextIndex = 0;
        }
      }
      tabList[nextIndex].focus(); // 改变焦点元素
      tabList[nextIndex].click(); // 选中下一个tab
      this.setFocus();
    },
    setFocus() {
      if (this.focusable) {
        this.isFocus = true;
      }
    },
    removeFocus() {
      this.isFocus = false;
    },
    visibilityChangeHandler() {
      const visibility = document.visibilityState;
      if (visibility === 'hidden') {
        this.focusable = false;
      } else if (visibility === 'visible') {
        setTimeout(() => {
          this.focusable = true;
        }, 50);
      }
    },
    windowBlurHandler() {
      this.focusable = false;
    },
    windowFocusHandler() {
      setTimeout(() => {
        this.focusable = true;
      }, 50);
    }
  },
  render() {
    const h = arguments[0];
    const {
      type,
      panes,
      editable,
      stretch,
      onTabClick,
      onTabRemove,
      navStyle,
      scrollable,
      scrollableNext,
      scrollablePrev,
      scrollNext,
      scrollPrev,
      changeTab,
      setFocus,
      removeFocus
    } = this;
    const scrollBtn = scrollable ? [// <span
    //   class={['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled']}
    //   on-click={scrollPrev}
    // >
    //   <i class="h-icon-angle_left" />
    // </span>
    h("div", {
      "class": 'el-tabs__nav-prev'
    }, [h("el-button", {
      "attrs": {
        "type": 'iconButton',
        "icon": this.rootTabs.tabPosition.indexOf('o') > 0 ? 'h-icon-angle_left' : 'h-icon-angle_up',
        "disabled": !scrollablePrev
      },
      "on": {
        "click": scrollPrev
      }
    })]), h("div", {
      "class": 'el-tabs__nav-next'
    }, [h("el-button", {
      "attrs": {
        "type": 'iconButton',
        "icon": this.rootTabs.tabPosition.indexOf('o') > 0 ? 'h-icon-angle_right' : 'h-icon-angle_down',
        "disabled": !scrollableNext
      },
      "on": {
        "click": scrollNext
      }
    })]) // <span
    //   class={['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled']}
    //   on-click={scrollNext}
    // >
    //   <i class="h-icon-angle_right" />
    // </span>
    ] : null;
    const notTheOnlyOne = panes.length !== 1;
    const tabs = this._l(panes, (pane, index) => {
      const tabName = pane.name || pane.index || index;
      const closable = pane.isClosable || editable;
      pane.index = `${index}`;
      const btnClose = closable && notTheOnlyOne ? h("el-button", {
        "attrs": {
          "icon": 'h-icon-close_sm'
        },
        "on": {
          "click": ev => {
            onTabRemove(pane, ev);
          }
        }
      }) : null;
      const fixWidth = this.fixWidth;
      const labelMaxWidth = pane.labelMaxWidth || this.labelMaxWidth;
      const tabSpanStyle = closable && notTheOnlyOne ? `max-width: ${fixWidth ? fixWidth - 50 : labelMaxWidth && labelMaxWidth - 50}px;overflow: hidden;display: inline-block;vertical-align: middle;text-overflow: ellipsis;white-space: nowrap;` : '';
      const tabLabelContent = pane.labelIcon ? h("i", {
        "class": ['el-tabs__item--icon', pane.labelIcon]
      }) : h("span", {
        "style": tabSpanStyle,
        "attrs": {
          "title": pane.label
        }
      }, [pane.$slots.label || pane.label]);
      const tabindex = pane.active ? 0 : -1;
      return h("div", {
        "class": {
          'el-tabs__item': true,
          [`is-${this.rootTabs.tabPosition}`]: true,
          'is-active': pane.active,
          'is-disabled': pane.disabled,
          'is-closable': closable && notTheOnlyOne,
          'is-focus': this.isFocus
        },
        "attrs": {
          "id": `tab-${tabName}`,
          "aria-controls": `pane-${tabName}`,
          "role": 'tab',
          "aria-selected": pane.active,
          "tabindex": tabindex
        },
        "key": `tab-${tabName}`,
        "ref": 'tabs',
        "refInFor": true,
        "style": {
          'min-width': fixWidth && `${fixWidth}px`,
          'max-width': fixWidth ? `${fixWidth}px` : labelMaxWidth && `${labelMaxWidth}px`
        },
        "on": {
          "focus": () => {
            setFocus();
          },
          "blur": () => {
            removeFocus();
          },
          "click": ev => {
            removeFocus();
            onTabClick(pane, tabName, ev);
          },
          "keydown": ev => {
            if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) {
              onTabRemove(pane, ev);
            }
          }
        }
      }, [tabLabelContent, btnClose]);
    });
    return h("div", {
      "class": ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : '', `is-${this.rootTabs.tabPosition}`],
      "ref": 'navWrap'
    }, [scrollBtn, h("div", {
      "class": ['el-tabs__nav-scroll'],
      "ref": 'navScroll'
    }, [h("div", {
      "class": ['el-tabs__nav', `is-${this.rootTabs.tabPosition}`, stretch && ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'is-stretch' : ''],
      "ref": 'nav',
      "style": navStyle,
      "attrs": {
        "role": 'tablist'
      },
      "on": {
        "keydown": changeTab
      }
    }, [!type ? h("tab-bar", {
      "attrs": {
        "tabs": panes
      }
    }) : null, tabs])])]);
  }
});
// CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tab_navvue_type_script_lang_js_ = (tab_navvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue
var tab_nav_render, tab_nav_staticRenderFns




/* normalize component */

var tab_nav_component = normalizeComponent(
  src_tab_navvue_type_script_lang_js_,
  tab_nav_render,
  tab_nav_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tab_nav = (tab_nav_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tabs.vue?vue&type=script&lang=js&


/* harmony default export */ var tabsvue_type_script_lang_js_ = ({
  name: 'ElTabs',
  components: {
    TabNav: tab_nav
  },
  props: {
    type: {
      type: String,
      default: ''
    },
    activeName: {
      type: String,
      default: ''
    },
    closable: {
      type: Boolean,
      default: null
    },
    addable: {
      type: Boolean,
      default: null
    },
    value: {
      type: String,
      default: ''
    },
    editable: {
      type: Boolean,
      default: null
    },
    tabPosition: {
      type: String,
      default: 'top'
    },
    beforeLeave: {
      type: Function,
      default: () => () => {}
    },
    beforeRemove: {
      type: Function,
      default: () => () => {}
    },
    stretch: {
      type: Boolean,
      default: null
    },
    labelMaxWidth: {
      type: Number,
      default: 192
    },
    fixWidth: {
      type: Number,
      default: null
    },
    size: {
      type: String,
      default: 'medium'
    }
  },
  provide() {
    return {
      rootTabs: this
    };
  },
  data() {
    return {
      currentName: this.value || this.activeName,
      panes: [],
      isButtonGroup: false
    };
  },
  watch: {
    activeName(value) {
      this.setCurrentName(value);
    },
    value(value) {
      this.setCurrentName(value);
    },
    currentName() {
      if (this.$refs.nav) {
        this.$nextTick(() => {
          this.$refs.nav.$nextTick(() => {
            this.scrollToActiveTab();
          });
        });
      }
    }
  },
  created() {
    if (!this.currentName) {
      this.setCurrentName('0');
    }
    this.$on('tab-nav-update', this.calcPaneInstances.bind(null, true));
  },
  mounted() {
    this.calcPaneInstances();
  },
  updated() {
    this.calcPaneInstances();
  },
  methods: {
    calcPaneInstances(isForceUpdate = false) {
      if (this.$slots.default) {
        const paneSlots = this.$slots.default.filter(vnode => vnode.tag && vnode.componentOptions && vnode.componentOptions.Ctor.options.name === 'ElTabPane');
        // update indeed
        const panes = paneSlots.map(({
          componentInstance
        }) => componentInstance);
        const panesChanged = !(panes.length === this.panes.length && panes.every((pane, index) => pane === this.panes[index]));
        if (isForceUpdate || panesChanged) {
          this.panes = panes;
        }
      } else if (this.panes.length !== 0) {
        this.panes = [];
      }
    },
    handleTabClick(tab, tabName, event) {
      if (tab.disabled) return;
      this.setCurrentName(tabName, () => {
        this.$emit('tab-click', tab, event);
      });
    },
    handleTabRemove(pane, ev) {
      if (pane.disabled) return;
      ev.stopPropagation();
      const hdRemove = () => {
        this.$emit('edit', pane.name, 'remove');
        this.$emit('tab-remove', pane.name);
      };
      const before = this.beforeRemove(pane.name);
      if (before && before.then) {
        before.then(() => {
          hdRemove();
        });
      } else {
        hdRemove();
      }
    },
    handleTabAdd() {
      this.$emit('edit', null, 'add');
      this.$emit('tab-add');
    },
    setCurrentName(value, cb) {
      const changeCurrentName = () => {
        this.currentName = value;
        this.$emit('input', value);
        cb && cb();
      };
      if (this.currentName !== value && this.beforeLeave) {
        const before = this.beforeLeave(value, this.currentName);
        if (before && before.then) {
          before.then(() => {
            changeCurrentName();
            this.$refs.nav && this.$refs.nav.removeFocus();
          });
        } else if (before !== false) {
          changeCurrentName();
        }
      } else {
        changeCurrentName();
      }
    },
    scrollChange(value) {
      this.isButtonGroup = value;
    },
    scrollToActiveTab() {
      this.$refs.nav.scrollToActiveTab();
    }
  },
  render() {
    const h = arguments[0];
    const {
      type,
      handleTabClick,
      handleTabRemove,
      handleTabAdd,
      currentName,
      panes,
      editable,
      addable,
      tabPosition,
      size,
      stretch,
      labelMaxWidth,
      fixWidth,
      scrollChange
    } = this;
    const newButton = editable || addable ? // <span
    // class="el-tabs__new-tab"
    // on-click={handleTabAdd}
    // tabindex="0"
    // on-keydown={ev => {
    //   if (ev.keyCode === 13) {
    //     handleTabAdd();
    //   }
    // }}
    // >
    //   <i class="h-icon-add" />
    // </span>
    h("div", {
      "class": {
        'el-tabs__new-tab': true,
        isButtonGroup: this.isButtonGroup
      }
    }, [h("el-button", {
      "attrs": {
        "type": 'iconButton',
        "icon": 'h-icon-add',
        "tabindex": '0'
      },
      "on": {
        "click": handleTabAdd,
        "keydown": ev => {
          if (ev.keyCode === 13) {
            handleTabAdd();
          }
        }
      }
    })]) : null;
    const navData = {
      props: {
        currentName,
        onTabClick: handleTabClick,
        onTabRemove: handleTabRemove,
        onScrollStatusChange: scrollChange,
        editable,
        type,
        panes,
        stretch,
        labelMaxWidth,
        fixWidth
      },
      ref: 'nav'
    };
    const header = h("div", {
      "class": ['el-tabs__header', `el-tabs--${size}`, `is-${tabPosition}`]
    }, [h("tab-nav", babel_helper_vue_jsx_merge_props_default()([{}, navData])), newButton]);
    const panels = h("div", {
      "class": 'el-tabs__content'
    }, [this.$slots.default]);
    return h("div", {
      "class": {
        'el-tabs': true,
        'el-tabs--card': type === 'card',
        [`el-tabs--${tabPosition}`]: true,
        'el-tabs--border-card': type === 'border-card'
      }
    }, [tabPosition !== 'bottom' ? [header, panels] : [panels, header]]);
  }
});
// CONCATENATED MODULE: ./packages/tabs/src/tabs.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tabsvue_type_script_lang_js_ = (tabsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tabs/src/tabs.vue
var tabs_render, tabs_staticRenderFns




/* normalize component */

var tabs_component = normalizeComponent(
  src_tabsvue_type_script_lang_js_,
  tabs_render,
  tabs_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tabs = (tabs_component.exports);
// CONCATENATED MODULE: ./packages/tabs/index.js


/* istanbul ignore next */
tabs.install = function (Vue) {
  Vue.component(tabs.name, tabs);
};
/* harmony default export */ var packages_tabs = (tabs);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-pane.vue?vue&type=template&id=fbab6158&
var tab_panevue_type_template_id_fbab6158_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.lazy || _vm.loaded || _vm.active)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.active),expression:"active"}],staticClass:"el-tab-pane",attrs:{"id":("pane-" + _vm.paneName),"aria-labelledby":("tab-" + _vm.paneName),"role":"tabpanel"}},[_vm._t("default")],2):_vm._e()}
var tab_panevue_type_template_id_fbab6158_staticRenderFns = []


// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue?vue&type=template&id=fbab6158&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-pane.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var tab_panevue_type_script_lang_js_ = ({
  name: 'ElTabPane',
  componentName: 'ElTabPane',
  props: {
    label: {
      type: String,
      default: ''
    },
    labelIcon: {
      type: String,
      default: ''
    },
    labelContent: {
      type: Function,
      default: () => () => {}
    },
    name: {
      type: String,
      default: ''
    },
    closable: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    lazy: {
      type: Boolean,
      default: null
    },
    labelMaxWidth: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      index: null,
      loaded: false
    };
  },
  computed: {
    isClosable() {
      return this.closable || this.$parent.closable;
    },
    active() {
      return this.$parent.currentName === (this.name || this.index);
    },
    paneName() {
      return this.name || this.index;
    }
  },
  watch: {
    label() {
      this.$parent.$forceUpdate();
    },
    'this.$parent.currentName'(val) {
      if (val === (this.name || this.index)) this.loaded = true;
    }
  },
  updated() {
    this.$parent.$emit('tab-nav-update');
  }
});
// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tab_panevue_type_script_lang_js_ = (tab_panevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.vue





/* normalize component */

var tab_pane_component = normalizeComponent(
  src_tab_panevue_type_script_lang_js_,
  tab_panevue_type_template_id_fbab6158_render,
  tab_panevue_type_template_id_fbab6158_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tab_pane = (tab_pane_component.exports);
// CONCATENATED MODULE: ./packages/tab-pane/index.js


/* istanbul ignore next */
tab_pane.install = function (Vue) {
  Vue.component(tab_pane.name, tab_pane);
};
/* harmony default export */ var packages_tab_pane = (tab_pane);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=template&id=b04ec82e&
var treevue_type_template_id_b04ec82e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.wrapContainer,{ref:"scrollbar",tag:"component",attrs:{"wrap-class":"el-tree-scrollbar__wrap","view-class":"el-tree-scrollbar__view"},on:{"on-scrolling-x":_vm.onScrollingX,"on-scrolling-y":_vm.onScrollingY}},[_c('div',{staticClass:"el-tree",class:{
      'el-tree--highlight-current': _vm.highlightCurrent,
      'is-moving': _vm.moveConfig.moveFlag,
      'has-border': _vm.border
    }},[_vm._l((_vm.root.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"node":child,"props":_vm.defaultProps,"render-after-expand":_vm.renderAfterExpand,"render-when-expand":_vm.renderWhenExpand,"render-content":_vm.renderContent,"prefix-content":_vm.prefixContent},on:{"node-expand":_vm.handleNodeExpand,"node-collapse":_vm.handleNodeCollapse}})}),(!_vm.root.childNodes || _vm.root.childNodes.length === 0 || !_vm.root.visible)?_c('div',{staticClass:"el-tree__empty-block"},[(_vm.$scopedSlots.empty)?_vm._t("empty"):_c('span',{staticClass:"el-tree__empty-text"},[_vm._v(_vm._s(_vm.emptyText))])],2):_vm._e(),(_vm.moveConfig.moveFlag)?_c('div',{staticClass:"el-tree__move-block",style:(_vm.moveBlockStyle)},[_c('div',{staticClass:"el-tree-node__content",domProps:{"innerHTML":_vm._s(_vm.moveConfig.nodeHtml)}})]):_vm._e(),(_vm.moveConfig.moveFlag && _vm.moveConfig.arrowFlag)?_c('div',{staticClass:"el-tree__move-arrow",style:({
        top: _vm.moveConfig.arrowTop + 'px',
        left: _vm.moveConfig.arrowLeft + 'px'
      })}):_vm._e()],2)])}
var treevue_type_template_id_b04ec82e_staticRenderFns = []


// CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=template&id=b04ec82e&

// CONCATENATED MODULE: ./packages/tree/src/model/util.js
const NODE_KEY = '$treeNodeId';
const markNodeData = function (node, data) {
  if (data[NODE_KEY]) return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
const getNodeKey = function (key, data) {
  if (!key) return data[NODE_KEY];
  return data[key] || data.key;
};

/**
 * 判断传入的对象是否为数组
 * @author chenguanbin
 * @param {Object} [object] 传入的对象
 */
const isArray = function (object) {
  return object && typeof object === 'object' && Array === object.constructor;
};

/**
 * 返回当前页面相对于窗口显示区左上角的 X ，Y 的位置
 * @author chenguanbin
 * @param {boolean} [top] 是否是获取顶部的左上角的Y坐标
 */
const model_util_getScroll = function (top) {
  var ret = window['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = window.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
};

/**
 * 返回目标节点在容器中的位置
 * @author chenguanbin
 * @param {HTMLElement} [element] 需要获取位置的元素
 * @param {HTMLElement} [container = document.body] 容器元素
 */
const model_util_getOffset = function (element, container = document.body) {
  const elRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const clientTop = element.clientTop || container.clientTop || 0;
  const clientLeft = element.clientLeft || container.clientLeft || 0;
  let top, left;
  if (container === document.body) {
    top = model_util_getScroll(true);
    left = model_util_getScroll();
  } else {
    top = container.scrollTop - containerRect.top;
    left = container.scrollLeft - containerRect.left;
  }
  return {
    top: elRect.top + top - clientTop,
    left: elRect.left + left - clientLeft,
    right: elRect.right + left - clientLeft,
    bottom: elRect.bottom + top - clientTop
  };
};

/**
 * 格式化数据，将简单格式数据转化为tree需要使用的格式
 * @param {Array} treeData 树节点数据
 * @param {String} nodeKey 节点Key
 * @param {String} parentKey 父节点Key
 */
const formatData = function (treeData, nodeKey, parentKey) {
  const dataClone = JSON.parse(JSON.stringify(treeData)); // 将数据进行深度克隆，避免污染源数据
  const nodeIds = dataClone.map(item => {
    return item[nodeKey];
  }); // 所有ID的数组
  const target = []; // 目标数据
  const childNodes = []; // 除根节点以外的数据

  // 将根节点加入到target，其余节点加入到childNodes
  treeData.forEach(item => {
    if (nodeIds.indexOf(item[parentKey]) === -1) {
      target.push(item);
    } else {
      childNodes.push(item);
    }
  });

  // 按照父节点key进行分组
  const groupNodes = getGruopNodes(childNodes, parentKey);
  const traverse = parent => {
    for (const pId in groupNodes) {
      if (pId.toString() === parent[nodeKey].toString()) {
        parent.children = groupNodes[pId].nodes;
        groupNodes[pId].nodes.forEach(item => {
          traverse(item);
        });
      }
    }
  };
  target.forEach(item => {
    traverse(item);
  });
  return target;
};

/**
 * 数据按照父节点ID进行分组
 * @param {Array} childNodes 除根节点以外的数据
 * @param {String} parentKey 父节点Key
 */
const getGruopNodes = (childNodes, parentKey) => {
  const groups = {};
  childNodes.forEach(item => {
    const pId = item[parentKey];
    if (groups[pId]) {
      groups[pId].nodes.push(item);
    } else {
      groups[pId] = {
        nodes: new Array(item)
      };
    }
  });
  return groups;
};

/**
 * 判断传入对象的类型
 * @param {传入的对象} obj
 */
const getType = function (obj) {
  // tostring会返回对应不同的标签的构造函数
  const toString = Object.prototype.toString;
  const map = {
    '[object Boolean]': 'boolean',
    '[object Number]': 'number',
    '[object String]': 'string',
    '[object Function]': 'function',
    '[object Array]': 'array',
    '[object Date]': 'date',
    '[object RegExp]': 'regExp',
    '[object Undefined]': 'undefined',
    '[object Null]': 'null',
    '[object Object]': 'object'
  };
  if (obj instanceof Element) {
    return 'element';
  }
  return map[toString.call(obj)];
};

/**
 * 对象深度拷贝
 * @param {传入的对象} data
 */
const deepClone = function (data) {
  const type = getType(data);
  let obj;
  if (type === 'array') {
    obj = [];
  } else if (type === 'object') {
    obj = {};
  } else {
    // 不再具有下一层次
    return data;
  }
  if (type === 'array') {
    for (let i = 0, len = data.length; i < len; i++) {
      obj.push(deepClone(data[i]));
    }
  } else if (type === 'object') {
    for (const key in data) {
      obj[key] = deepClone(data[key]);
    }
  }
  return obj;
};
// CONCATENATED MODULE: ./packages/tree/src/model/node.js



const getChildState = node => {
  let all = true;
  let none = true;
  let allWithoutDisable = true;
  let noneWithoutDisable = true;
  let allDisabled = true;
  for (let i = 0, j = node.length; i < j; i++) {
    const n = node[i];
    if (n.checked !== true || n.indeterminate) {
      all = false;
      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n.checked !== false || n.indeterminate) {
      none = false;
      if (!n.disabled) {
        noneWithoutDisable = false;
      }
    }
    if (!n.disabled) {
      allDisabled = false;
    }
    if (!getChildState(n.childNodes).allWithoutDisable) {
      allWithoutDisable = false;
    }
  }
  return {
    all,
    none,
    allDisabled,
    allWithoutDisable,
    noneWithoutDisable,
    half: !all && !none
  };
};
const reInitChecked = function (node) {
  if (node.childNodes.length === 0 || node.disabled) return;
  const {
    all,
    none,
    half
  } = getChildState(node.childNodes);
  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }
  const parent = node.parent;
  if (!parent || parent.level === 0) return;
  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};

// const initLazyLoadChild = node => {
//   const childNodes = node.childNodes;
//   if (node.checked) {
//     for (let i = 0, j = childNodes.length; i < j; i++) {
//       const child = childNodes[i];
//       if (!child.disabled) {
//         child.checked = true;
//       }
//     }
//   }

//   const parent = node.parent;
//   if (!parent || parent.level === 0) return;
//   reInitChecked(parent);
// };

const getPropertyFromData = function (node, prop) {
  const props = node.store.props;
  const data = node.data || {};
  const config = props[prop];
  if (typeof config === 'function') {
    return config(data, node);
  } else if (typeof config === 'string') {
    return data[config];
  } else if (typeof config === 'undefined') {
    return '';
  }
};
let nodeIdSeed = 0;
class node_Node {
  constructor(options) {
    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.cacheExpanded = null;
    this.filtering = false;
    for (const name in options) {
      if (hasOwn(options, name)) {
        this[name] = options[name];
      }
    }

    // internal
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;
    if (this.parent) {
      this.level = this.parent.level + 1;
    }
    const store = this.store;
    if (!store) {
      throw new Error('[Node]store is required!');
    }
    store.registerNode(this);
    const props = store.props;
    if (props && typeof props.isLeaf !== 'undefined') {
      const isLeaf = getPropertyFromData(this, 'isLeaf');
      if (typeof isLeaf === 'boolean') {
        this.isLeafByUser = isLeaf;
      }
    }
    if (store.lazy !== true && this.data || this.data && options.loadedBeforeMove && options.loadedChildren) {
      this.setData(this.data, options.loadedChildren);
      if (store.defaultExpandAll) {
        this.expanded = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }
    if (!this.data) return;
    const defaultExpandedKeys = store.defaultExpandedKeys;
    const key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
      this.expand(null, store.autoExpandParent);
    }
    if (key && (store.currentNodeKey || store.currentNodeKey === 0) && this.key === store.currentNodeKey) {
      store.currentNode = this;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }
    this.updateLeafState();
  }
  setData(data, loadedChildren) {
    if (!Array.isArray(data)) {
      markNodeData(this, data);
    }
    this.data = data;
    this.childNodes = [];
    let children;
    if (loadedChildren) {
      children = loadedChildren;
    } else if (this.level === 0 && this.data instanceof Array) {
      children = this.data;
    } else {
      children = getPropertyFromData(this, 'children') || [];
    }
    for (let i = 0, j = children.length; i < j; i++) {
      this.insertChild({
        data: children[i]
      });
    }
  }
  get svgIcon() {
    return getPropertyFromData(this, 'svgIcon');
  }
  get svgIconOffline() {
    return getPropertyFromData(this, 'svgIconOffline');
  }
  get svgIconColor() {
    return getPropertyFromData(this, 'svgIconColor');
  }
  get svgIconColorActive() {
    return getPropertyFromData(this, 'svgIconColorActive');
  }
  get svgIconRequire() {
    return getPropertyFromData(this, 'svgIconRequire');
  }
  get label() {
    return getPropertyFromData(this, 'label');
  }
  get key() {
    const nodeKey = this.store.key;
    if (this.data) return this.data[nodeKey];
    return null;
  }
  get disabled() {
    return getPropertyFromData(this, 'disabled');
  }
  get icon() {
    return getPropertyFromData(this, 'icon');
  }
  get selectable() {
    const selectable = getPropertyFromData(this, 'selectable');
    return typeof selectable === 'boolean' ? selectable : true;
  }
  insertChild(child, index, isSetLeafFalse, loadedBeforeMove, loadedChildren) {
    if (!child) throw new Error('insertChild error: child is required.');
    if (!(child instanceof node_Node)) {
      merge(child, {
        parent: this,
        store: this.store,
        loadedBeforeMove,
        loadedChildren
      });
      child = new node_Node(child);
    }
    child.level = this.level + 1;
    if (typeof index === 'undefined' || index < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index, 0, child);
    }
    this.updateLeafState(isSetLeafFalse);
    // isSetLeafFalse && (this.loaded = true);
  }
  insertBefore(child, ref, loadedBeforeMove, loadedChildren) {
    let index;
    if (ref) {
      index = this.childNodes.indexOf(ref);
    }
    this.insertChild(child, index, null, loadedBeforeMove, loadedChildren);
  }
  insertAfter(child, ref, loadedBeforeMove, loadedChildren) {
    let index;
    if (ref) {
      index = this.childNodes.indexOf(ref);
      if (index !== -1) index += 1;
    }
    this.insertChild(child, index, null, loadedBeforeMove, loadedChildren);
  }
  removeChild(child) {
    const index = this.childNodes.indexOf(child);
    if (index > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index, 1);
    }
    this.updateLeafState();
  }
  removeChildByData(data) {
    let targetNode = null;
    this.childNodes.forEach(node => {
      if (node.data === data) {
        targetNode = node;
      }
    });
    if (targetNode) {
      this.removeChild(targetNode);
    }
  }
  expand(callback, expandParent) {
    const done = () => {
      if (expandParent) {
        let parent = this.parent;
        while (parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      this.expanded = true;
      if (callback) callback();
    };
    if (this.shouldLoadData()) {
      this.loadNode(done);
    } else {
      if (this.store.lazy === true && this.store.load && this.loadedBeforeMove) {
        this.isLeaf = true;
      }
      done();
    }
  }
  loadNode(done) {
    this.loadData(data => {
      if (data instanceof Array) {
        if (this.checked) {
          this.setChecked(true, true);
        } else if (!this.store.checkStrictly) {
          reInitChecked(this);
        }
        done && done();
      }
    });
  }
  doCreateChildren(array, defaultProps = {}) {
    array.forEach(item => {
      this.insertChild(merge({
        data: item
      }, defaultProps));
    });
  }
  collapse() {
    this.expanded = false;
  }
  shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded && !this.isLeaf && !this.loadedBeforeMove;
  }
  updateLeafState(isSetLeafFalse) {
    if (isSetLeafFalse) {
      this.isLeaf = false;
      return;
    }
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(value, deep, recursion, passValue, rootOnly = false) {
    const {
      all,
      allWithoutDisable,
      allDisabled,
      noneWithoutDisable,
      half
    } = getChildState(this.childNodes);

    // 这里有个奇葩的处理，这个针对checkbox在半选情况下无法正确返回checked状态的问题
    // 比如存在父节点a, 子节点a-1、a-2、a-3（禁用），
    // 当勾选a-1和a-2后，勾选父节点a时会发现页面无响应（由于a-3（禁用）的影响）
    // 原因是勾选a-1和a-2后，父节点a在checkbox内部依然是未勾选状态

    // 这边判断此情况的逻辑是
    // 1.非叶子节点
    // 2.非联动勾选的节点
    // 3.子节点不全是禁用
    if (!this.isLeaf && !recursion && !allDisabled && !this.store.checkStrictly) {
      if (noneWithoutDisable && this.checked === false && value === false && half) {
        // 1.非禁用的子节点全不勾选
        // 2.当前checkbox返回的勾选状态是false
        // 3.当前也不是勾选状态
        // 4.节点半选
        value = true;
      } else if (!all && allWithoutDisable) {
        // 非禁用的子节点勾选，禁用的没勾
        value = false;
      }
    }
    this.indeterminate = value === 'half';
    this.checked = value === true;
    if (this.store.checkStrictly) return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      // if (!this.isLeaf && !all && allWithoutDisable) {
      //   this.checked = false;
      //   value = false;
      // }

      const handleDescendants = () => {
        if (deep) {
          const childNodes = this.childNodes;
          for (let i = 0, j = childNodes.length; i < j; i++) {
            const child = childNodes[i];
            passValue = passValue || value !== false;
            if (!child.disabled) {
              child.setChecked(passValue, deep, true, passValue);
            }
          }
          const {
            half,
            all,
            allDisabled
          } = getChildState(childNodes);
          if (!all && !allDisabled) {
            this.checked = all;
            this.indeterminate = half;
          }
        }
      };
      if (this.shouldLoadData()) {
        // Only work on lazy load data.
        this.loadData(() => {
          this.store.checkParentToChild && handleDescendants();
          reInitChecked(this);
        }, {
          checked: value !== false
        });
        return;
      } else {
        if (!this.disabled) {
          this.store.checkParentToChild && handleDescendants();
        }
      }
    }
    const parent = this.parent;
    if (!parent || parent.level === 0) return;
    if (!recursion && !rootOnly && this.store.checkChildToParent) {
      reInitChecked(parent);
    }
  }
  getChildren() {
    // this is data
    const data = this.data;
    if (!data) return null;
    const props = this.store.props;
    let children = 'children';
    if (props) {
      children = props.children || 'children';
    }
    if (data[children] === undefined) {
      data[children] = null;
    }
    return data[children];
  }
  updateChildren() {
    const newData = this.getChildren() || [];
    const oldData = this.childNodes.map(node => node.data);
    const newDataMap = {};
    const newNodes = [];
    newData.forEach((item, index) => {
      if (item[NODE_KEY]) {
        newDataMap[item[NODE_KEY]] = {
          index,
          data: item
        };
      } else {
        newNodes.push({
          index,
          data: item
        });
      }
    });
    oldData.forEach(item => {
      if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item);
    });
    newNodes.forEach(({
      index,
      data
    }) => {
      this.insertChild({
        data
      }, index);
    });
    this.updateLeafState();
  }
  loadData(callback, defaultProps = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
      this.loading = true;
      const resolve = children => {
        this.loaded = true;
        this.loading = false;
        this.childNodes = [];
        this.doCreateChildren(children, defaultProps);
        this.updateLeafState();
        if (callback) {
          callback.call(this, children);
        }
      };
      this.store.load(this, resolve);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  }
}
// CONCATENATED MODULE: ./packages/tree/src/model/tree-store.js



class tree_store_TreeStore {
  constructor(options) {
    this.currentNode = null;
    this.currentNodeKey = null;
    for (const option in options) {
      if (hasOwn(options, option)) {
        this[option] = options[option];
      }
    }
    this.nodesMap = {};
    this.root = new node_Node({
      data: this.data,
      store: this
    });
    if (this.lazy && this.load) {
      const loadFn = this.load;
      loadFn(this.root, data => {
        // this.root.doCreateChildren(data);
        if (this.simpleData) data = formatData(data, this.key, this.parentKey);
        this._initLazyNode(this.root, data);
        this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }
  _initLazyNode(node, data) {
    node.doCreateChildren(data);
    for (const item of data) {
      if (item[this.props.children] && item[this.props.children].length) {
        const _node = this.getNode(item);
        _node.loaded = true;
        this._initLazyNode(_node, item[this.props.children]);
      }
    }
  }
  filter(value, keepAlive) {
    const filterNodeMethod = this.filterNodeMethod;
    const traverse = function (node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach(child => {
        child.visible = filterNodeMethod.call(child, value, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        let allHidden = true;
        childNodes.forEach(child => {
          if (child.visible) allHidden = false;
        });
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (!node.isLeaf) {
        if (node.filtering === false && !keepAlive) {
          node.cacheExpanded = node.expanded;
          node.filtering = true;
        }
        node.root ? node.root.expand() : node.expand();
        if (keepAlive) {
          node.filtering = false;
          !node.cacheExpanded && node.collapse && node.collapse();
        }
      }
    };
    traverse(this);
  }
  setData(newVal) {
    const instanceChanged = newVal !== this.root.data;
    this.root.setData(newVal);
    if (instanceChanged) {
      this._initDefaultCheckedNodes();
    }
  }
  getNode(data) {
    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data);
    return this.nodesMap[key];
  }
  insertBefore(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertBefore({
      data
    }, refNode);
  }
  insertAfter(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertAfter({
      data
    }, refNode);
  }
  remove(data) {
    if (!Array.isArray(data)) data = [data];
    data.forEach(d => {
      const node = this.getNode(d);
      node && node.parent.removeChild(node);
    });
  }
  append(data, parentData) {
    const parentNode = parentData ? this.getNode(parentData) : this.root;
    if (parentNode) {
      if (!Array.isArray(data)) data = [data];
      data.forEach(d => {
        parentNode.insertChild({
          data: d
        });
      });
    }
  }
  reload(data, done) {
    if (this.lazy && this.load) {
      if (!Array.isArray(data)) data = [data];
      const l = data.length - 1;
      data.forEach((d, i) => {
        const node = this.getNode(d);
        if (node) {
          node.loaded = false;
          node.loadNode(i === l && done);
        }
      });
    }
  }

  /**
   * 将节点移动到目标节点的子节点
   * @author chenguanbin
   * @param {Object} [data] 被移动节点的数据对象
   * @param {Object} [targetData] 目标节点的数据对象
   * @param {String} [position] 节点被移动到目标节点的位置: inner(目标节点内) prev(目标节点之前) next(目标节点之后)
   */
  move(data, targetData, position) {
    const node = this.getNode(data);
    const targetNode = targetData ? this.getNode(targetData) : this.root;

    // 移除节点数据
    if (node) {
      let parentNodeData = node.parent.data;
      if (!isArray(parentNodeData)) {
        parentNodeData = parentNodeData.children || [];
      }
      for (let i = 0; i < parentNodeData.length; i++) {
        if (parentNodeData[i] === data) {
          parentNodeData.splice(i, 1);
          break;
        }
      }
      node.parent.removeChild(node);
    }
    const loadedBeforeMove = node.loaded;
    const loadedChildren = node.childNodes.map(n => n.data);

    // 添加节点数据到目标节点
    if (targetNode) {
      if (position === 'inner') {
        targetNode.insertChild({
          data
        }, undefined, true, loadedBeforeMove, loadedChildren);
      } else if (position === 'prev') {
        targetNode.parent.insertBefore({
          data
        }, targetNode, loadedBeforeMove, loadedChildren);
      } else if (position === 'next') {
        targetNode.parent.insertAfter({
          data
        }, targetNode, loadedBeforeMove, loadedChildren);
      }
      this._moveData(data, targetNode, position);
      return this.getNode(data);
    }
  }

  /**
   * 移动数据
   * @author chenguanbin
   * @param {Object} [data] 被移动节点的数据对象
   * @param {Object} [targetNode] 目标节点
   * @param {String} [position] 节点被移动到目标节点的位置: inner(目标节点内) prev(目标节点之前) next(目标节点之后)
   */
  _moveData(data, targetNode, position) {
    // 分为：移动到节点之中、移动到节点前后
    if (position === 'inner') {
      if (!targetNode.data.children) {
        targetNode.data.children = [];
      }
      targetNode.data.children.push(data);
    } else {
      let pNodeData = targetNode.parent.data;
      if (!isArray(pNodeData)) {
        pNodeData = pNodeData.children || [];
      }
      for (let i = 0; i < pNodeData.length; i++) {
        if (pNodeData[i] === targetNode.data) {
          position === 'prev' ? pNodeData.splice(i, 0, data) : pNodeData.splice(i + 1, 0, data);
          break;
        }
      }
    }
  }
  _initDefaultCheckedNodes() {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    const nodesMap = this.nodesMap;
    defaultCheckedKeys.forEach(checkedKey => {
      const node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !this.checkStrictly);
      }
    });
  }
  _initDefaultCheckedNode(node) {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    if (defaultCheckedKeys.indexOf(node.key) !== -1) {
      node.setChecked(true, !this.checkStrictly, this.lazy);
    } else if (node.parent && !this.checkStrictly) {
      node.setChecked(node.parent.checked, !this.checkStrictly, this.lazy);
    }
  }
  setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  }
  registerNode(node) {
    const key = this.key;
    if (!key || !node || !node.data) return;
    const nodeKey = node.key;
    if (nodeKey !== undefined) this.nodesMap[node.key] = node;
  }
  deregisterNode(node) {
    const key = this.key;
    if (!key || !node || !node.data) return;
    delete this.nodesMap[node.key];
  }

  /**
   * 获取选中节点方法
   * 增加选中半选的判断，默认不获取  xiangxiao3 2017/9/26
   * @param {boolean} [leafOnly=false] 仅返回被选中的叶子节点
   * @param {boolean} [checkedOnly=true] 仅返回半选状态的节点
   * @returns 被选中的节点
   * @memberof TreeStore
   */
  getCheckedNodes(leafOnly = false, checkedOnly = true) {
    const checkedNodes = [];
    const traverse = function (node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach(child => {
        // 1、leafOnly=false，且节点选中
        // 2、leafOnly=true，且节点是叶子节点，且节点选中
        // 3、checkedOnly=false，且节点半选
        if (!leafOnly && child.checked || leafOnly && child.isLeaf && child.checked || !checkedOnly && child.indeterminate) {
          checkedNodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return checkedNodes;
  }

  /**
   * 获取选中节点的key值
   * 增加选中半选的判断，默认不获取  xiangxiao3 2017/9/26
   * @param {boolean} [leafOnly=false] 仅返回被选中的叶子节点
   * @param {boolean} [checkedOnly=true] 仅返回半选状态的节点
   * @returns 被选中节点的key值
   * @memberof TreeStore
   */
  getCheckedKeys(leafOnly = false, checkedOnly = true) {
    return this.getCheckedNodes(leafOnly, checkedOnly).map(data => (data || {})[this.key]);
  }

  /**
   * 返回目前半选中的节点所组成的数组
   */
  getHalfCheckedNodes() {
    const nodes = [];
    const traverse = function (node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach(child => {
        if (child.indeterminate) {
          nodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return nodes;
  }

  /**
   * 返回目前半选中的节点的 key 所组成的数组
   */
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map(data => (data || {})[this.key]);
  }
  _getAllNodes() {
    const allNodes = [];
    const nodesMap = this.nodesMap;
    for (const nodeKey in nodesMap) {
      if (hasOwn(nodesMap, nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }
    return allNodes;
  }

  // updateChildren(key, data) {
  //   const node = this.nodesMap[key];
  //   if (!node) return;
  //   const childNodes = node.childNodes;
  //   for (let i = childNodes.length - 1; i >= 0; i--) {
  //     const child = childNodes[i];
  //     this.remove(child.data);
  //   }
  //   for (let i = 0, j = data.length; i < j; i++) {
  //     const child = data[i];
  //     this.append(child, node.data);
  //   }
  // }

  _setCheckedKeys(key, leafOnly = false, checkedKeys, rootOnly = false) {
    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);
    const cache = Object.create(null);
    const keys = Object.keys(checkedKeys);
    for (let i = 0, j = allNodes.length; i < j; i++) {
      const node = allNodes[i];
      const nodeKey = node.data[key].toString();
      const checked = keys.indexOf(nodeKey) > -1;
      if (!checked) {
        if (node.checked && !cache[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }
      let parent = node.parent;
      while (parent && parent.level > 0) {
        cache[parent.data[key]] = true;
        parent = parent.parent;
      }
      if (node.isLeaf || this.checkStrictly) {
        // 是否只选中点击的节点
        if (rootOnly) {
          node.setChecked(true, false, false, false, rootOnly);
        } else {
          node.setChecked(true, false);
        }
        continue;
      }

      // 是否只选中点击的节点
      if (rootOnly) {
        node.setChecked(true, false, false, false, rootOnly);
      } else {
        node.setChecked(true, true);
      }
      if (leafOnly) {
        node.setChecked(false, false);
        const traverse = function (node) {
          const childNodes = node.childNodes;
          childNodes.forEach(child => {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    }
  }
  setCheckedNodes(array, leafOnly = false, rootOnly = false) {
    const key = this.key;
    const checkedKeys = {};
    array.forEach(item => {
      checkedKeys[(item || {})[key]] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys, rootOnly);
  }
  setCheckedKeys(keys, leafOnly = false, rootOnly = false) {
    this.defaultCheckedKeys = keys;
    const key = this.key;
    const checkedKeys = {};
    keys.forEach(key => {
      checkedKeys[key] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys, rootOnly);
  }
  setDefaultExpandedKeys(keys) {
    keys = keys || [];
    this.defaultExpandedKeys = keys;
    keys.forEach(key => {
      const node = this.getNode(key);
      if (node) node.expand(null, this.autoExpandParent);
    });
  }
  setChecked(data, checked, deep) {
    const node = this.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(node) {
    if (node === null) {
      this.currentNode = null;
      return;
    }
    this.currentNode = node;
  }
  setUserCurrentNode(node) {
    const key = node[this.key];
    const currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
  }
  setCurrentNodeKey(key) {
    if (key === null) {
      this.currentNode = null;
      return;
    }
    const node = this.getNode(key);
    if (node) {
      this.currentNode = node;
    }
  }
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=template&id=b3319f20&
var tree_nodevue_type_template_id_b3319f20_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.node.visible),expression:"node.visible"}],staticClass:"el-tree-node",class:_vm.classObject,attrs:{"data-key":_vm.getNodeKey(_vm.node)},on:{"mousedown":_vm.mouseDown}},[_c('div',{staticClass:"el-tree-node__content",style:(_vm.nodeStyle),on:{"click":function($event){$event.stopPropagation();return _vm.handleClick.apply(null, arguments)},"dblclick":function($event){$event.stopPropagation();return _vm.handleDbClick.apply(null, arguments)},"contextmenu":function ($event) { return _vm.handleContextMenu($event); },"mouseenter":function ($event) { return _vm.tree.$emit('node-mouseenter', _vm.node.data, _vm.node, $event); },"mouseleave":function ($event) { return _vm.tree.$emit('node-mouseleave', _vm.node.data, _vm.node, $event); }}},[_c('prefix-content',{attrs:{"node":_vm.node,"expanded":_vm.expanded,"handle-expand-icon-click":_vm.handleExpandIconClick}}),(_vm.showCheckbox)?_c('el-checkbox',{attrs:{"indeterminate":_vm.node.indeterminate,"disabled":!!_vm.node.disabled},on:{"change":_vm.handleCheckChange},nativeOn:{"click":function($event){$event.stopPropagation();}},model:{value:(_vm.node.checked),callback:function ($$v) {_vm.$set(_vm.node, "checked", $$v)},expression:"node.checked"}}):_vm._e(),(_vm.node.svgIcon && _vm.node.svgIconRequire)?_c('h-svg-icon',{staticClass:"el-tree-node__icon",attrs:{"svgs":_vm.node.svgIcon}}):(_vm.node.svgIcon && typeof _vm.node.svgIcon === 'string')?_c('h-svg-icon',{staticClass:"el-tree-node__icon",attrs:{"offline":_vm.node.svgIconOffline}},[_c(_vm.node.svgIcon,{tag:"component",attrs:{"color":_vm.svgIconColor}})],1):(_vm.node.svgIcon && typeof _vm.node.svgIcon === 'object')?_c('h-svg-icon',{staticClass:"el-tree-node__icon",attrs:{"offline":_vm.node.svgIconOffline}},_vm._l((_vm.node.svgIcon),function(icon,index){return _c(icon,{key:index,tag:"component",attrs:{"color":_vm.svgIconColor[index]}})}),1):_vm._e(),(!_vm.node.svgIcon && (_vm.node.icon || _vm.defaultIcon))?_c('span',{class:'el-tree-node__icon ' + (_vm.node.icon || _vm.defaultIcon)}):_vm._e(),(_vm.node.loading)?_c('span',{staticClass:"el-tree-node__loading-icon h-icon-restart"}):_vm._e(),_c('node-content',{attrs:{"node":_vm.node}})],1),(!_vm.renderAfterExpand || _vm.childNodeRendered)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.expanded),expression:"expanded"}],staticClass:"el-tree-node__children"},_vm._l((_vm.node.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"render-content":_vm.renderContent,"prefix-content":_vm.prefixContent,"render-after-expand":_vm.renderAfterExpand,"render-when-expand":_vm.renderWhenExpand,"node":child},on:{"node-expand":_vm.handleChildNodeExpand}})}),1):_vm._e()])}
var tree_nodevue_type_template_id_b3319f20_staticRenderFns = []


// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=template&id=b3319f20&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

// import ElCollapseTransition from 'hui/src/transitions/collapse-transition';




/* harmony default export */ var tree_nodevue_type_script_lang_js_ = ({
  name: 'ElTreeNode',
  componentName: 'ElTreeNode',
  components: {
    // ElCollapseTransition,
    ElCheckbox: packages_checkbox,
    PrefixContent: {
      props: {
        node: {
          required: true
        },
        expanded: {
          required: true
        },
        handleExpandIconClick: {
          required: true
        }
      },
      render(h) {
        const parent = this.$parent;
        const {
          node,
          expanded,
          handleExpandIconClick
        } = this;
        return parent.prefixContent ? parent.prefixContent.call(parent._renderProxy, h, {
          node,
          expanded,
          handleExpandIconClick
        }) : h("span", {
          "class": {
            'is-leaf': (node.isLeaf || node.data.isLeaf) && node.childNodes.length === 0,
            'expanded': !node.isLeaf && expanded,
            'el-tree-node__expand-icon h-icon-angle_right': true
          },
          "on": {
            "click": handleExpandIconClick
          }
        });
      }
    },
    NodeContent: {
      props: {
        node: {
          required: true
        }
      },
      render(h) {
        const parent = this.$parent;
        const tree = parent.tree;
        const node = this.node;
        const {
          data,
          store
        } = node;
        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, {
          _self: tree.$vnode.context,
          node,
          data,
          store
        }) : tree.$scopedSlots.default ? tree.$scopedSlots.default({
          node,
          data,
          store
        }) : h("span", {
          "class": 'el-tree-node__label',
          "attrs": {
            "title": node.label
          }
        }, [node.label]);
      }
    }
  },
  mixins: [emitter],
  props: {
    node: {
      type: Object,
      default() {
        return {};
      }
    },
    props: {
      type: Object,
      default: null
    },
    prefixContent: {
      type: Function,
      default: null
    },
    renderContent: {
      type: Function,
      default: null
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    renderWhenExpand: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      tree: null,
      expanded: false,
      childNodeRendered: false,
      oldChecked: null,
      oldIndeterminate: null
      // nodeWidth: 0 // 节点宽度
    };
  },
  computed: {
    // tree-node class
    classObject: function () {
      const classObject = {
        'is-expanded': this.expanded,
        'is-current': this.isCurrent,
        'is-hidden': !this.node.visible,
        'is-disabled': !!this.node.disabled,
        'is-drag': this.tree.moveConfig.moveFlag,
        'is-nonselectable': !this.node.selectable,
        'is-drag-inner': this.tree.moveConfig.targetNode === this.node && this.tree.moveConfig.movePosition === 'inner' && this.tree.moveConfig.targetNode !== this.tree.moveConfig.moveNode
      };
      // 节点自定义样式
      if (this.tree.nodeClassRender) {
        const nodeClass = this.tree.nodeClassRender(this.node.data);
        if (nodeClass) {
          classObject[nodeClass] = true;
        }
      }
      return classObject;
    },
    svgIconColor() {
      const {
        node
      } = this;
      if (node.svgIconColorActive && this.isCurrent) {
        return node.svgIconColorActive;
      } else if (node.svgIconColor && !this.isCurrent) {
        return node.svgIconColor;
      } else {
        return '';
      }
    },
    isCurrent() {
      return this.tree.store.currentNode && this.tree.store.currentNode.id === this.node.id;
    },
    nodeStyle() {
      const nodeHeight = this.tree.nodeHeight;
      const style = {
        'padding-left': (this.node.level - 1) * this.tree.indent + 'px'
      };
      return nodeHeight ? Object.assign(style, {
        height: nodeHeight + 'px',
        'line-height': nodeHeight - 4 + 'px'
      }) : style;
    },
    showCheckbox() {
      return this.tree.showCheckbox;
    }
  },
  watch: {
    'node.indeterminate'(val) {
      this.handleSelectChange(this.node.checked, val);
    },
    'node.checked'(val) {
      this.handleSelectChange(val, this.node.indeterminate);
    },
    'node.expanded'(val) {
      this.$nextTick(() => this.expanded = val);
      if (val) {
        this.childNodeRendered = true;
      } else if (!val && this.renderWhenExpand) {
        this.childNodeRendered = false;
      }
    }
    // 监听树的最长节点宽度，改变时对应修改自身宽度
    // 'tree.maxNodeWidth'(val) {
    //   this.nodeWidth = val;
    // }
  },
  created() {
    let parent = this.$parent;
    if (parent.wrapClass) {
      parent = parent.$parent;
    }
    if (parent.isTree) {
      this.tree = parent;
    } else {
      this.tree = parent.tree;
    }
    const tree = this.tree;
    if (!tree) {
      // eslint-disable-next-line
      console.warn("Can not find node's tree.");
    }
    const props = tree.props || {};
    const childrenKey = props.children || 'children';
    this.$watch(`node.data.${childrenKey}`, () => {
      this.node.updateChildren();
    });

    // 是否显示图标
    this.showIcon = tree.showIcon;
    // 默认图标
    this.defaultIcon = tree.defaultIcon;
    if (this.node.expanded) {
      this.expanded = true;
      this.childNodeRendered = true;
    }
    if (this.tree.accordion) {
      this.$on('tree-node-expand', node => {
        if (this.node !== node) {
          this.node.collapse();
        }
      });
    }
  },
  mounted() {
    // const contentWidth = this.$el.querySelector('.el-tree-node__content').scrollWidth;
    let parent = this.$parent;
    if (parent.wrapClass) {
      parent = parent.$parent;
    }
  },
  methods: {
    getNodeKey(node, index) {
      const nodeKey = this.tree.nodeKey;
      if (nodeKey && node) {
        return node.data[nodeKey];
      }
      return index;
    },
    handleSelectChange(checked, indeterminate) {
      this.tree.$emit('check-change', this.node.data, checked, indeterminate);
      this.oldChecked = checked;
      this.indeterminate = indeterminate;
    },
    handleClick($event) {
      // selectable 未赋值则可以点击，否则按照 selectable 的值来判断
      const selectable = this.node.selectable;
      const isContinue = selectable === undefined || selectable === '' ? true : selectable;
      const todo = () => {
        const store = this.tree.store;
        store.setCurrentNode(this.node);
        this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
        this.tree.currentNode = this;
        if (this.tree.expandOnClickNode) {
          this.handleExpandIconClick();
        }
        if (this.tree.checkOnClickNode && !this.node.disabled) {
          this.handleCheckChange(!this.node.checked);
        }
        this.tree.$emit('node-click', this.node.data, this.node, this, $event);
      };

      // beforeClick 能够覆盖 selectable
      if (this.tree.beforeClick) {
        // 支持beforeClick返回Boolean或Promise
        let result = this.tree.beforeClick(this.node.data, this.node);
        if (result === false) return; // 返回false则无法点击
        if (result === undefined) result = true; // 未返回值可以点击
        Promise.resolve(result).then(allowed => {
          if (allowed) {
            todo();
          }
        });
      } else if (isContinue) {
        todo();
      }
    },
    handleDbClick($event) {
      if (this.tree.expandOnDbclickNode) {
        this.handleExpandIconClick();
      }
      this.tree.$emit('node-dbclick', this.node.data, this.node, this, $event);
    },
    handleExpandIconClick(e) {
      if (e) e.stopPropagation();
      if ((this.node.isLeaf || this.node.data.isLeaf) && this.node.childNodes.length === 0) {
        return;
      }
      if (this.expanded) {
        this.tree.$emit('node-collapse', this.node.data, this.node, this);
        this.node.collapse();
        this.$emit('node-collapse', this.node.data, this.node, this);
      } else {
        this.node.expand();
        this.$emit('node-expand', this.node.data, this.node, this);
      }
    },
    /**
     * 当某一节点被鼠标右键点击时会触发该事件
     */
    handleContextMenu(event) {
      if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {
        event.stopPropagation();
        event.preventDefault();
      }
      this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
    },
    handleCheckChange(ev) {
      this.node.setChecked(ev, !this.tree.checkStrictly);
      this.$nextTick(() => {
        const store = this.tree.store;
        this.tree.$emit('check', this.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        }, this.node.checked);
      });
    },
    handleChildNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.tree.$emit('node-expand', nodeData, node, instance);
    },
    /**
     * 鼠标点击到节点上的事件
     * @author chenguanbin
     * @param {Event} [event] 事件触发时的事件对象
     */
    mouseDown(event) {
      if (this.tree.move) {
        // 节点拖拽时阻止事件冒泡
        event.stopPropagation();
        // beforeDrag 返回false，则无法拖拽
        if (this.tree.beforeDrag && this.tree.beforeDrag(this.node.data, this.node) === false) {
          return;
        }
        const _this = this;
        const leftDist = 20; // 移动节点距离鼠标有20px的位移
        const moveConfig = this.tree.moveConfig;
        moveConfig.mouseDownFlag = true;
        moveConfig.moveNode = this.node;
        moveConfig.$el = this.$el;
        moveConfig.nodeHtml = this.$el.children[0].innerHTML;
        moveConfig.clientX = event.clientX;
        moveConfig.clientY = event.clientY;
        moveConfig.top = moveConfig.clientY + this.tree.$el.scrollTop;
        moveConfig.left = moveConfig.clientX + this.tree.$el.scrollLeft + leftDist;

        // 在body上绑定onmousemove事件
        document.body.onmousemove = event => {
          _this.bodyMouseMove(event);
        };

        // 在body上绑定mouseup事件
        document.body.onmouseup = function (event) {
          _this.bodyMouseUp(event);
        };

        // 防止IE文字选中
        this.$el.onselectstart = function () {
          return false;
        };
      }
    },
    /**
     * 鼠标在节点上移动的事件
     * @author chenguanbin
     * @param {Event} [event] 事件触发时的事件对象
     */
    bodyMouseMove(event) {
      if (this.tree.move) {
        const moveConfig = this.tree.moveConfig;
        const x = event.clientX - moveConfig.clientX;
        const y = event.clientY - moveConfig.clientY;
        const reponseDistance = 2; // 拖拽响应距离设置为2px，一定程度上防止误操作

        // 鼠标点击后开始拖拽
        if (moveConfig.mouseDownFlag && (Math.abs(x) > reponseDistance || Math.abs(y) > reponseDistance)) {
          // 若正在移动标志为false
          if (!moveConfig.moveFlag) {
            moveConfig.moveFlag = true;
            // 若节点展开，收起自身节点
            if (moveConfig.moveNode.expanded && this.tree.moveArea !== 'outter') {
              moveConfig.moveNodeExpanded = true;
              moveConfig.moveNode.collapse();
            }
            // 触发开始拖拽事件：'node-drag'
            this.tree.$emit('node-drag', event, this.node.data, this.node, this);
          }

          // 被选中的节点跟着鼠标移动
          moveConfig.top += y;
          moveConfig.left += x;
          moveConfig.clientX = event.clientX;
          moveConfig.clientY = event.clientY;

          // 触发节点拖拽过程中的事件：'node-drag-move'
          this.tree.$emit('node-drag-move', event, this.node.data, this.node, this);

          // 若只能移动到树范围之外，则移动到树节点上无响应
          if (this.tree.moveArea === 'outter') return;

          // 判断是否还在树范围内
          if (this._isWinthinTree(event.target)) {
            // 获取 el-tree-node 节点
            const nodeEl = this._getNodeElement(event.target);
            if (!nodeEl.getAttribute) return;
            const key = nodeEl.getAttribute('data-key');
            const node = this.tree.store.getNode(key);
            const targetNode = moveConfig.targetNode;
            const moveNode = moveConfig.moveNode;
            if (targetNode !== node) {
              if (targetNode && moveConfig.movePosition !== 'out') {
                this.tree.$emit('node-drag-leave', event, moveNode, targetNode, this);
              }
              if (node.id !== moveNode.id) {
                this.tree.$emit('node-drag-enter', event, moveNode, node, this);
              }
            }

            // 设置目标节点
            moveConfig.targetNode = node;
            moveConfig.targetEl = nodeEl;

            // 移动到自身上隐藏箭头
            if (nodeEl === moveConfig.$el) {
              moveConfig.arrowFlag = false;
              return;
            }

            // 移动箭头位置
            this._moveArrow(nodeEl, moveConfig, event);
          } else {
            if (moveConfig.movePosition !== 'out') {
              this.tree.$emit('node-drag-leave', event, moveConfig.moveNode, null, this);
            }
            // 移出树范围后，移除箭头
            moveConfig.arrowFlag = false;
            moveConfig.movePosition = 'out';
          }
        }
      }
    },
    /**
     * @desc 移动箭头位置
     * @author chenguanbin
     * @param {Document} nodeEl el-tree-node 节点
     * @param {Object} moveConfig 节点移动时的各参数
     */
    _moveArrow(nodeEl, moveConfig) {
      const contentNode = nodeEl.querySelector('.el-tree-node__content');
      const treeOffset = this.tree.$el.getBoundingClientRect();
      const offset = model_util_getOffset(contentNode, this.tree.$el);
      let top = moveConfig.top - treeOffset.top + this.tree.scrollTop; // 计算出目前鼠标位于树控件顶部的距离，有滚动条时需要加上滚动条距离
      const nodeHeight = this.tree.nodeHeight || 32; // 节点高度为32px
      const dis = this.tree.nodeHeight ? this.tree.nodeHeight / 4 : 8; // 拖拽响应距离： 0-8px（兄弟前节点）  9-24px（子节点）  25-31px（兄弟后节点）
      let count = 0; // 计算拖动了多少个节点的距离
      while (top >= nodeHeight) {
        top -= nodeHeight;
        count++;
      }
      const targetNode = moveConfig.targetNode;
      // 添加到目标节点之前
      if (top >= 0 && top < dis) {
        moveConfig.arrowTop = count * nodeHeight;
        moveConfig.movePosition = 'prev';
        moveConfig.arrowFlag = true;
      } else if (top > nodeHeight - dis && top < nodeHeight) {
        // 添加到目标节点之后
        moveConfig.arrowTop = (count + 1) * nodeHeight - 1; // 减1px，为了区分添加到节点前后的情况
        moveConfig.movePosition = 'next';
        moveConfig.arrowFlag = true;
      } else {
        // 添加到子节点
        moveConfig.movePosition = 'inner';
        moveConfig.arrowFlag = false;
        // targetNode.childNodes.length && targetNode.expand();
      }

      // 目标节点为叶子节点时，指示线的起点要去掉展开图标的尺寸32px；
      const iconOffset = this.tree.nodeHeight || 32;
      const borderOffset = 2; // 采用默认border为2px透明的方式，所以要去掉边框的偏移
      const paddingLeft = parseInt(contentNode.style.paddingLeft);
      moveConfig.arrowLeft = offset.left + (targetNode.isLeaf === true ? paddingLeft + iconOffset + borderOffset : paddingLeft + borderOffset);
    },
    /**
     * 在body上绑定的mouseup事件
     * @author chenguanbin
     * @param {Event} [event] 事件触发时的事件对象
     */
    bodyMouseUp(event) {
      const tree = this.tree;
      const moveConfig = tree.moveConfig;
      // 停止拖拽
      moveConfig.mouseDownFlag = false;
      // 若节点正在移动
      if (moveConfig.moveFlag) {
        // 节点停止移动
        moveConfig.moveFlag = false;
        // 判断是否还在树范围之内
        if (this._isWinthinTree(event.target)) {
          // 若只能移动到树范围之外
          if (tree.moveArea === 'outter') return;
          // 获取目标节点
          const targetNode = moveConfig.targetNode;
          // 若目标节点不是正在移动的节点，则移动节点
          // 移动节点
          tree.moveNodes = () => {
            if (this.node.data !== targetNode.data) {
              const todo = () => {
                // 触发'node-drop'事件
                tree.$emit('node-drop', event, this.node.data, this.node, targetNode, moveConfig.movePosition, this);
                // 移动节点
                const newNode = tree.store.move(this.node.data, targetNode.data, moveConfig.movePosition);
                const store = this.tree.store;
                store.setCurrentNode(newNode);
                this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
                this.tree.currentNode = newNode;
              };

              // beforeDrop 返回false，则无法完成拖拽
              if (tree.beforeDrop) {
                let result = this.tree.beforeDrop(this.node.data, this.node, targetNode, moveConfig.movePosition);
                if (result === false) return;
                if (result === undefined) result = true;
                Promise.resolve(result).then(allowed => {
                  if (allowed) {
                    todo();
                  }
                });
              } else {
                todo();
              }
            }
            // 若节点拖拽前为展开状态
            if (moveConfig.moveNodeExpanded) {
              this.$nextTick(() => {
                const node = tree.getNode(moveConfig.moveNode.key);
                node.expand();
                moveConfig.moveNodeExpanded = false;
                // 若目标节点不是正在移动的节点，则展开子节点
                if (this.node.data !== targetNode.data) {
                  this.expandChildNodes(moveConfig.moveNode.childNodes);
                }
              });
            }
            tree.$emit('node-drag-end', event, this.node.data, this.node, targetNode, moveConfig.movePosition, this);
          };
          // 添加一个属性控制是否mouseup处理逻辑
          if (!tree.customDrag) {
            tree.moveNodes();
          }
          // 拖拽完成后处理逻辑钩子
          tree.$emit('node-drag-over', event, this.node.data, this.node, targetNode, moveConfig.movePosition, this);
        } else {
          // beforeDrop 返回false，则无法完成拖拽
          if (tree.beforeDrop && tree.beforeDrop(this.node.data, this.node, null, 'out') === false) {
            return;
          }
          // 触发'node-drop'事件
          tree.$emit('node-drop', event, this.node.data, this.node, null, 'out', this);
          tree.$emit('node-drag-end', event, this.node.data, this.node, null, 'out', this);
        }
      }
    },
    /**
     * @desc 根据子节点在拖拽前的状态，展开子节点
     * @author chenguanbin
     * @param {Array} nodes 子节点
     */
    expandChildNodes(childNodes) {
      for (const child of childNodes) {
        const node = this.tree.getNode(child.key);
        // 子节点在拖拽前未展开状态，则展开节点
        child.expanded && node.expand();
        const childNodes = child.childNodes;
        if (childNodes && childNodes.length) this.expandChildNodes(childNodes);
      }
    },
    /**
     * 判断是否还在树范围内
     */
    _isWinthinTree(node) {
      let isWinthin = false;
      while (node.tagName.toLocaleLowerCase() !== 'body') {
        if (hasClass(node, 'el-tree')) {
          isWinthin = true;
          break;
        }
        node = node.parentNode;
      }
      return isWinthin;
    },
    /**
     * 获取节点元素
     */
    _getNodeElement(node) {
      while (node && node.getAttribute && !node.getAttribute('data-key')) {
        node = node.parentNode;
      }
      return node;
    }
  }
});
// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tree_nodevue_type_script_lang_js_ = (tree_nodevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue





/* normalize component */

var tree_node_component = normalizeComponent(
  src_tree_nodevue_type_script_lang_js_,
  tree_nodevue_type_template_id_b3319f20_render,
  tree_nodevue_type_template_id_b3319f20_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tree_node = (tree_node_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var treevue_type_script_lang_js_ = ({
  name: 'ElTree',
  components: {
    ElScrollbar: scrollbar,
    ElTreeNode: tree_node
  },
  mixins: [emitter],
  props: {
    data: {
      type: Array,
      default: null
    },
    emptyText: {
      type: String,
      default() {
        return Object(locale_["t"])('el.tree.emptyText');
      }
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    renderWhenExpand: {
      type: Boolean,
      default: false
    },
    nodeKey: {
      type: String,
      default: ''
    },
    parentKey: {
      type: String,
      default: ''
    },
    checkStrictly: {
      type: Boolean,
      default: null
    },
    checkParentToChild: {
      type: Boolean,
      default: true
    },
    checkChildToParent: {
      type: Boolean,
      default: true
    },
    defaultExpandAll: {
      type: Boolean,
      default: null
    },
    expandOnClickNode: {
      type: Boolean,
      default: false
    },
    checkOnClickNode: {
      type: Boolean,
      default: false
    },
    expandOnDbclickNode: {
      type: Boolean,
      default: true
    },
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: {
      type: Array,
      default: null
    },
    defaultExpandedKeys: {
      type: Array,
      default: null
    },
    prefixContent: {
      type: Function,
      default: null
    },
    renderContent: {
      type: Function,
      default: null
    },
    showCheckbox: {
      type: Boolean,
      default: false
    },
    props: {
      type: Object,
      default() {
        return {
          children: 'children',
          label: 'label',
          icon: 'icon',
          svgIcon: 'svgIcon',
          svgIconOffline: 'svgIconOffline',
          disabled: 'disabled',
          selectable: 'selectable',
          isLeaf: 'isLeaf'
        };
      }
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: {
      type: Boolean,
      default: true
    },
    currentNodeKey: {
      type: [String, Number],
      default: ''
    },
    load: {
      type: Function,
      default: null
    },
    filterNodeMethod: {
      type: Function,
      default: null
    },
    accordion: {
      type: Boolean,
      default: null
    },
    indent: {
      type: Number,
      default: 16
    },
    // 是否使用简单数据结构
    simpleData: {
      type: Boolean,
      default: false
    },
    // 是否可移动
    move: {
      type: Boolean,
      default: null
    },
    moveStyle: {
      type: Object,
      default() {
        return {};
      }
    },
    // 节点可拖拽的区域： all(全部) outter(只能拖拽到树区域以外)
    moveArea: {
      type: String,
      default: 'all'
    },
    // 用于捕获节点被拖拽之前的事件回调函数，若返回 false， 则无法拖拽节点
    beforeDrag: {
      type: Function,
      default: null
    },
    // 用于捕获节点拖拽操作结束之前的事件回调函数，若返回 false 则无法终止拖拽
    beforeDrop: {
      type: Function,
      default: null
    },
    // 用于自定义处理mouseup之后的逻辑，true 自定义处理
    customDrag: {
      type: Boolean,
      default: false
    },
    // 用于捕获单击节点之前的事件回调函数，若返回 false， 则无法进行单击操作
    beforeClick: {
      type: Function,
      default: null
    },
    // 是否显示图标
    showIcon: {
      type: Boolean,
      default: false
    },
    // 默认图标
    defaultIcon: {
      type: String,
      default: ''
    },
    border: {
      type: Boolean,
      default: false
    },
    scrollSize: {
      type: Number,
      default: 6
    },
    customSrcollbar: {
      type: Boolean,
      default: false
    },
    nodeHeight: {
      type: Number,
      default: null
    },
    nodeClassRender: {
      type: Function,
      default: () => ''
    }
  },
  data() {
    return {
      store: null,
      root: null,
      currentNode: null,
      scrollTop: 0,
      moveConfig: {
        mouseDownFlag: false,
        // 鼠标点击节点标志
        moveFlag: false,
        // 节点正在移动标志
        moveNode: null,
        // 被移动的节点
        moveNodeExpanded: false,
        // 节点被移动前是否已经展开
        $el: null,
        // 被移动节点的 DOM
        targetNode: null,
        // 目标节点
        targetEl: null,
        // 目标节点的 DOm
        movePosition: 'inner',
        // 节点被移动到目标节点的位置: inner(目标节点内) prev(目标节点之前) next(目标节点之后)
        nodeHtml: '',
        // 模拟节点：被移动节点的 html
        top: 0,
        // 模拟节点的 top 值
        left: 0,
        // 模拟节点的 left 值
        clientX: 0,
        // 记录开始移动时鼠标的 X 轴定位
        clientY: 0,
        // 记录开始移动时鼠标的 Y 轴定位
        arrowFlag: false,
        // 是否显示箭头
        arrowTop: 0,
        // 箭头 top 值
        arrowLeft: 0 // 箭头 left 值
      },
      defaultProps: {
        children: 'children',
        label: 'label',
        icon: 'icon',
        svgIcon: 'svgIcon',
        svgIconOffline: 'svgIconOffline',
        svgIconColor: 'svgIconColor',
        svgIconColorActive: 'svgIconColorActive',
        svgIconRequire: 'svgIconRequire',
        disabled: 'disabled',
        selectable: 'selectable',
        isLeaf: 'isLeaf'
      }
    };
  },
  computed: {
    children: {
      set(value) {
        this.data = value;
      },
      get() {
        return this.data;
      }
    },
    moveBlockStyle() {
      const offset = {
        top: this.moveConfig.top + 'px',
        left: this.moveConfig.left + 'px'
      };
      return Object.assign({}, this.moveStyle, offset);
    },
    wrapContainer() {
      return this.customSrcollbar ? 'div' : 'el-scrollbar';
    }
  },
  watch: {
    lazy(newVal) {
      this.store.lazy = newVal;
    },
    defaultExpandAll(newVal) {
      this.store.defaultExpandAll = newVal;
    },
    defaultCheckedKeys(newVal) {
      this.store.defaultCheckedKeys = newVal;
      this.store.setDefaultCheckedKey(newVal);
    },
    defaultExpandedKeys(newVal) {
      this.store.defaultExpandedKeys = newVal;
      this.store.setDefaultExpandedKeys(newVal);
    },
    currentNodeKey(newVal) {
      this.store.setCurrentNodeKey(newVal);
      this.store.currentNodeKey = newVal;
    },
    data(newVal) {
      // 启用简单数据，则在改变data后处理数据
      // 判断是否有nodeKey和parentKey
      if (this.simpleData && this.nodeKey && this.parentKey) {
        newVal = formatData(newVal, this.nodeKey, this.parentKey);
      }
      this.store.setData(newVal);
    }
  },
  created() {
    this.isTree = true;
    let _data = this.data;
    this.defaultProps = {
      ...this.defaultProps,
      ...this.props
    };

    // 若启用简单数据
    // 判断是否有nodeKey 和 parentKey
    if (this.simpleData && this.nodeKey && this.parentKey) {
      _data = formatData(this.data, this.nodeKey, this.parentKey);
      // 简单数据结构直接设置 children，这样无需在外部 props 中传入
      this.defaultProps.children = 'children';
    }
    this.store = new tree_store_TreeStore({
      key: this.nodeKey,
      parentKey: this.parentKey,
      data: _data,
      lazy: this.lazy,
      props: this.defaultProps,
      simpleData: this.simpleData,
      load: this.load,
      checkParentToChild: this.checkParentToChild,
      checkChildToParent: this.checkChildToParent,
      currentNodeKey: this.currentNodeKey,
      checkStrictly: this.checkStrictly,
      checkDescendants: this.checkDescendants,
      defaultCheckedKeys: this.defaultCheckedKeys,
      defaultExpandedKeys: this.defaultExpandedKeys,
      autoExpandParent: this.autoExpandParent,
      defaultExpandAll: this.defaultExpandAll,
      filterNodeMethod: this.filterNodeMethod
    });
    this.root = this.store.root;
  },
  mounted() {
    this.$refs.scrollbar && !this.customSrcollbar && this.$refs.scrollbar.update();
  },
  methods: {
    filter(value, keepAlive) {
      if (!this.filterNodeMethod) {
        throw new Error('[Tree] filterNodeMethod is required when filter');
      }
      this.store.filter(value, keepAlive);
    },
    getNodeKey(node, index) {
      const nodeKey = this.nodeKey;
      if (nodeKey && node) {
        return node.data[nodeKey];
      }
      return index;
    },
    getCheckedNodes(leafOnly, checkedOnly) {
      return this.store.getCheckedNodes(leafOnly, checkedOnly);
    },
    getCheckedKeys(leafOnly, checkedOnly) {
      return this.store.getCheckedKeys(leafOnly, checkedOnly);
    },
    setCheckedNodes(nodes, leafOnly, rootOnly) {
      if (!this.nodeKey) {
        throw new Error('[Tree] nodeKey is required in setCheckedNodes');
      }
      this.store.setCheckedNodes(nodes, leafOnly, rootOnly);
    },
    setCheckedKeys(keys, leafOnly, rootOnly) {
      if (!this.nodeKey) {
        throw new Error('[Tree] nodeKey is required in setCheckedNodes');
      }
      this.store.setCheckedKeys(keys, leafOnly, rootOnly);
    },
    setChecked(data, checked, deep) {
      this.store.setChecked(data, checked, deep);
    },
    handleNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.$emit('node-expand', nodeData, node, instance);
      setTimeout(() => {
        this.$refs.scrollbar && !this.customSrcollbar && this.$refs.scrollbar.update();
      }, 300);
    },
    handleNodeCollapse() {
      setTimeout(() => {
        this.$refs.scrollbar && !this.customSrcollbar && this.$refs.scrollbar.update();
      }, 300);
    },
    /**
     * 手动触发，重新渲染滚动条
     */
    resizeScrollbar() {
      this.$refs.scrollbar && !this.customSrcollbar && this.$refs.scrollbar.update();
    },
    /**
     * 选中目标节点
     * @param {Object/String} data 选中节点的 key 或者 data
     * @param {Boolean} selected 节点是否选中
     */
    setSelected(data, selected = true) {
      const store = this.store;
      const node = store.getNode(data);
      if (selected) {
        store.setCurrentNode(node);
        this.currentNode = node;
      } else {
        store.setCurrentNode(null);
        this.currentNode = null;
      }
      this.$emit('current-change', node.data, node);
    },
    getSelectedNode() {
      return this.store.currentNode;
    },
    getSelectedKey() {
      return this.store.currentNode ? this.getNodeKey(this.store.currentNode) : '';
    },
    getHalfCheckedNodes() {
      return this.store.getHalfCheckedNodes();
    },
    getHalfCheckedKeys() {
      return this.store.getHalfCheckedKeys();
    },
    setCurrentNode(data) {
      if (!this.nodeKey) {
        throw new Error('[Tree] nodeKey is required in setCurrentNode');
      }
      this.store.setUserCurrentNode(data);
    },
    setCurrentKey(key) {
      if (!this.nodeKey) {
        throw new Error('[Tree] nodeKey is required in setCurrentKey');
      }
      this.store.setCurrentNodeKey(key);
    },
    getNode(data) {
      return this.store.getNode(data);
    },
    remove(data) {
      this.store.remove(data);
    },
    append(data, parentNode) {
      this.store.append(data, parentNode);
    },
    insertBefore(data, refNode) {
      this.store.insertBefore(data, refNode);
    },
    insertAfter(data, refNode) {
      this.store.insertAfter(data, refNode);
    },
    expandNode(data) {
      const store = this.store;
      const node = store.getNode(data);
      node && node.expand();
    },
    collapseNode(data) {
      const store = this.store;
      const node = store.getNode(data);
      node && node.collapse();
    },
    onScrollingX(s) {
      const {
        scrollLeft,
        percentX
      } = s;
      this.$emit('on-scrolling-x', {
        scrollLeft,
        percentX
      });
      this.$emit('on-scrolling', s);
    },
    onScrollingY(s) {
      const {
        scrollTop,
        percentY
      } = s;
      this.scrollTop = scrollTop;
      this.$emit('on-scrolling-y', {
        scrollTop,
        percentY
      });
      this.$emit('on-scrolling', s);
    },
    reload(data, done) {
      this.store.reload(data, done);
    }
  }
});
// CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_treevue_type_script_lang_js_ = (treevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/tree/src/tree.vue





/* normalize component */

var tree_component = normalizeComponent(
  src_treevue_type_script_lang_js_,
  treevue_type_template_id_b04ec82e_render,
  treevue_type_template_id_b04ec82e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tree = (tree_component.exports);
// CONCATENATED MODULE: ./packages/tree/index.js


/* istanbul ignore next */
tree.install = function (Vue) {
  Vue.component(tree.name, tree);
};
/* harmony default export */ var packages_tree = (tree);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/alert/src/main.vue?vue&type=template&id=57916940&
var mainvue_type_template_id_57916940_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-alert-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-alert",class:[_vm.typeClass, _vm.isSimple, _vm.isCenter]},[(_vm.showIcon)?_c('h-feedback-icon',{staticClass:"el-alert__icon",attrs:{"icon-name":_vm.iconClass}}):_vm._e(),_c('div',{staticClass:"el-alert__content",class:[_vm.showIcon ? 'is-icon' : '', _vm.closable ? 'is-close' : '']},[(_vm.title || _vm.$slots.title)?_c('span',{staticClass:"el-alert__title",class:[_vm.isBoldTitle, _vm.isSimple]},[_vm._t("title",function(){return [_vm._v(" "+_vm._s(_vm.title)+" ")]})],2):_vm._e(),_vm._t("default",function(){return [(_vm.description)?_c('p',{staticClass:"el-alert__description",class:[_vm.isSimple, _vm.title ? 'is-title' : '']},[_vm._v(" "+_vm._s(_vm.description)+" ")]):_vm._e()]}),_c('i',{directives:[{name:"show",rawName:"v-show",value:(_vm.closable),expression:"closable"}],staticClass:"el-alert__closebtn",class:[_vm.isCustomed, _vm.iconCloseClass],on:{"click":function($event){return _vm.close()}}},[_vm._v(" "+_vm._s(_vm.closeText)+" ")])],2)],1)])}
var mainvue_type_template_id_57916940_staticRenderFns = []


// CONCATENATED MODULE: ./packages/alert/src/main.vue?vue&type=template&id=57916940&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/alert/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

const TYPE_CLASSES_MAP = {
  success: 'h-icon-feedback_success_sm',
  warning: 'h-icon-feedback_warning_sm',
  error: 'h-icon-feedback_error_sm',
  info: 'h-icon-feedback_info_sm'
};
/* harmony default export */ var alert_src_mainvue_type_script_lang_js_ = ({
  name: 'ElAlert',
  props: {
    title: {
      type: String,
      default: ''
    },
    description: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'info'
    },
    center: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeText: {
      type: String,
      default: ''
    },
    closeIcon: {
      type: String,
      default: ''
    },
    showIcon: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ''
    },
    simple: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      visible: true
    };
  },
  computed: {
    typeClass() {
      return `el-alert--${this.type}`;
    },
    isSimple() {
      return this.simple ? 'is-simple' : '';
    },
    isCenter() {
      return this.center ? 'is-center' : '';
    },
    iconClass() {
      if (this.icon === '') {
        return this.type ? TYPE_CLASSES_MAP[this.type] : '';
      } else {
        return this.icon;
      }
    },
    isCustomed() {
      return this.closeText ? 'is-customed' : '';
    },
    iconCloseClass() {
      return this.closeText === '' ? this.closeIcon ? this.closeIcon : 'h-icon-close_sm' : '';
    },
    isBoldTitle() {
      return this.description || this.$slots.default ? 'is-bold' : '';
    }
  },
  methods: {
    close() {
      this.visible = false;
      this.$emit('close');
    }
  }
});
// CONCATENATED MODULE: ./packages/alert/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_alert_src_mainvue_type_script_lang_js_ = (alert_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/alert/src/main.vue





/* normalize component */

var alert_src_main_component = normalizeComponent(
  packages_alert_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_57916940_render,
  mainvue_type_template_id_57916940_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var alert_src_main = (alert_src_main_component.exports);
// CONCATENATED MODULE: ./packages/alert/index.js


/* istanbul ignore next */
alert_src_main.install = function (Vue) {
  Vue.component(alert_src_main.name, alert_src_main);
};
/* harmony default export */ var packages_alert = (alert_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/notification/src/main.vue?vue&type=template&id=78826cc6&
var mainvue_type_template_id_78826cc6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-notification-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-notification",class:[_vm.customClass, _vm.sizeClass, _vm.horizontalClass],style:(_vm.positionStyle),on:{"mouseenter":function($event){return _vm.clearTimer()},"mouseleave":function($event){return _vm.startTimer()},"click":_vm.click}},[_c('div',{staticClass:"el-notification__group"},[_c('div',{staticClass:"el-notification__title"},[_vm._v(" "+_vm._s(_vm.title)+" ")]),_c('div',{staticClass:"el-notification__content"},[_vm._t("default",function(){return [(!_vm.dangerouslyUseHTMLString)?_c('p',[_vm._v(" "+_vm._s(_vm.message)+" ")]):_c('p',{domProps:{"innerHTML":_vm._s(_vm.message)}})]})],2),(_vm.showClose)?_c('div',{staticClass:"el-notification__closeBtn h-icon-close_sm",on:{"click":function($event){$event.stopPropagation();return _vm.close.apply(null, arguments)}}}):_vm._e()]),(_vm.pages.length >= 2)?_c('div',{staticClass:"el-notification__pagination"},[_c('el-pagination',{attrs:{"total":_vm.pages.length * 10,"page-count":4,"small":"","layout":"first, prev, miniPager, next, last"},on:{"current-change":_vm.handlePageChange}})],1):_vm._e()])])}
var mainvue_type_template_id_78826cc6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/notification/src/main.vue?vue&type=template&id=78826cc6&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/notification/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

const src_mainvue_type_script_lang_js_sizeMap = {
  small: 'small',
  middle: 'middle',
  large: 'large'
};
/* harmony default export */ var notification_src_mainvue_type_script_lang_js_ = ({
  data() {
    return {
      visible: false,
      title: '',
      message: '',
      duration: 3000,
      showClose: true,
      size: 'small',
      customClass: '',
      onClose: null,
      onClick: null,
      closed: false,
      verticalOffset: 0,
      position: 'top-right',
      timer: null,
      pages: [],
      activePageIndex: 0,
      dangerouslyUseHTMLString: false
    };
  },
  computed: {
    sizeClass() {
      return src_mainvue_type_script_lang_js_sizeMap[this.size] ? `el-notification--${src_mainvue_type_script_lang_js_sizeMap[this.size]}` : 'el-notification--small';
    },
    horizontalClass() {
      return this.position.indexOf('right') > -1 ? 'right' : 'left';
    },
    verticalProperty() {
      return /^top-/.test(this.position) ? 'top' : 'bottom';
    },
    positionStyle() {
      return {
        [this.verticalProperty]: `${this.verticalOffset}px`
      };
    }
  },
  watch: {
    closed(newVal) {
      if (newVal) {
        this.visible = false;
        this.$el.addEventListener('transitionend', this.destroyElement);
      }
    },
    pages(val) {
      if (val.length !== 1) return;
      this.renderPage(0);
    },
    activePageIndex(val) {
      this.renderPage(val);
    }
  },
  mounted() {
    if (this.duration > 0) {
      this.timer = setTimeout(() => {
        if (!this.closed) {
          this.close();
        }
      }, this.duration);
    }
  },
  methods: {
    destroyElement() {
      this.$el.removeEventListener('transitionend', this.destroyElement);
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    renderPage(index) {
      this.message = this.pages[index].content;
      this.title = this.pages[index].title;
    },
    click() {
      if (typeof this.onClick === 'function') {
        this.onClick();
      }
    },
    close() {
      this.closed = true;
      if (typeof this.onClose === 'function') {
        this.onClose();
      }
    },
    clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer() {
      if (this.duration > 0) {
        this.timer = setTimeout(() => {
          if (!this.closed) {
            this.close();
          }
        }, this.duration);
      }
    },
    handlePageChange(currentPage) {
      this.activePageIndex = currentPage - 1;
    }
  }
});
// CONCATENATED MODULE: ./packages/notification/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_notification_src_mainvue_type_script_lang_js_ = (notification_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/notification/src/main.vue





/* normalize component */

var notification_src_main_component = normalizeComponent(
  packages_notification_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_78826cc6_render,
  mainvue_type_template_id_78826cc6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var notification_src_main = (notification_src_main_component.exports);
// CONCATENATED MODULE: ./packages/notification/src/main.js




const NotificationConstructor = external_vue_default.a.extend(notification_src_main);
let src_main_instance;
const main_instances = []; // Notification的实例信息
let pages = []; // 分页的页数信息
let main_seed = 1;
var Notification = function (options) {
  if (external_vue_default.a.prototype.$isServer) return;
  options = options || {};
  const id = 'notification_' + main_seed++;
  const position = options.position || 'top-right';
  // 非分页场景和 分页场景的第一页 都需要新建一个Notification实例
  if (!(options.pagination && pages.length)) {
    const userOnClose = options.onClose;
    options.onClose = function () {
      Notification.close(id, userOnClose);
    };
    src_main_instance = new NotificationConstructor({
      data: options
    });
    if (options.pagination) {
      // 分页的第一条信息  更新pages
      pages.push({
        content: options.message,
        title: options.title
      });
      options.pages = pages;
      const offset = options.offset || 0;
      src_main_instance.verticalOffset = offset + 16;
    } else {
      // 非分页场景 单条或者多条时都包含 考虑多个实例时的偏移问题
      let verticalOffset = options.offset || 0;
      main_instances.filter(item => item.position === position).forEach(item => {
        verticalOffset += item.$el.offsetHeight + 16;
      });
      verticalOffset += 16;
      src_main_instance.verticalOffset = verticalOffset;
    }
    if (isVNode(options.message)) {
      src_main_instance.$slots.default = [options.message];
      options.message = 'REPLACED_BY_VNODE';
    }
    src_main_instance.id = id;
    src_main_instance.vm = src_main_instance.$mount();
    document.body.appendChild(src_main_instance.vm.$el);
    src_main_instance.vm.visible = true;
    src_main_instance.dom = src_main_instance.vm.$el;
    src_main_instance.dom.style.zIndex = popup_manager.nextZIndex();
    main_instances.push(src_main_instance);
    return src_main_instance.vm;
  } else {
    // 分页情况下的后续页
    // 第一个实例的timeout清零
    src_main_instance.clearTimer();
    pages.push({
      content: options.message,
      title: options.title
    });
    options.pages = pages;
    options.message = '';
    src_main_instance.startTimer();
  }
};
Notification.close = function (id, userOnClose) {
  let index = -1;
  const len = main_instances.length;
  const instance = main_instances.filter((instance, i) => {
    if (instance.id === id) {
      index = i;
      return true;
    }
    return false;
  })[0];
  if (!instance) return;
  if (typeof userOnClose === 'function') {
    userOnClose(instance);
  }
  main_instances.splice(index, 1);
  pages = [];
  if (len <= 1) return;
  const position = instance.position;
  const removedHeight = instance.dom.offsetHeight;
  for (let i = index; i < len - 1; i++) {
    if (main_instances[i].position === position) {
      main_instances[i].dom.style[instance.verticalProperty] = parseInt(main_instances[i].dom.style[instance.verticalProperty], 10) - removedHeight - 16 + 'px';
    }
  }
};
/* harmony default export */ var packages_notification_src_main = (Notification);
// CONCATENATED MODULE: ./packages/notification/index.js

/* harmony default export */ var notification = (packages_notification_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/main.vue?vue&type=template&id=e68e388a&
var mainvue_type_template_id_e68e388a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"sliderContainer",staticClass:"el-slider",class:{
    'is-vertical': _vm.vertical,
    'el-slider--with-input': _vm.showInput,
    'el-slider--with-button': _vm.internalShowButton
  }},[(_vm.showInput && !_vm.range)?_c('el-input-number',_vm._b({ref:"input",staticClass:"el-slider__input",attrs:{"step":_vm.step,"disabled":_vm.disabled,"controls":_vm.showInputControls,"min":_vm.min,"max":_vm.max,"precision":_vm.precision},on:{"blur":_vm.handleBlur},model:{value:(_vm.firstValue),callback:function ($$v) {_vm.firstValue=$$v},expression:"firstValue"}},'el-input-number',_vm.$attrs,false)):_vm._e(),(_vm.internalShowButton)?_c('el-button',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.onFirstButtonClick),expression:"onFirstButtonClick"}],attrs:{"icon":("h-icon-" + (_vm.vertical ? 'add' : 'minus'))}}):_vm._e(),_c('div',{ref:"slider",staticClass:"el-slider__runway",class:{
      'show-input': _vm.showInput && !_vm.range,
      'show-button': _vm.internalShowButton,
      disabled: _vm.disabled
    },style:(_vm.runwayStyle)},[_c('div',{staticClass:"el-slider__runway-click-area",on:{"click":_vm.onSliderClick}}),_c('div',{staticClass:"el-slider__bar",style:(_vm.barStyle)}),_c('slider-button',{ref:"button1",attrs:{"vertical":_vm.vertical},on:{"slider-click-value-change":_vm.sliderClickValueChange,"drag-end":_vm.dragEnd,"button-down":function($event){return _vm.buttonDown(_vm.sliderInput)}},model:{value:(_vm.firstValue),callback:function ($$v) {_vm.firstValue=$$v},expression:"firstValue"}}),(_vm.range)?_c('slider-button',{ref:"button2",attrs:{"vertical":_vm.vertical},on:{"drag-end":_vm.dragEnd,"button-down":function($event){return _vm.buttonDown(_vm.sliderInput2)}},model:{value:(_vm.secondValue),callback:function ($$v) {_vm.secondValue=$$v},expression:"secondValue"}}):_vm._e(),(_vm.showStops)?_c('div',[_vm._l((_vm.stops),function(item,index){return [_c('div',{key:index,staticClass:"el-slider__stop-wrap"},[_c('div',{staticClass:"el-slider__stop el-slider__stop--top el-slider__stop--left",style:(_vm.vertical
                ? { bottom: item.stepWidth + '%' }
                : { left: item.stepWidth + '%' })}),_c('div',{staticClass:"el-slider__stop el-slider__stop--bottom el-slider__stop--right",style:(_vm.vertical
                ? { bottom: item.stepWidth + '%' }
                : { left: item.stepWidth + '%' })}),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showStopsNumber),expression:"showStopsNumber"}],staticClass:"el-slider__mark",style:(_vm.vertical
                ? { bottom: item.stepWidth + '%' }
                : { left: item.stepWidth + '%' })},[_vm._v(" "+_vm._s(item.stepValue)+" ")])])]})],2):_vm._e()],1),(_vm.internalShowButton)?_c('el-button',{directives:[{name:"repeat-click",rawName:"v-repeat-click",value:(_vm.onSecondButtonClick),expression:"onSecondButtonClick"}],attrs:{"icon":("h-icon-" + (_vm.vertical ? 'minus' : 'add'))}}):_vm._e()],1)}
var mainvue_type_template_id_e68e388a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/slider/src/main.vue?vue&type=template&id=e68e388a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/button.vue?vue&type=template&id=33118c53&
var buttonvue_type_template_id_33118c53_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"button",staticClass:"el-slider__button-wrapper",class:{ hover: _vm.hovering, dragging: _vm.dragging },style:(_vm.wrapperStyle),on:{"mouseenter":_vm.handleMouseEnter,"mouseleave":_vm.handleMouseLeave,"mousedown":_vm.onButtonDown}},[_c('el-tooltip',{ref:"tooltip",attrs:{"disabled":!_vm.showTooltip,"effect":"light","placement":"top"}},[_c('span',{attrs:{"slot":"content"},slot:"content"},[_vm._v(" "+_vm._s(_vm.formatValue)+" ")]),_c('div',{staticClass:"el-slider__button",class:{ hover: _vm.hovering, dragging: _vm.dragging }})])],1)}
var buttonvue_type_template_id_33118c53_staticRenderFns = []


// CONCATENATED MODULE: ./packages/slider/src/button.vue?vue&type=template&id=33118c53&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/button.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var slider_src_buttonvue_type_script_lang_js_ = ({
  name: 'ElSliderButton',
  components: {
    ElTooltip: packages_tooltip
  },
  props: {
    value: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      hovering: false,
      dragging: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: null,
      oldValue: this.value
    };
  },
  computed: {
    disabled() {
      return this.$parent.disabled;
    },
    max() {
      return this.$parent.max;
    },
    min() {
      return this.$parent.min;
    },
    step() {
      return this.$parent.step;
    },
    showTooltip() {
      return this.$parent.showTooltip && !(this.$parent.showInput && this.$parent.range);
    },
    precision() {
      return this.$parent.precision;
    },
    currentPosition() {
      return `${(this.value - this.min) / (this.max - this.min) * 100}%`;
    },
    enableFormat() {
      return this.$parent.formatTooltip instanceof Function;
    },
    formatValue() {
      return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
    },
    wrapperStyle() {
      return this.vertical ? {
        bottom: this.currentPosition
      } : {
        left: this.currentPosition
      };
    }
  },
  watch: {
    dragging(val) {
      this.$parent.dragging = val;
    }
  },
  methods: {
    displayTooltip() {
      this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
    },
    hideTooltip() {
      this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
    },
    handleMouseEnter() {
      this.hovering = true;
      this.displayTooltip();
    },
    handleMouseLeave() {
      this.hovering = false;
      this.hideTooltip();
    },
    onButtonDown(event) {
      if (this.disabled) return;
      event.preventDefault();
      this.$emit('button-down');
      this.onDragStart(event);
      window.addEventListener('mousemove', this.onDragging);
      window.addEventListener('mouseup', this.onDragEnd);
      window.addEventListener('contextmenu', this.onDragEnd);
    },
    onDragStart(event) {
      this.dragging = true;
      if (this.vertical) {
        this.startY = event.clientY;
      } else {
        this.startX = event.clientX;
      }
      this.startPosition = parseFloat(this.currentPosition);
      // add by zhangxiaogang
      this.$parent.$emit('drag-start', event, this.oldValue);
    },
    onDragging(event) {
      if (this.dragging) {
        this.displayTooltip();
        this.$parent.resetSize();
        let diff = 0;
        if (this.vertical) {
          this.currentY = event.clientY;
          diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
        } else {
          this.currentX = event.clientX;
          diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
        }
        this.newPosition = this.startPosition + diff;
        this.setPosition(this.newPosition);
      }
    },
    onDragEnd() {
      if (this.dragging) {
        /*
         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
         */
        setTimeout(() => {
          this.dragging = false;
          this.hideTooltip();
          this.setPosition(this.newPosition);
          // add by zhangxiaogang
          this.$emit('drag-end');
        }, 0);
        window.removeEventListener('mousemove', this.onDragging);
        window.removeEventListener('mouseup', this.onDragEnd);
        window.removeEventListener('contextmenu', this.onDragEnd);
      }
    },
    setPosition(newPosition, type) {
      if (newPosition === null) return;
      if (newPosition < 0) {
        newPosition = 0;
      } else if (newPosition > 100) {
        newPosition = 100;
      }
      const lengthPerStep = 100 / ((this.max - this.min) / this.step);
      const steps = Math.round(newPosition / lengthPerStep);
      let value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
      value = parseFloat(value.toFixed(this.precision));
      this.newPosition = newPosition;
      this.$emit('input', value);
      type && this.$emit(type, value);
      this.$refs.tooltip && this.$refs.tooltip.updatePopper();
      if (!this.dragging && this.value !== this.oldValue) {
        this.oldValue = this.value;
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/slider/src/button.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_slider_src_buttonvue_type_script_lang_js_ = (slider_src_buttonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/slider/src/button.vue





/* normalize component */

var src_button_component = normalizeComponent(
  packages_slider_src_buttonvue_type_script_lang_js_,
  buttonvue_type_template_id_33118c53_render,
  buttonvue_type_template_id_33118c53_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var slider_src_button = (src_button_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/input.vue?vue&type=template&id=51935765&
var inputvue_type_template_id_51935765_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-input-number',{ref:"rangeInput",staticClass:"el-slider__range-input",attrs:{"step":_vm.slider.step,"precision":_vm.precision,"disabled":_vm.slider.disabled,"controls":_vm.slider.showInputControls,"min":_vm.slider.min,"max":_vm.slider.max,"debounce":_vm.slider.debounce},model:{value:(_vm.value),callback:function ($$v) {_vm.value=$$v},expression:"value"}})}
var inputvue_type_template_id_51935765_staticRenderFns = []


// CONCATENATED MODULE: ./packages/slider/src/input.vue?vue&type=template&id=51935765&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/input.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

// import Popper from 'hui/src/utils/vue-popper';

/* harmony default export */ var slider_src_inputvue_type_script_lang_js_ = ({
  name: 'ElSliderInput',
  components: {
    ElInputNumber: packages_input_number
  },
  // mixins: [Popper],

  props: {
    placement: {
      type: String,
      default: 'top'
    },
    value: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      slider: {
        step: 1,
        disabled: false,
        showInputControls: true,
        min: 0,
        max: 100,
        debounce: 300
      },
      button: null
    };
  },
  computed: {
    precision() {
      return this.slider && this.slider.step && this.slider.step.toString().includes('.') ? this.slider.step.toString().split('.').pop().length : undefined;
    }
  },
  watch: {
    value(val) {
      if (typeof val !== 'undefined') {
        this.$emit('change', val);
      }
    }
  },
  mounted() {
    this.popperElm = this.$el;
    this.referenceElm = this.button;
    this.showPopper = true;
  }
});
// CONCATENATED MODULE: ./packages/slider/src/input.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_slider_src_inputvue_type_script_lang_js_ = (slider_src_inputvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/slider/src/input.vue





/* normalize component */

var src_input_component = normalizeComponent(
  packages_slider_src_inputvue_type_script_lang_js_,
  inputvue_type_template_id_51935765_render,
  inputvue_type_template_id_51935765_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_input = (src_input_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/slider/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var slider_src_mainvue_type_script_lang_js_ = ({
  name: 'ElSlider',
  components: {
    ElInputNumber: packages_input_number,
    SliderButton: slider_src_button
  },
  directives: {
    RepeatClick: repeat_click
  },
  mixins: [emitter],
  props: {
    debounce: {
      type: Number,
      default: 300
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    marks: {
      type: [Array, Object],
      default: () => []
    },
    value: {
      type: [Number, Array],
      default: 0
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showButton: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showStopsNumber: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: {
      type: Function,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: ''
    }
  },
  data() {
    return {
      firstValue: null,
      secondValue: null,
      oldValue: null,
      dragging: false,
      sliderSize: 1,
      sliderInput: null,
      sliderInput2: null
    };
  },
  computed: {
    stops() {
      const result = [];
      const totalWidth = 100;
      if (this.marks.length > 0 || Object.keys(this.marks) && Object.keys(this.marks).length > 0) {
        // TODO: 判断数据正确性
        const markObj = Array.isArray(this.marks) ? this.marks.reduce((prev, curr) => {
          prev[curr] = curr;
          return prev;
        }, {}) : this.marks;
        for (const key in markObj) {
          result.push({
            stepWidth: (key - this.min) * totalWidth / (this.max - this.min),
            stepValue: markObj[key]
          });
        }
        return result;
      }
      if (this.step === 0) {
         false && false;
        return [];
      }
      const stopCount = (this.max - this.min) / this.step;
      const stepWidth = totalWidth * this.step / (this.max - this.min);
      for (let i = 0; i <= stopCount; i++) {
        result.push({
          stepWidth: i * stepWidth,
          stepValue: this.min + i * this.step
        });
      }
      return result;
    },
    minValue() {
      return Math.min(this.firstValue, this.secondValue);
    },
    maxValue() {
      return Math.max(this.firstValue, this.secondValue);
    },
    barSize() {
      return this.range ? `${100 * (this.maxValue - this.minValue) / (this.max - this.min)}%` : `${100 * (this.firstValue - this.min) / (this.max - this.min)}%`;
    },
    barStart() {
      return this.range ? `${100 * (this.minValue - this.min) / (this.max - this.min)}%` : '0%';
    },
    precision() {
      const precisions = [this.min, this.max, this.step].map(item => {
        const decimal = ('' + item).split('.')[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    },
    runwayStyle() {
      return this.vertical ? {
        height: this.height
      } : {};
    },
    barStyle() {
      return this.vertical ? {
        height: this.barSize,
        bottom: this.barStart
      } : {
        width: this.barSize,
        left: this.barStart
      };
    },
    internalShowButton() {
      return this.showButton && !this.range && !this.showInput;
    }
  },
  watch: {
    value(val, oldVal) {
      if (this.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index])) {
        return;
      }
      this.setValues();
    },
    dragging(val) {
      if (!val) {
        this.setValues();
      }
    },
    firstValue(val) {
      if (this.range) {
        this.$emit('input', [this.minValue, this.maxValue]);
      } else {
        this.$emit('input', val);
      }
    },
    secondValue() {
      if (this.range) {
        this.$emit('input', [this.minValue, this.maxValue]);
      }
    },
    min() {
      this.setValues();
    },
    max() {
      this.setValues();
    }
  },
  mounted() {
    if (this.range) {
      if (Array.isArray(this.value)) {
        this.firstValue = Math.max(this.min, this.value[0]);
        this.secondValue = Math.min(this.max, this.value[1]);
      } else {
        this.firstValue = this.min;
        this.secondValue = this.max;
      }
      this.oldValue = [this.firstValue, this.secondValue];
      // 增加范围选择带输入框 add by yangzhini at 2019-4-18
      if (this.showInput) {
        this.sliderInput = this.createInputElement(0);
        this.sliderInput2 = this.createInputElement(1);

        /**
         * modify by taooujing 2023-08-21
         * sliderInput不添加到body层。直接添加在button-wrappwe层。
         * 设置其位置为absoulute;top:-32px;left:-16px;
         *
         * vertical时，位置设置为right:-56px;top:-4px
         */

        this.sliderInput.$el.style.position = 'absolute';
        this.sliderInput2.$el.style.position = 'absolute';

        // button-wrapper绑定了mouseenter，mouseleave，mousedown事件。input-number需要去除这些事件。
        this.sliderInput.$el.addEventListener('mouseenter', e => {
          e.stopPropagation();
        });
        this.sliderInput.$el.addEventListener('mouseleave', e => {
          e.stopPropagation();
        });
        this.sliderInput.$el.addEventListener('mousedown', e => {
          e.stopPropagation();
        });
        this.sliderInput2.$el.addEventListener('mouseenter', e => {
          e.stopPropagation();
        });
        this.sliderInput2.$el.addEventListener('mouseleave', e => {
          e.stopPropagation();
        });
        this.sliderInput2.$el.addEventListener('mousedown', e => {
          e.stopPropagation();
        });
        if (this.vertical) {
          this.sliderInput.$el.style.top = '-4px';
          this.sliderInput.$el.style.right = '-56px';
          this.sliderInput2.$el.style.top = '-4px';
          this.sliderInput2.$el.style.right = '-56px';
          // 设置slider右部padding
          this.$refs.sliderContainer.style.paddingRight = '56px';
        } else {
          this.sliderInput.$el.style.top = '-32px';
          this.sliderInput.$el.style.left = '-16px';
          this.sliderInput.$el.style.zIndex = '10';
          this.sliderInput2.$el.style.top = '-32px';
          this.sliderInput2.$el.style.left = '-16px';
          this.sliderInput.$el.style.zIndex = '11';

          // 设置slider顶部padding
          this.$refs.sliderContainer.style.paddingTop = '30px';
        }
        this.$refs.button1.$el.appendChild(this.sliderInput.$el);
        this.$refs.button2.$el.appendChild(this.sliderInput2.$el);
        this.$watch('value', val => {
          this.sliderInput.value = this.firstValue;
          this.sliderInput2.value = this.secondValue;
          // this.sliderInput.updatePopper();
          // this.sliderInput2.updatePopper();
        });
      }
    } else {
      if (typeof this.value !== 'number' || isNaN(this.value)) {
        this.firstValue = this.min;
      } else {
        this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
      }
      this.oldValue = this.firstValue;
    }
    this.resetSize();
    window.addEventListener('resize', this.resetSize);
  },
  beforeDestroy() {
    window.removeEventListener('resize', this.resetSize);
    if (this.sliderInput) {
      this.sliderInput.$destroy(true);
    }
    if (this.sliderInput2) {
      this.sliderInput2.$destroy(true);
    }
  },
  methods: {
    valueChanged() {
      if (this.range) {
        return ![this.minValue, this.maxValue].every((item, index) => item === this.oldValue[index]);
      } else {
        return this.value !== this.oldValue;
      }
    },
    setValues() {
      if (this.min > this.max) {
        console.error('[Hui Error][Slider]min should not be greater than max.');
        return;
      }
      const val = this.value;
      if (this.range && Array.isArray(val)) {
        if (val[1] < this.min) {
          this.$emit('input', [this.min, this.min]);
        } else if (val[0] > this.max) {
          this.$emit('input', [this.max, this.max]);
        } else if (val[0] < this.min) {
          this.$emit('input', [this.min, val[1]]);
        } else if (val[1] > this.max) {
          this.$emit('input', [val[0], this.max]);
        } else {
          this.firstValue = val[0];
          this.secondValue = val[1];
          if (this.valueChanged()) {
            this.$emit('change', [this.minValue, this.maxValue]);
            this.dispatch('ElFormItem', 'el.form.change', [this.minValue, this.maxValue]);
            this.oldValue = val.slice();
          }
        }
      } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
        if (val < this.min) {
          this.$emit('input', this.min);
        } else if (val > this.max) {
          this.$emit('input', this.max);
        } else {
          this.firstValue = val;
          if (this.valueChanged()) {
            this.$emit('change', val);
            this.dispatch('ElFormItem', 'el.form.change', val);
            this.oldValue = val;
          }
        }
      }
    },
    setPosition(percent, type) {
      const targetValue = this.min + percent * (this.max - this.min) / 100;
      if (!this.range) {
        this.$refs.button1.setPosition(percent, type);
        return;
      }
      let button;
      if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
        button = this.firstValue < this.secondValue ? 'button1' : 'button2';
      } else {
        button = this.firstValue > this.secondValue ? 'button1' : 'button2';
      }
      this.$refs[button].setPosition(percent, type);
    },
    onSliderClick(event) {
      if (this.disabled || this.dragging) return;
      // add by zhangxiaogang
      this.$emit('before-click', event, this.range && Array.isArray(this.value) ? [this.minValue, this.maxValue] : this.value);
      this.resetSize();
      if (this.vertical) {
        const sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
        this.setPosition((sliderOffsetBottom - event.clientY) / this.sliderSize * 100, 'slider-click-value-change');
      } else {
        const sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
        this.setPosition((event.clientX - sliderOffsetLeft) / this.sliderSize * 100, 'slider-click-value-change');
      }
    },
    sliderClickValueChange(value) {
      if (this.range && Array.isArray(value)) {
        this.$emit('slider-click', [this.minValue, this.maxValue]);
      } else {
        this.$emit('slider-click', value);
      }
    },
    onSecondButtonClick() {
      this.vertical ? this.firstValue -= this.step : this.firstValue += this.step;
    },
    onFirstButtonClick() {
      this.vertical ? this.firstValue += this.step : this.firstValue -= this.step;
    },
    resetSize() {
      if (this.$refs.slider) {
        this.sliderSize = this.$refs.slider[`client${this.vertical ? 'Height' : 'Width'}`];
      }
    },
    // add by zhangxiaogang
    dragEnd() {
      if (this.range && Array.isArray(this.value)) {
        this.$emit('drag-end', [this.minValue, this.maxValue]);
      } else {
        this.$emit('drag-end', this.value);
      }
    },
    // range show-input 情况下，点击 button聚焦 input add by yangzhini
    buttonDown(sliderInput) {
      // 点击失去焦点
      if (this.$refs.input && this.$refs.input.$refs.input.$refs.input) {
        this.$refs.input.$refs.input.$refs.input.blur();
      }
      if (!sliderInput) return;
      this.sliderInputSelect(sliderInput);
    },
    sliderInputSelect(sliderInput) {
      if (!sliderInput) return;
      sliderInput.$refs.rangeInput.$refs.input.$refs.input.select();
    },
    // add by yangzhini
    createInputElement(index) {
      const sliderInput = new external_vue_default.a(src_input);
      sliderInput.value = this.value[index];
      sliderInput.button = this.$refs[`button${index + 1}`].$el;
      sliderInput.slider = this;
      !this.$isServer && sliderInput.$mount(document.createElement('div'));
      sliderInput.$on('change', value => {
        if (index === 0) {
          this.firstValue = value;
        } else {
          this.secondValue = value;
        }
        // 解决[1,6]变为[6,9]时（即1改为9）显示为[9,9]的问题
        sliderInput.$refs.rangeInput.$refs.input.$refs.input.value = value;

        // sliderInput.updatePopper();
      });
      return sliderInput;
    },
    handleBlur(event) {
      this.$emit('blur', event);
    }
  }
});
// CONCATENATED MODULE: ./packages/slider/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_slider_src_mainvue_type_script_lang_js_ = (slider_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/slider/src/main.vue





/* normalize component */

var slider_src_main_component = normalizeComponent(
  packages_slider_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_e68e388a_render,
  mainvue_type_template_id_e68e388a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var slider_src_main = (slider_src_main_component.exports);
// CONCATENATED MODULE: ./packages/slider/index.js


/* istanbul ignore next */
slider_src_main.install = function (Vue) {
  Vue.component(slider_src_main.name, slider_src_main);
};
/* harmony default export */ var slider = (slider_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/loading/src/loading.vue?vue&type=template&id=3daff638&
var loadingvue_type_template_id_3daff638_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-loading-fade"},on:{"after-leave":_vm.handleAfterLeave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-loading-mask",class:[_vm.customClass, { 'is-fullscreen': _vm.fullscreen }]},[_c('div',{staticClass:"el-loading-spinner"},[_c('loading-icon',{staticClass:"h-icon-loading loading-icon"}),(_vm.text)?_c('p',{staticClass:"el-loading-text"},[_vm._v(" "+_vm._s(_vm.text)+" ")]):_vm._e()],1)])])}
var loadingvue_type_template_id_3daff638_staticRenderFns = []


// CONCATENATED MODULE: ./packages/loading/src/loading.vue?vue&type=template&id=3daff638&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/loading-icon.vue?vue&type=template&id=ea67e116&
var loading_iconvue_type_template_id_ea67e116_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"h-an-icon-loading"},[_c('span',{ref:"path1",staticClass:"path1"}),_c('span',{ref:"path2",staticClass:"path2"}),_c('span',{ref:"path3",staticClass:"path3"}),_c('span',{ref:"path4",staticClass:"path4"})])}
var loading_iconvue_type_template_id_ea67e116_staticRenderFns = []


// CONCATENATED MODULE: ./packages/icon/src/loading-icon.vue?vue&type=template&id=ea67e116&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/loading-icon.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//

/* harmony default export */ var loading_iconvue_type_script_lang_js_ = ({
  name: 'ElLoadIcon',
  data() {
    return {
      interval: []
    };
  },
  mounted() {
    if (navigator.appName === 'Microsoft Internet Explorer' && navigator.appVersion.split(';')[1].replace(/[ ]/g, '') === 'MSIE9.0' && !this.dataPicker) {
      this.animation({
        time: 0,
        ref: this.$refs.path1
      });
      this.animation({
        time: 600,
        ref: this.$refs.path2
      });
      this.animation({
        time: 800,
        ref: this.$refs.path3
      });
      this.animation({
        time: 1000,
        ref: this.$refs.path4
      });
    }
  },
  beforeDestroy() {
    for (const i in this.interval) {
      this.interval[i] && clearInterval(this.interval[i]);
    }
  },
  methods: {
    scale(scale, ref) {
      ref.style.msTransform = 'scale(' + (1 + scale) + ')';
      ref.style.opacity = 0.3 + scale;
    },
    animation(op) {
      setTimeout(() => {
        let scale = 0;
        let isUp = true;
        const interval = setInterval(() => {
          if (scale === 0.7 || scale > 0.7) {
            isUp = false;
          } else if (scale === 0 || scale < 0) {
            isUp = true;
          }
          scale = isUp ? scale + 0.1 : scale - 0.1;
          this.scale(scale, op.ref);
        }, 80);
        this.interval.push(interval);
      }, op.time);
    }
  }
});
// CONCATENATED MODULE: ./packages/icon/src/loading-icon.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_loading_iconvue_type_script_lang_js_ = (loading_iconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/icon/src/loading-icon.vue





/* normalize component */

var loading_icon_component = normalizeComponent(
  src_loading_iconvue_type_script_lang_js_,
  loading_iconvue_type_template_id_ea67e116_render,
  loading_iconvue_type_template_id_ea67e116_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var loading_icon = (loading_icon_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/loading/src/loading.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var loadingvue_type_script_lang_js_ = ({
  components: {
    loadingIcon: loading_icon
  },
  data() {
    return {
      text: null,
      fullscreen: true,
      visible: false,
      customClass: ''
    };
  },
  methods: {
    handleAfterLeave() {
      this.$emit('after-leave');
    },
    setText(text) {
      this.text = text;
    }
  }
});
// CONCATENATED MODULE: ./packages/loading/src/loading.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_loadingvue_type_script_lang_js_ = (loadingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/loading/src/loading.vue





/* normalize component */

var loading_component = normalizeComponent(
  src_loadingvue_type_script_lang_js_,
  loadingvue_type_template_id_3daff638_render,
  loadingvue_type_template_id_3daff638_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_loading = (loading_component.exports);
// CONCATENATED MODULE: ./packages/loading/src/directive.js



// let Mask = Vue.extend(require('./loading.vue'));
const Mask = external_vue_default.a.extend(src_loading);
/* harmony default export */ var src_directive = ({
  install: Vue => {
    if (Vue.prototype.$isServer) return;
    const toggleLoading = (el, binding) => {
      if (binding.value) {
        Vue.nextTick(() => {
          if (binding.modifiers.fullscreen) {
            el.originalPosition = getStyle(document.body, 'position');
            el.originalOverflow = getStyle(document.body, 'overflow');
            // 获取overflowX、overflowY值，在结束loading设置
            el.originalOverflowX = getStyle(document.body, 'overflowX');
            el.originalOverflowY = getStyle(document.body, 'overflowY');
            addClass(el.mask, 'is-fullscreen');
            insertDom(document.body, el, binding);
          } else {
            removeClass(el.mask, 'is-fullscreen');
            if (binding.modifiers.body) {
              el.originalPosition = getStyle(document.body, 'position');
              ['top', 'left'].forEach(property => {
                const scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
                el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
              });
              ['height', 'width'].forEach(property => {
                el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
              });
              insertDom(document.body, el, binding);
            } else {
              el.originalPosition = getStyle(el, 'position');
              insertDom(el, el, binding);
            }
          }
        });
      } else {
        if (el.domVisible) {
          el.instance.$on('after-leave', () => {
            el.domVisible = false;
            // 结束loading时，分别设置overflowX、overflowY，
            // 解决ie11下overflow多个值无法设置的问题，如：overflow: hidden auto;
            if (binding.modifiers.fullscreen && (el.originalOverflowX !== 'hidden' || el.originalOverflowY !== 'hidden')) {
              if (el.originalOverflowX === el.originalOverflowY) {
                document.body.style.overflow = el.originalOverflow;
              } else {
                document.body.style.overflow = '';
                document.body.style.overflowX = el.originalOverflowX;
                document.body.style.overflowY = el.originalOverflowY;
              }
            }
            if (binding.modifiers.fullscreen || binding.modifiers.body) {
              document.body.style.position = el.originalPosition;
            } else {
              el.style.position = el.originalPosition;
            }
          });
          Vue.nextTick(() => {
            el.instance.visible = false;
          });
        }
      }

      // icon大小
      if (binding.modifiers.mini) {
        addClass(el.mask, 'is-mini');
      } else if (binding.modifiers.small) {
        addClass(el.mask, 'is-small');
      } else if (binding.modifiers.large) {
        addClass(el.mask, 'is-large');
      } else {
        addClass(el.mask, 'is-default');
      }

      // 主题色
      addClass(el.mask, binding.modifiers.gray ? 'is-gray' : 'is-primary');
    };
    const insertDom = (parent, el, binding) => {
      if (!el.domVisible && getStyle(el, 'display') !== 'none' && getStyle(el, 'visibility') !== 'hidden') {
        Object.keys(el.maskStyle).forEach(property => {
          el.mask.style[property] = el.maskStyle[property];
        });
        if (el.originalPosition !== 'absolute' && el.originalPosition !== 'fixed') {
          // parent.style.position = 'relative';
        }
        if (binding.modifiers.fullscreen && binding.modifiers.lock) {
          parent.style.overflow = 'hidden';
        }
        el.domVisible = true;
        parent.appendChild(el.mask);
        Vue.nextTick(() => {
          el.instance.visible = true;
        });
        el.domInserted = true;
      }
    };
    Vue.directive('loading', {
      bind: function (el, binding) {
        const mask = new Mask({
          el: document.createElement('div'),
          data: {
            text: el.getAttribute('element-loading-text'),
            fullscreen: !!binding.modifiers.fullscreen
          }
        });
        el.instance = mask;
        el.mask = mask.$el;
        el.maskStyle = {};
        toggleLoading(el, binding);
      },
      update: function (el, binding) {
        el.instance.setText(el.getAttribute('element-loading-text'));
        if (binding.oldValue !== binding.value) {
          toggleLoading(el, binding);
        }
      },
      unbind: function (el) {
        if (el.domInserted) {
          /* if (binding.modifiers.fullscreen || binding.modifiers.body) {
            document.body.removeChild(el.mask);
          } else { */
          el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
          // }
        }
        el.instance && el.instance.$destroy();
      }
    });
  }
});
// CONCATENATED MODULE: ./packages/loading/src/index.js




const LoadingConstructor = external_vue_default.a.extend(src_loading);
const src_defaults = {
  text: null,
  fullscreen: true,
  body: false,
  lock: false,
  customClass: ''
};
let fullscreenLoading;
LoadingConstructor.prototype.originalPosition = '';
LoadingConstructor.prototype.originalOverflow = '';
LoadingConstructor.prototype.close = function () {
  if (this.fullscreen && this.originalOverflow !== 'hidden') {
    document.body.style.overflow = this.originalOverflow;
  }
  if (this.fullscreen || this.body) {
    document.body.style.position = this.originalPosition;
  } else {
    this.target.style.position = this.originalPosition;
  }
  if (this.fullscreen) {
    fullscreenLoading = undefined;
  }
  this.$on('after-leave', () => {
    this.$el && this.$el.parentNode && this.$el.parentNode.removeChild(this.$el);
    this.$destroy();
  });
  external_vue_default.a.nextTick(() => {
    this.visible = false;
  });
};
const addStyle = (options, parent, instance) => {
  const maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition = getStyle(document.body, 'position');
    instance.originalOverflow = getStyle(document.body, 'overflow');
  } else if (options.body) {
    instance.originalPosition = getStyle(document.body, 'position');
    ['top', 'left'].forEach(property => {
      const scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
      maskStyle[property] = options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
    });
    ['height', 'width'].forEach(property => {
      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';
    });
  } else {
    instance.originalPosition = getStyle(parent, 'position');
  }
  Object.keys(maskStyle).forEach(property => {
    instance.$el.style[property] = maskStyle[property];
  });
};
const Loading = (options = {}) => {
  if (external_vue_default.a.prototype.$isServer) return;
  options = merge({}, src_defaults, options);
  if (typeof options.target === 'string') {
    options.target = document.querySelector(options.target);
  }
  options.target = options.target || document.body;
  if (options.target !== document.body) {
    options.fullscreen = false;
  } else {
    options.body = true;
  }
  if (options.fullscreen && fullscreenLoading) {
    return fullscreenLoading;
  }
  const parent = options.body ? document.body : options.target;
  const instance = new LoadingConstructor({
    el: document.createElement('div'),
    data: options
  });
  addStyle(options, parent, instance);
  if (instance.originalPosition !== 'absolute' && instance.originalPosition !== 'fixed') {
    // parent.style.position = 'relative';
  }
  if (options.fullscreen && options.lock) {
    parent.style.overflow = 'hidden';
  }
  parent.appendChild(instance.$el);
  external_vue_default.a.nextTick(() => {
    instance.visible = true;
  });
  if (options.fullscreen) {
    fullscreenLoading = instance;
  }

  // icon大小
  addClass(instance.$el, options.size ? `is-${options.size}` : 'is-default');
  // 主题色
  addClass(instance.$el, options.color ? `is-${options.color}` : 'is-primary');
  return instance;
};
/* harmony default export */ var loading_src = (Loading);
// CONCATENATED MODULE: ./packages/loading/index.js


/* harmony default export */ var packages_loading = ({
  install(Vue) {
    Vue.use(src_directive);
    Vue.prototype.$loading = loading_src;
  },
  directive: src_directive,
  service: loading_src
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/icon.vue?vue&type=template&id=51fa78d1&
var iconvue_type_template_id_51fa78d1_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{class:'h-icon-' + _vm.name})}
var iconvue_type_template_id_51fa78d1_staticRenderFns = []


// CONCATENATED MODULE: ./packages/icon/src/icon.vue?vue&type=template&id=51fa78d1&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/icon.vue?vue&type=script&lang=js&
//
//
//
//

/* harmony default export */ var iconvue_type_script_lang_js_ = ({
  name: 'ElIcon',
  props: {
    name: {
      type: String,
      default: null
    }
  }
});
// CONCATENATED MODULE: ./packages/icon/src/icon.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_iconvue_type_script_lang_js_ = (iconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/icon/src/icon.vue





/* normalize component */

var icon_component = normalizeComponent(
  src_iconvue_type_script_lang_js_,
  iconvue_type_template_id_51fa78d1_render,
  iconvue_type_template_id_51fa78d1_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_icon = (icon_component.exports);
// CONCATENATED MODULE: ./packages/icon/index.js


/* istanbul ignore next */
src_icon.install = function (Vue) {
  Vue.component(src_icon.name, src_icon);
};
/* harmony default export */ var packages_icon = (src_icon);
// CONCATENATED MODULE: ./packages/loading-icon/index.js


/* istanbul ignore next */
loading_icon.install = function (Vue) {
  Vue.component(loading_icon.name, loading_icon);
};
/* harmony default export */ var packages_loading_icon = (loading_icon);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/feedback-icon.vue?vue&type=template&id=7ed91ee5&
var feedback_iconvue_type_template_id_7ed91ee5_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{class:_vm.feedbackIcon},[_c('span',{staticClass:"path1"}),_c('span',{staticClass:"path2"})])}
var feedback_iconvue_type_template_id_7ed91ee5_staticRenderFns = []


// CONCATENATED MODULE: ./packages/icon/src/feedback-icon.vue?vue&type=template&id=7ed91ee5&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/icon/src/feedback-icon.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//

/* harmony default export */ var feedback_iconvue_type_script_lang_js_ = ({
  name: 'HFeedbackIcon',
  props: {
    iconName: {
      type: String,
      default: undefined
    }
  },
  computed: {
    feedbackIcon() {
      return !this.iconName.includes('h-icon-') ? `h-icon-${this.iconName}` : this.iconName;
    }
  }
});
// CONCATENATED MODULE: ./packages/icon/src/feedback-icon.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_feedback_iconvue_type_script_lang_js_ = (feedback_iconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/icon/src/feedback-icon.vue





/* normalize component */

var feedback_icon_component = normalizeComponent(
  src_feedback_iconvue_type_script_lang_js_,
  feedback_iconvue_type_template_id_7ed91ee5_render,
  feedback_iconvue_type_template_id_7ed91ee5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var feedback_icon = (feedback_icon_component.exports);
// CONCATENATED MODULE: ./packages/feedback-icon/index.js


/* istanbul ignore next */
feedback_icon.install = function (Vue) {
  Vue.component(feedback_icon.name, feedback_icon);
};
/* harmony default export */ var packages_feedback_icon = (feedback_icon);
// CONCATENATED MODULE: ./packages/row/src/row.js
/* harmony default export */ var src_row = ({
  name: 'ElRow',
  componentName: 'ElRow',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    gutter: Number,
    type: String,
    justify: {
      type: String,
      default: 'start'
    },
    align: {
      type: String,
      default: 'top'
    }
  },
  computed: {
    style() {
      var ret = {};
      if (this.gutter) {
        ret.marginLeft = `-${this.gutter / 2}px`;
        ret.marginRight = ret.marginLeft;
      }
      return ret;
    }
  },
  render(h) {
    return h(this.tag, {
      class: ['el-row', this.justify !== 'start' ? `is-justify-${this.justify}` : '', this.align !== 'top' ? `is-align-${this.align}` : '', {
        'el-row--flex': this.type === 'flex'
      }],
      style: this.style
    }, this.$slots.default);
  }
});
// CONCATENATED MODULE: ./packages/row/index.js


/* istanbul ignore next */
src_row.install = function (Vue) {
  Vue.component(src_row.name, src_row);
};
/* harmony default export */ var packages_row = (src_row);
// CONCATENATED MODULE: ./packages/upload/src/ajax.js

function getError(action, option, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to post ${action} ${xhr.status}`;
  }
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    const returnBody = JSON.parse(text);
    returnBody._xhr_ = xhr; // 加入response完整对象返回
    return returnBody;
  } catch (e) {
    return text;
  }
}
function upload(option) {
  if (typeof XMLHttpRequest === 'undefined') {
    return;
  }
  const xhr = new XMLHttpRequest();
  const action = option.action;
  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option.onProgress(e);
    };
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach(key => {
      formData.append(key, option.data[key]);
    });
  }
  formData.append(option.filename, option.file);
  xhr.onerror = function error(e) {
    option.onError(e, xhr);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr), xhr);
    }
    option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open('post', action, true);
  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }
  let headers;
  if (option.headers) {
    headers = isFunction(option.headers) ? option.headers() : option.headers;
  } else {
    headers = {};
  }
  for (const item in headers) {
    if (hasOwn(headers, item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  }
  xhr.send(formData);
  return xhr;
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-list.vue?vue&type=template&id=77b44308&
var upload_listvue_type_template_id_77b44308_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{class:[
    'el-upload-list',
    'el-upload-list--' + _vm.listType,
    { 'is-disabled': _vm.disabled }
  ],attrs:{"name":"el-list"}},[_vm._l((_vm.files),function(file,index){return _c('li',{key:("" + index),class:['el-upload-list__item', 'is-' + file.status]},[_c('el-tooltip',{attrs:{"disabled":file.status !== 'fail',"content":_vm.errorTooltipText,"placement":"top","effect":"light"}},[_c('div',[(_vm.listType === 'text')?_c('i',{staticClass:"h-icon-attach"}):_vm._e(),_c('div',{staticClass:"el-upload-list__item-content"},[(
              ['picture-card', 'picture'].indexOf(_vm.listType) > -1 &&
                (file.percentage === undefined ||
                  file.percentage >= 100 ||
                  file.status === 'success' ||
                  _vm.autoUpload === false)
            )?_c('img',{staticClass:"el-upload-list__item-thumbnail",attrs:{"src":file.url,"alt":""}}):_vm._e(),(
              ['picture-card', 'picture'].indexOf(_vm.listType) > -1 &&
                file.percentage !== undefined &&
                file.percentage < 100
            )?_c('i',{staticClass:"uploading-close h-icon-close",on:{"click":function($event){return _vm.$emit('remove', file)}}}):_vm._e(),_c('span',{staticClass:"el-upload-list__item-name",style:({ width: _vm.fileNameWidth(file) }),on:{"click":function($event){return _vm.handleClick(file)}}},[_c('name-content',{attrs:{"file":file,"file-name-render":_vm.fileNameRender}})],1),_c('i',{staticClass:"list-icon-btn h-icon-close_sm",on:{"click":function($event){return _vm.$emit('remove', file)}}}),(file.status === 'fail' && _vm.listType === 'text')?_c('i',{staticClass:"list-icon-btn h-icon-refresh_sm",on:{"click":function($event){return _vm.handleReupload(file)}}}):_vm._e(),(file.status === 'uploading')?_c('el-progress',{attrs:{"show-text":false,"stroke-width":2,"percentage":_vm.parsePercentage(file.percentage),"type":"line"}}):_vm._e()],1),(
            _vm.listType === 'picture-card' &&
              (file.percentage === undefined ||
                file.percentage >= 100 ||
                file.status === 'success' ||
                _vm.autoUpload === false)
          )?_c('span',{staticClass:"el-upload-list__item-actions"},[(file.status === 'fail' && _vm.listType === 'picture-card')?_c('span',{staticClass:"el-upload-list__item-reupload",on:{"click":function($event){return _vm.handleReupload(file)}}},[_c('i',{staticClass:"h-icon-refresh"})]):_vm._e(),(
              file.status !== 'fail' &&
                _vm.handlePreview &&
                _vm.listType === 'picture-card'
            )?_c('span',{staticClass:"el-upload-list__item-preview",on:{"click":function($event){return _vm.handlePreview(file)}}},[_c('i',{staticClass:"h-icon-zoom_in"})]):_vm._e(),_c('span',{staticClass:"el-upload-list__item-delete",on:{"click":function($event){return _vm.$emit('remove', file)}}},[_c('i',{staticClass:"h-icon-delete"})])]):_vm._e()])])],1)}),_vm._t("default")],2)}
var upload_listvue_type_template_id_77b44308_staticRenderFns = []


// CONCATENATED MODULE: ./packages/upload/src/upload-list.vue?vue&type=template&id=77b44308&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=template&id=03b5e353&
var progressvue_type_template_id_03b5e353_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-progress",class:[
    'el-progress--' + _vm.type,
    _vm.status ? 'is-' + _vm.status : '',
    _vm.verticalAlign ? 'is-text-vertical' : '',
    {
      'el-progress--without-text': !_vm.internalShowText,
      'el-progress--text-inside': _vm.textInside,
      'el-progress--small': _vm.internalSmall
    }
  ]},[(_vm.type === 'line')?_c('div',{staticClass:"el-progress-bar"},[_c('div',{staticClass:"el-progress-bar__outer",style:({
        height: _vm.internalStrokeWidth + 'px',
        'border-radius': _vm.strokeLinecap === 'square' ? '0px' : '100px'
      })},[_c('div',{staticClass:"el-progress-bar__inner",style:(_vm.barStyle)},[(_vm.internalShowText && _vm.textInside)?_c('div',{staticClass:"el-progress-bar__innerText"},[_vm._v(" "+_vm._s(_vm.percentage)+"% ")]):_vm._e(),(_vm.internalDynamic)?_c('div',{staticClass:"el-progress-bar__dynamic-block",style:(("animation-duration:" + _vm.duration + "s;"))}):_vm._e()])])]):_c('div',{staticClass:"el-progress-circle",style:({ height: _vm.width + 'px', width: _vm.width + 'px' })},[_c('svg',{attrs:{"viewBox":"0 0 100 100"}},[_c('path',{staticClass:"el-progress-circle__track",attrs:{"d":_vm.trackPath,"stroke-width":_vm.relativeStrokeWidth,"stroke":"#ebebeb","fill":"none"}}),_c('path',{staticClass:"el-progress-circle__path",style:(_vm.circlePathStyle),attrs:{"d":_vm.trackPath,"stroke":_vm.stroke,"stroke-width":_vm.relativeStrokeWidth,"fill":"none"}})])]),(_vm.internalShowText && !_vm.textInside)?_c('div',{staticClass:"el-progress__text",style:({ fontSize: _vm.progressTextSize + 'px' }),attrs:{"title":!_vm.status ? (_vm.percentage + "%") : _vm.statusText}},[_vm._t("text",function(){return [(!_vm.status)?[_vm._v(_vm._s(_vm.percentage)+"%")]:[_c('i',{class:_vm.iconClass,style:({ fontSize: _vm.iconSize + 'px' })}),(_vm.type === 'line')?_c('span',{staticClass:"el-progress__status-text"},[_vm._v(" "+_vm._s(_vm.statusText)+" ")]):_vm._e()]]})],2):_vm._e()])}
var progressvue_type_template_id_03b5e353_staticRenderFns = []


// CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=template&id=03b5e353&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/progress/src/progress.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

const STROKE_WIDTH_SMALL = 8;
/* harmony default export */ var progressvue_type_script_lang_js_ = ({
  name: 'ElProgress',
  props: {
    type: {
      type: String,
      default: 'line',
      validator: val => ['line', 'circle'].indexOf(val) > -1
    },
    percentage: {
      type: Number,
      default: 0,
      validator: val => val >= 0 && val <= 100
    },
    status: {
      type: String,
      default: ''
    },
    strokeWidth: {
      type: Number,
      default() {
        return this.type === 'line' ? 12 : 8;
      }
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 160
    },
    showText: {
      type: Boolean,
      default: true
    },
    verticalAlign: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: ''
    },
    background: {
      type: String,
      default: ''
    },
    statusText: {
      type: String,
      default: ''
    },
    strokeLinecap: {
      type: String,
      default: 'square'
    },
    dynamic: {
      type: Boolean,
      default: false
    },
    // 动态进度条一次的播放时间,单位为秒 modify by yangzhini 2019-04-15
    duration: {
      type: Number,
      default: 1.5,
      validator: val => val >= 0
    }
  },
  computed: {
    barStyle() {
      var style = {};
      style.backgroundColor = this.color;
      if (this.background) style.background = this.background;
      // 动态进度条在不知道进度的时候使用, 为配合动效, 将percentage设置为100%
      style.width = this.internalDynamic ? '100%' : this.percentage + '%';
      style.borderRadius = this.strokeLinecap === 'square' ? '0px' : '100px';
      return style;
    },
    relativeStrokeWidth() {
      // 进度圈暂不支持小型模式, 直接使用strokeWidth
      return (this.strokeWidth / this.width * 100).toFixed(1);
    },
    trackPath() {
      var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);
      return `M 50 50 m 0 -${radius} a ${radius} ${radius} 0 1 1 0 ${radius * 2} a ${radius} ${radius} 0 1 1 0 -${radius * 2}`;
    },
    perimeter() {
      var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
      return 2 * Math.PI * radius;
    },
    circlePathStyle() {
      var perimeter = this.perimeter;
      return {
        strokeDasharray: `${perimeter}px,${perimeter}px`,
        strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
        transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease',
        strokeLinecap: this.percentage === 0 ? '' : this.strokeLinecap === 'square' ? 'butt' : 'round'
      };
    },
    stroke() {
      var ret;
      switch (this.status) {
        case 'success':
          ret = this.color || '#02bf0f'; // $--color-success
          break;
        case 'exception':
          ret = this.color || '#fa3239'; // $--color-danger
          break;
        default:
          ret = this.color || '#2196f3';
        // $--color-info
      }
      return ret;
    },
    iconClass() {
      if (this.type === 'line') {
        return this.status === 'success' ? 'h-icon-tip_right' : 'h-icon-tip_error';
      } else {
        return this.status === 'success' ? 'h-icon-done' : 'h-icon-close';
      }
    },
    progressTextSize() {
      return this.type === 'line' ? 8 + this.internalStrokeWidth * 0.5 : this.width * 0.111111;
    },
    iconSize() {
      return this.type === 'line' ? 12 + this.internalStrokeWidth * 0.5 : this.width * 0.2 + 16;
    },
    // '小型'只在线形非内显进度条上生效
    internalSmall() {
      return this.small && this.type === 'line' && !this.textInside;
    },
    // 确定所使用的线宽, 小型进度条优先使用8px线宽, 否则根据strokeWidth来设定线宽
    internalStrokeWidth() {
      return this.internalSmall ? STROKE_WIDTH_SMALL : this.strokeWidth;
    },
    // 动态进度条不显示text
    internalShowText() {
      return this.internalDynamic ? false : this.showText;
    },
    // 动态进度条暂时只支持线形进度条
    internalDynamic() {
      return this.dynamic && this.type === 'line';
    }
  }
});
// CONCATENATED MODULE: ./packages/progress/src/progress.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_progressvue_type_script_lang_js_ = (progressvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/progress/src/progress.vue





/* normalize component */

var progress_component = normalizeComponent(
  src_progressvue_type_script_lang_js_,
  progressvue_type_template_id_03b5e353_render,
  progressvue_type_template_id_03b5e353_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var progress = (progress_component.exports);
// CONCATENATED MODULE: ./packages/progress/index.js


/* istanbul ignore next */
progress.install = function (Vue) {
  Vue.component(progress.name, progress);
};
/* harmony default export */ var packages_progress = (progress);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-list.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var upload_listvue_type_script_lang_js_ = ({
  components: {
    ElProgress: packages_progress,
    ElTooltip: packages_tooltip,
    NameContent: {
      props: {
        file: {
          required: true
        },
        fileNameRender: Function
      },
      render(h) {
        const {
          name
        } = this.file;
        return this.fileNameRender ? this.fileNameRender(h, this.file) : h("span", [name]);
      }
    }
  },
  mixins: [locale],
  props: {
    files: {
      type: Array,
      default() {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    handlePreview: {
      type: Function,
      default: null
    },
    listType: {
      type: String,
      default: ''
    },
    reupload: {
      type: Function,
      default: null
    },
    fileNameRender: {
      type: Function,
      default: null
    },
    errorTooltipText: {
      type: String,
      default: 'upload error'
    },
    autoUpload: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    parsePercentage(val) {
      return parseInt(val, 10);
    },
    handleClick(file) {
      this.handlePreview && this.handlePreview(file);
    },
    handleReupload(file) {
      this.reupload && this.reupload(file);
    },
    fileNameWidth(file) {
      return file.status === 'fail' && this.listType === 'text' ? `calc(100% - 52px)` : `calc(100% - 28px)`;
    }
  }
});
// CONCATENATED MODULE: ./packages/upload/src/upload-list.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_upload_listvue_type_script_lang_js_ = (upload_listvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/upload/src/upload-list.vue





/* normalize component */

var upload_list_component = normalizeComponent(
  src_upload_listvue_type_script_lang_js_,
  upload_listvue_type_template_id_77b44308_render,
  upload_listvue_type_template_id_77b44308_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var upload_list = (upload_list_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-dragger.vue?vue&type=template&id=50cb1215&
var upload_draggervue_type_template_id_50cb1215_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-upload-dragger",class:{
    'is-dragover': _vm.dragover
  },on:{"drop":function($event){$event.preventDefault();return _vm.onDrop.apply(null, arguments)},"dragover":function($event){$event.preventDefault();return _vm.onDragover.apply(null, arguments)},"dragleave":function($event){$event.preventDefault();_vm.dragover = false}}},[_vm._t("default")],2)}
var upload_draggervue_type_template_id_50cb1215_staticRenderFns = []


// CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue?vue&type=template&id=50cb1215&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload-dragger.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var upload_draggervue_type_script_lang_js_ = ({
  name: 'ElUploadDrag',
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      dragover: false
    };
  },
  methods: {
    onDragover() {
      if (!this.disabled) {
        this.dragover = true;
      }
    },
    onDrop(e) {
      if (!this.disabled) {
        this.dragover = false;
        this.$emit('file', e.dataTransfer.files);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_upload_draggervue_type_script_lang_js_ = (upload_draggervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/upload/src/upload-dragger.vue





/* normalize component */

var upload_dragger_component = normalizeComponent(
  src_upload_draggervue_type_script_lang_js_,
  upload_draggervue_type_template_id_50cb1215_render,
  upload_draggervue_type_template_id_50cb1215_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var upload_dragger = (upload_dragger_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/upload.vue?vue&type=script&lang=js&



/* harmony default export */ var uploadvue_type_script_lang_js_ = ({
  components: {
    UploadDragger: upload_dragger
  },
  props: {
    visible: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: ''
    },
    action: {
      type: String,
      default: ''
    },
    name: {
      type: String,
      default: 'file'
    },
    data: {
      type: Object,
      default: null
    },
    headers: {
      type: [Function, Object],
      default: null
    },
    withCredentials: {
      type: Boolean,
      default: null
    },
    multiple: {
      type: Boolean,
      default: null
    },
    accept: {
      type: String,
      default: ''
    },
    onStart: {
      type: Function,
      default: null
    },
    onProgress: {
      type: Function,
      default: null
    },
    onSuccess: {
      type: Function,
      default: null
    },
    onError: {
      type: Function,
      default: null
    },
    beforeUpload: {
      type: Function,
      default: null
    },
    drag: {
      type: Boolean,
      default: null
    },
    onPreview: {
      type: Function,
      default: function () {}
    },
    onRemove: {
      type: Function,
      default: function () {}
    },
    onReady: {
      type: Function,
      default: null
    },
    fileList: {
      type: Array,
      default: null
    },
    autoUpload: {
      type: Boolean,
      default: null
    },
    listType: {
      type: String,
      default: ''
    },
    httpRequest: {
      type: Function,
      default: upload
    },
    disabled: {
      type: Boolean,
      default: false
    },
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: function () {}
    }
  },
  data() {
    return {
      mouseover: false,
      reqs: {}
    };
  },
  methods: {
    isImage(str) {
      return str.indexOf('image') !== -1;
    },
    handleChange(ev) {
      const files = ev.target.files;
      if (!files) return;
      this.uploadFiles(files);
    },
    uploadFiles(files) {
      if (this.limit && this.fileList.length + files.length > this.limit) {
        this.onExceed && this.onExceed(files, this.fileList);
        return;
      }
      let postFiles = Array.prototype.slice.call(files);
      if (!this.multiple) {
        postFiles = postFiles.slice(0, 1);
      }
      if (postFiles.length === 0) {
        return;
      }
      if (this.onReady) {
        const result = this.onReady(postFiles);
        if (result === false) return;
      }
      this.$parent.uploadFilesAll = [];
      postFiles.forEach(rawFile => {
        this.onStart(rawFile);
        if (this.autoUpload) this.upload(rawFile);
      });
    },
    upload(rawFile) {
      this.$refs.input.value = null;
      if (!this.beforeUpload) {
        return this.post(rawFile);
      }
      const before = this.beforeUpload(rawFile);
      if (before && before.then) {
        before.then(processedFile => {
          if (Object.prototype.toString.call(processedFile) === '[object File]') {
            this.post(processedFile);
          } else {
            this.post(rawFile);
          }
        }, () => {
          this.onRemove(null, rawFile);
        });
      } else if (before !== false) {
        this.post(rawFile);
      } else {
        this.onRemove(null, rawFile);
      }
    },
    abort(file) {
      const {
        reqs
      } = this;
      if (file) {
        let uid = file;
        if (file.uid) uid = file.uid;
        if (reqs[uid]) {
          reqs[uid].abort();
        }
      } else {
        Object.keys(reqs).forEach(uid => {
          if (reqs[uid]) reqs[uid].abort();
          delete reqs[uid];
        });
      }
    },
    post(rawFile) {
      const {
        uid
      } = rawFile;
      const options = {
        headers: this.headers,
        withCredentials: this.withCredentials,
        file: rawFile,
        data: this.data,
        filename: this.name,
        action: this.action,
        onProgress: e => {
          this.onProgress(e, rawFile);
        },
        onSuccess: (res, xhr) => {
          this.onSuccess(res, rawFile, xhr);
          delete this.reqs[uid];
        },
        onError: (err, xhr) => {
          this.onError(err, rawFile, xhr);
          delete this.reqs[uid];
        }
      };
      const req = this.httpRequest(options);
      this.reqs[uid] = req;
      if (req && req.then) {
        req.then(options.onSuccess, options.onError);
      }
    },
    handleClick() {
      if (!this.disabled) {
        this.$refs.input.value = null;
        this.$refs.input.click();
      }
    }
  },
  render() {
    const h = arguments[0];
    /* if (!this.visible) return; */

    const {
      visible,
      handleClick,
      drag,
      name,
      handleChange,
      multiple,
      accept,
      listType,
      uploadFiles,
      disabled
    } = this;
    const data = {
      class: {
        'el-upload': true
      },
      on: {
        click: handleClick
      }
    };
    data.class[`el-upload--${listType}`] = true;
    return h("div", babel_helper_vue_jsx_merge_props_default()([{}, data, {
      "directives": [{
        name: "show",
        value: visible
      }]
    }]), [drag ? h("upload-dragger", {
      "attrs": {
        "disabled": disabled
      },
      "on": {
        "file": uploadFiles
      }
    }, [this.$slots.default]) : this.$slots.default, h("input", {
      "class": 'el-upload__input',
      "attrs": {
        "type": 'file',
        "name": name,
        "multiple": multiple,
        "accept": accept
      },
      "ref": 'input',
      "on": {
        "change": handleChange
      }
    })]);
  }
});
// CONCATENATED MODULE: ./packages/upload/src/upload.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_uploadvue_type_script_lang_js_ = (uploadvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/upload/src/upload.vue
var upload_render, upload_staticRenderFns




/* normalize component */

var upload_component = normalizeComponent(
  src_uploadvue_type_script_lang_js_,
  upload_render,
  upload_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_upload = (upload_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/iframe-upload.vue?vue&type=script&lang=js&


/* harmony default export */ var iframe_uploadvue_type_script_lang_js_ = ({
  components: {
    UploadDragger: upload_dragger
  },
  props: {
    type: {
      type: String,
      default: null
    },
    data: {
      type: null,
      default: null
    },
    action: {
      type: String,
      default: ''
    },
    name: {
      type: String,
      default: 'file'
    },
    withCredentials: {
      type: Boolean,
      default: null
    },
    accept: {
      type: String,
      default: null
    },
    onStart: {
      type: Function,
      default: null
    },
    onProgress: {
      type: Function,
      default: null
    },
    onSuccess: {
      type: Function,
      default: null
    },
    onError: {
      type: Function,
      default: null
    },
    beforeUpload: {
      type: Function,
      default: null
    },
    onPreview: {
      type: Function,
      default: function () {}
    },
    onRemove: {
      type: Function,
      default: function () {}
    },
    drag: {
      type: Boolean,
      default: null
    },
    listType: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      mouseover: false,
      domain: '',
      file: null,
      submitting: false
    };
  },
  created() {
    this.frameName = 'frame-' + Date.now();
  },
  mounted() {
    const self = this;
    !this.$isServer && window.addEventListener('message', event => {
      if (!self.file) return;
      var targetOrigin = new URL(self.action).origin;
      if (event.origin !== targetOrigin) return;
      var response = event.data;
      if (response.result === 'success') {
        self.onSuccess(response, self.file);
      } else if (response.result === 'failed') {
        self.onError(response, self.file);
      }
      self.submitting = false;
      self.file = null;
    }, false);
  },
  methods: {
    isImage(str) {
      return str.indexOf('image') !== -1;
    },
    handleClick() {
      if (!this.disabled) {
        this.$refs.input.click();
      }
    },
    handleChange(ev) {
      const file = ev.target.value;
      if (file) {
        this.uploadFiles(file);
      }
    },
    uploadFiles(file) {
      if (this.submitting) return;
      this.submitting = true;
      this.file = file;
      this.onStart(file);
      const formNode = this.getFormNode();
      const dataSpan = this.getFormDataNode();
      let data = this.data;
      if (typeof data === 'function') {
        data = data(file);
      }
      const inputs = [];
      for (const key in data) {
        if (hasOwn(data, key)) {
          inputs.push(`<input name="${key}" value="${data[key]}"/>`);
        }
      }
      dataSpan.innerHTML = inputs.join('');
      formNode.submit();
      dataSpan.innerHTML = '';
    },
    getFormNode() {
      return this.$refs.form;
    },
    getFormDataNode() {
      return this.$refs.data;
    }
  },
  render() {
    const h = arguments[0];
    const {
      drag,
      uploadFiles,
      listType,
      frameName,
      disabled
    } = this;
    const oClass = {
      'el-upload': true
    };
    oClass[`el-upload--${listType}`] = true;
    return h("div", {
      "class": oClass,
      "on": {
        "click": this.handleClick
      },
      "nativeOn": {
        "drop": this.onDrop,
        "dragover": this.handleDragover,
        "dragleave": this.handleDragleave
      }
    }, [h("iframe", {
      "on": {
        "load": this.onload
      },
      "ref": 'iframe',
      "attrs": {
        "name": frameName
      }
    }), h("form", {
      "ref": 'form',
      "attrs": {
        "action": this.action,
        "target": frameName,
        "enctype": 'multipart/form-data',
        "method": 'POST'
      }
    }, [h("input", {
      "class": 'el-upload__input',
      "attrs": {
        "type": 'file',
        "name": 'file',
        "accept": this.accept
      },
      "ref": 'input',
      "on": {
        "change": this.handleChange
      }
    }), h("input", {
      "attrs": {
        "type": 'hidden',
        "name": 'documentDomain'
      },
      "domProps": {
        "value": this.$isServer ? '' : document.domain
      }
    }), h("span", {
      "ref": 'data'
    })]), drag ? h("upload-dragger", {
      "on": {
        "file": uploadFiles
      },
      "attrs": {
        "disabled": disabled
      }
    }, [this.$slots.default]) : this.$slots.default]);
  }
});
// CONCATENATED MODULE: ./packages/upload/src/iframe-upload.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_iframe_uploadvue_type_script_lang_js_ = (iframe_uploadvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/upload/src/iframe-upload.vue
var iframe_upload_render, iframe_upload_staticRenderFns




/* normalize component */

var iframe_upload_component = normalizeComponent(
  src_iframe_uploadvue_type_script_lang_js_,
  iframe_upload_render,
  iframe_upload_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var iframe_upload = (iframe_upload_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/upload/src/index.vue?vue&type=script&lang=js&







function srcvue_type_script_lang_js_noop() {}
/* harmony default export */ var srcvue_type_script_lang_js_ = ({
  name: 'ElUpload',
  components: {
    ElProgress: packages_progress,
    UploadList: upload_list,
    Upload: src_upload,
    IframeUpload: iframe_upload
  },
  mixins: [migrating],
  props: {
    action: {
      type: String,
      default: ''
    },
    headers: {
      type: Object,
      default() {
        return {};
      }
    },
    data: {
      type: Object,
      default() {
        return {};
      }
    },
    multiple: {
      type: Boolean,
      default: null
    },
    name: {
      type: String,
      default: 'file'
    },
    drag: {
      type: Boolean,
      default: null
    },
    dragger: {
      type: Boolean,
      default: null
    },
    withCredentials: {
      type: Boolean,
      default: null
    },
    showFileList: {
      type: Boolean,
      default: true
    },
    accept: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'select'
    },
    beforeUpload: {
      type: Function,
      default: null
    },
    beforeRemove: {
      type: Function,
      default: null
    },
    onRemove: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    onChange: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    onPreview: {
      type: Function,
      default: null
    },
    onSuccess: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    onProgress: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    onError: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    onReady: {
      type: Function,
      default: null
    },
    onSubmitError: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    fileList: {
      type: Array,
      default() {
        return [];
      }
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: 'text' // text,picture,picture-card
    },
    httpRequest: {
      type: Function,
      default: upload
    },
    disabled: {
      type: Boolean,
      default: false
    },
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: srcvue_type_script_lang_js_noop
    },
    fileNameRender: {
      type: Function,
      default: null
    },
    singleFile: {
      type: Boolean,
      default: false
    },
    errorTooltipText: {
      type: String,
      default: 'upload error'
    }
  },
  data() {
    return {
      uploadFiles: [],
      uploadFilesAll: [],
      // 用于存储所有上传的文件（无论是否showFileList）
      dragOver: false,
      draging: false,
      tempIndex: 1
    };
  },
  watch: {
    fileList: {
      immediate: true,
      handler(fileList) {
        this.uploadFiles = fileList.map(item => {
          item.uid = item.uid || Date.now() + this.tempIndex++;
          item.status = 'success';
          return item;
        });
      }
    }
  },
  methods: {
    reupload(rawFile) {
      this.$refs['upload-inner'].upload(rawFile);
    },
    handleStart(rawFile) {
      rawFile.uid = Date.now() + this.tempIndex++;
      const file = {
        status: 'ready',
        name: rawFile.name,
        size: rawFile.size,
        percentage: 0,
        uid: rawFile.uid,
        raw: rawFile
      };
      try {
        file.url = URL.createObjectURL(rawFile);
      } catch (err) {
        // eslint-disable-next-line
        console.error(err);
        return;
      }
      this.showFileList ? this.uploadFiles.push(file) : this.uploadFiles = [file];
      this.uploadFilesAll.push(file);

      // this.uploadFiles.push(file);
      this.onChange(file, this.uploadFiles);
    },
    handleProgress(ev, rawFile) {
      var file = this.getFile(rawFile);
      this.onProgress(ev, file, this.uploadFiles);
      file.status = 'uploading';
      file.percentage = ev.percent || 0;
    },
    handleSuccess(res, rawFile, xhr) {
      var file = this.getFile(rawFile);
      if (file) {
        file.status = 'success';
        file.response = res;
        this.onSuccess(res, file, this.uploadFiles, xhr);
        this.onChange(file, this.uploadFiles);
      }
    },
    handleError(err, rawFile, xhr) {
      var file = this.getFile(rawFile);
      // var fileList = this.uploadFiles;

      file.status = 'fail';

      // fileList.splice(fileList.indexOf(file), 1);

      this.onError(err, file, this.uploadFiles, xhr);
      this.onChange(file, this.uploadFiles);
    },
    handleRemove(file, raw) {
      if (raw) {
        file = this.getFile(raw);
      }
      const doRemove = () => {
        this.abort(file);
        const fileList = this.uploadFiles;
        fileList.splice(fileList.indexOf(file), 1);
        this.onRemove(file, fileList);
      };
      if (!this.beforeRemove) {
        doRemove();
      } else if (typeof this.beforeRemove === 'function') {
        const before = this.beforeRemove(file, this.uploadFiles);
        if (before && before.then) {
          before.then(() => {
            doRemove();
          }, srcvue_type_script_lang_js_noop);
        } else if (before !== false) {
          doRemove();
        }
      }
    },
    getFile(rawFile) {
      var fileList = this.multiple && this.showFileList === false ? this.uploadFilesAll : this.uploadFiles;
      var target;
      fileList.every(item => {
        target = rawFile.uid === item.uid ? item : null;
        return !target;
      });
      return target;
    },
    abort(file) {
      this.$refs['upload-inner'] && this.$refs['upload-inner'].abort(file);
    },
    clearFiles() {
      this.uploadFiles = [];
    },
    submit() {
      const readyFiles = this.uploadFiles.filter(file => file.status === 'ready');
      readyFiles.length === 0 ? this.onSubmitError({
        type: 'empty',
        uploadFiles: this.uploadFiles
      }) : readyFiles.forEach(file => {
        this.$refs['upload-inner'].upload(file.raw);
      });
    },
    getMigratingConfig() {
      return {
        props: {
          'default-file-list': 'default-file-list is renamed to file-list.',
          'show-upload-list': 'show-upload-list is renamed to show-file-list.',
          'thumbnail-mode': 'thumbnail-mode has been deprecated, you can implement the same effect according to this case: http://element.eleme.io/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan'
        }
      };
    }
  },
  render() {
    const h = arguments[0];
    var uploadList;
    var uploadData = {
      props: {
        visible: !(this.singleFile && this.uploadFiles.length >= 1),
        type: this.type,
        drag: this.drag,
        limit: this.limit,
        action: this.action,
        multiple: this.multiple,
        'before-upload': this.beforeUpload,
        'with-credentials': this.withCredentials,
        headers: this.headers,
        name: this.name,
        data: this.data,
        accept: this.accept,
        fileList: this.uploadFiles,
        autoUpload: this.autoUpload,
        listType: this.listType,
        disabled: this.disabled,
        'on-exceed': this.onExceed,
        'on-start': this.handleStart,
        'on-progress': this.handleProgress,
        'on-success': this.handleSuccess,
        'on-error': this.handleError,
        'on-preview': this.onPreview,
        'on-remove': this.handleRemove,
        'on-ready': this.onReady,
        'http-request': this.httpRequest
      },
      ref: 'upload-inner'
    };
    const trigger = this.$slots.trigger || this.$slots.default;
    var uploadComponent = typeof FormData !== 'undefined' || this.$isServer ? h("upload", babel_helper_vue_jsx_merge_props_default()([{}, uploadData]), [trigger]) : h("iframeUpload", babel_helper_vue_jsx_merge_props_default()([{}, uploadData]), [trigger]);

    /* if (this.singleFile && this.uploadFiles.length >= 1) {
      uploadComponent = undefined;
    } */
    if (this.showFileList) {
      uploadList = h(upload_list, {
        "attrs": {
          "disabled": this.disabled,
          "listType": this.listType,
          "files": this.uploadFiles,
          "reupload": this.reupload,
          "autoUpload": this.autoUpload,
          "handlePreview": this.onPreview,
          "fileNameRender": this.fileNameRender,
          "errorTooltipText": this.errorTooltipText
        },
        "on": {
          "remove": this.handleRemove
        }
      }, [this.listType === 'picture-card' && (this.limit == null || this.uploadFiles.length < this.limit) ? uploadComponent : '']);
    }
    return h("div", [this.listType === 'picture-card' ? uploadList : '', this.listType !== 'picture-card' ? this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent : '', this.$slots.tip, this.listType !== 'picture-card' ? uploadList : '']);
  }
});
// CONCATENATED MODULE: ./packages/upload/src/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var upload_srcvue_type_script_lang_js_ = (srcvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/upload/src/index.vue
var src_render, src_staticRenderFns




/* normalize component */

var upload_src_component = normalizeComponent(
  upload_srcvue_type_script_lang_js_,
  src_render,
  src_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var upload_src = (upload_src_component.exports);
// CONCATENATED MODULE: ./packages/upload/index.js


/* istanbul ignore next */
upload_src.install = function (Vue) {
  Vue.component(upload_src.name, upload_src);
};
/* harmony default export */ var packages_upload = (upload_src);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/spinner/src/spinner.vue?vue&type=template&id=0b250d7a&
var spinnervue_type_template_id_0b250d7a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"el-spinner"},[_c('svg',{staticClass:"el-spinner-inner",style:({ width: _vm.radius / 2 + 'px', height: _vm.radius / 2 + 'px' }),attrs:{"viewBox":"0 0 50 50"}},[_c('circle',{staticClass:"path",attrs:{"stroke":_vm.strokeColor,"stroke-width":_vm.strokeWidth,"cx":"25","cy":"25","r":"20","fill":"none"}})])])}
var spinnervue_type_template_id_0b250d7a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/spinner/src/spinner.vue?vue&type=template&id=0b250d7a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/spinner/src/spinner.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var spinnervue_type_script_lang_js_ = ({
  name: 'ElSpinner',
  props: {
    type: {
      type: String,
      default: null
    },
    radius: {
      type: Number,
      default: 100
    },
    strokeWidth: {
      type: Number,
      default: 5
    },
    strokeColor: {
      type: String,
      default: '#efefef'
    }
  }
});
// CONCATENATED MODULE: ./packages/spinner/src/spinner.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_spinnervue_type_script_lang_js_ = (spinnervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/spinner/src/spinner.vue





/* normalize component */

var spinner_component = normalizeComponent(
  src_spinnervue_type_script_lang_js_,
  spinnervue_type_template_id_0b250d7a_render,
  spinnervue_type_template_id_0b250d7a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var spinner = (spinner_component.exports);
// CONCATENATED MODULE: ./packages/spinner/index.js


/* istanbul ignore next */
spinner.install = function (Vue) {
  Vue.component(spinner.name, spinner);
};
/* harmony default export */ var packages_spinner = (spinner);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/message/src/main.vue?vue&type=template&id=b3417f3a&
var mainvue_type_template_id_b3417f3a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-message-fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.visible),expression:"visible"}],staticClass:"el-message",class:_vm.customClass,style:(("top:" + _vm.verticalOffset + "px")),on:{"mouseenter":_vm.clearTimer,"mouseleave":_vm.startTimer}},[(_vm.iconClass)?_c('i',{staticClass:"el-message__img",class:_vm.iconClass}):_c('feedback-icon',{staticClass:"el-message__typeImg",attrs:{"icon-name":_vm.typeClass}}),_c('div',{staticClass:"el-message__group",class:{ 'is-with-icon': _vm.iconClass }},[_vm._t("default",function(){return [_c('div',[(!_vm.dangerouslyUseHTMLString)?_c('p',{class:[_vm.showClose ? 'is-close' : '']},[_vm._v(" "+_vm._s(_vm.message)+" ")]):_c('p',{class:[_vm.showClose ? 'is-close' : ''],domProps:{"innerHTML":_vm._s(_vm.message)}})])]}),(_vm.showClose)?_c('div',{staticClass:"el-message__closeBtn h-icon-close_sm",on:{"click":_vm.close}}):_vm._e()],2)],1)])}
var mainvue_type_template_id_b3417f3a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/message/src/main.vue?vue&type=template&id=b3417f3a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/message/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


const mainvue_type_script_lang_js_typeMap = {
  success: 'feedback_success_md',
  info: 'feedback_info_md',
  warning: 'feedback_warning_md',
  error: 'feedback_error_md'
};
/* harmony default export */ var message_src_mainvue_type_script_lang_js_ = ({
  components: {
    feedbackIcon: feedback_icon
  },
  data() {
    return {
      visible: false,
      message: '',
      duration: 3000,
      type: 'info',
      iconClass: '',
      customClass: '',
      verticalOffset: 0,
      onClose: null,
      showClose: false,
      closed: false,
      timer: null,
      dangerouslyUseHTMLString: false
    };
  },
  computed: {
    typeClass() {
      return this.type && mainvue_type_script_lang_js_typeMap[this.type] ? `h-icon-${mainvue_type_script_lang_js_typeMap[this.type]}` : '';
    }
  },
  watch: {
    closed(newVal) {
      if (newVal) {
        this.visible = false;
        this.$el.addEventListener('transitionend', this.destroyElement);
      }
    }
  },
  mounted() {
    this.startTimer();
  },
  methods: {
    destroyElement() {
      this.$el.removeEventListener('transitionend', this.destroyElement);
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close() {
      this.closed = true;
      if (typeof this.onClose === 'function') {
        this.onClose(this);
      }
    },
    clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer() {
      if (this.duration > 0) {
        this.timer = setTimeout(() => {
          if (!this.closed) {
            this.close();
          }
        }, this.duration);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/message/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_message_src_mainvue_type_script_lang_js_ = (message_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/message/src/main.vue





/* normalize component */

var message_src_main_component = normalizeComponent(
  packages_message_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_b3417f3a_render,
  mainvue_type_template_id_b3417f3a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var message_src_main = (message_src_main_component.exports);
// CONCATENATED MODULE: ./packages/message/src/main.js




// let MessageConstructor = Vue.extend(require('./main.vue'));
const MessageConstructor = external_vue_default.a.extend(message_src_main);
let message_src_main_instance;
const src_main_instances = [];
let src_main_seed = 1;
var Message = function (options) {
  if (external_vue_default.a.prototype.$isServer) return;
  options = options || {};
  if (typeof options === 'string') {
    options = {
      message: options
    };
  }
  const userOnClose = options.onClose;
  const id = 'message_' + src_main_seed++;
  options.onClose = function () {
    Message.close(id, userOnClose);
  };
  message_src_main_instance = new MessageConstructor({
    data: options
  });
  let verticalOffset = 0;
  src_main_instances.forEach(item => {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  // 首个的位置为top:20px
  verticalOffset += 20;
  message_src_main_instance.verticalOffset = verticalOffset;
  message_src_main_instance.id = id;
  if (isVNode(message_src_main_instance.message)) {
    message_src_main_instance.$slots.default = [message_src_main_instance.message];
    message_src_main_instance.message = null;
  }
  message_src_main_instance.vm = message_src_main_instance.$mount();
  document.body.appendChild(message_src_main_instance.vm.$el);
  message_src_main_instance.vm.visible = true;
  message_src_main_instance.dom = message_src_main_instance.vm.$el;
  message_src_main_instance.dom.style.zIndex = popup_manager.nextZIndex();
  src_main_instances.push(message_src_main_instance);
  return message_src_main_instance.vm;
};
['success', 'warning', 'info', 'error'].forEach(type => {
  Message[type] = options => {
    if (typeof options === 'string') {
      options = {
        message: options
      };
    }
    options.type = type;
    return Message(options);
  };
});
Message.close = function (id, userOnClose) {
  const len = src_main_instances.length;
  for (let i = 0; i < len; i++) {
    if (id === src_main_instances[i].id) {
      if (typeof userOnClose === 'function') {
        userOnClose(src_main_instances[i]);
      }
      const removedHeight = src_main_instances[i].dom.offsetHeight;
      src_main_instances.splice(i, 1);
      if (len <= 1) return;
      for (let j = i; j < len - 1; j++) {
        src_main_instances[j].dom.style.top = parseInt(src_main_instances[j].dom.style.top, 10) - removedHeight - 16 + 'px';
      }
      break;
    }
  }
};
Message.closeAll = function () {
  for (let i = src_main_instances.length - 1; i >= 0; i--) {
    src_main_instances[i].close();
  }
};
/* harmony default export */ var packages_message_src_main = (Message);
// CONCATENATED MODULE: ./packages/message/index.js

/* harmony default export */ var packages_message = (packages_message_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/badge/src/main.vue?vue&type=template&id=58558c1e&
var mainvue_type_template_id_58558c1e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-badge"},[_vm._t("default"),_c('transition',{attrs:{"name":"el-zoom-in-center"}},[(_vm.max && _vm.showTip)?_c('ElTooltip',{attrs:{"content":'' + _vm.value,"placement":"right"}},[_c('sup',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hidden && (_vm.content || _vm.isDot)),expression:"!hidden && (content || isDot)"}],staticClass:"el-badge__content",class:{ 'is-fixed': _vm.$slots.default, 'is-dot': _vm.isDot },domProps:{"textContent":_vm._s(_vm.content)}})]):_c('sup',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hidden && (_vm.content || _vm.isDot)),expression:"!hidden && (content || isDot)"}],staticClass:"el-badge__content",class:{ 'is-fixed': _vm.$slots.default, 'is-dot': _vm.isDot },domProps:{"textContent":_vm._s(_vm.content)}})],1)],2)}
var mainvue_type_template_id_58558c1e_staticRenderFns = []


// CONCATENATED MODULE: ./packages/badge/src/main.vue?vue&type=template&id=58558c1e&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/badge/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var badge_src_mainvue_type_script_lang_js_ = ({
  name: 'ElBadge',
  components: {
    ElTooltip: packages_tooltip
  },
  props: {
    // showTips 最大值存在时，有效；鼠标移至 span 处有提示
    showTip: {
      type: Boolean,
      default: false
    },
    value: {
      type: null,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    isDot: {
      type: Boolean,
      default: null
    },
    hidden: {
      type: Boolean,
      default: null
    }
  },
  computed: {
    content() {
      if (this.isDot) return;
      const value = this.value;
      const max = this.max;
      if (typeof value === 'number' && typeof max === 'number') {
        return max < value ? `${max}+` : value;
      }
      return value;
    }
  }
});
// CONCATENATED MODULE: ./packages/badge/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_badge_src_mainvue_type_script_lang_js_ = (badge_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/badge/src/main.vue





/* normalize component */

var badge_src_main_component = normalizeComponent(
  packages_badge_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_58558c1e_render,
  mainvue_type_template_id_58558c1e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var badge_src_main = (badge_src_main_component.exports);
// CONCATENATED MODULE: ./packages/badge/index.js


/* istanbul ignore next */
badge_src_main.install = function (Vue) {
  Vue.component(badge_src_main.name, badge_src_main);
};
/* harmony default export */ var badge = (badge_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/card/src/main.vue?vue&type=template&id=be17ff72&
var mainvue_type_template_id_be17ff72_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-card"},[(_vm.$slots.header || _vm.header)?_c('div',{staticClass:"el-card__header"},[_vm._t("header",function(){return [_vm._v(" "+_vm._s(_vm.header)+" ")]})],2):_vm._e(),_c('div',{staticClass:"el-card__body",style:(_vm.bodyStyle)},[_vm._t("default")],2)])}
var mainvue_type_template_id_be17ff72_staticRenderFns = []


// CONCATENATED MODULE: ./packages/card/src/main.vue?vue&type=template&id=be17ff72&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/card/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var card_src_mainvue_type_script_lang_js_ = ({
  name: 'ElCard',
  props: {
    header: {
      type: null,
      default: null
    },
    bodyStyle: {
      type: null,
      default: null
    }
  }
});
// CONCATENATED MODULE: ./packages/card/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_card_src_mainvue_type_script_lang_js_ = (card_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/card/src/main.vue





/* normalize component */

var card_src_main_component = normalizeComponent(
  packages_card_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_be17ff72_render,
  mainvue_type_template_id_be17ff72_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var card_src_main = (card_src_main_component.exports);
// CONCATENATED MODULE: ./packages/card/index.js


/* istanbul ignore next */
card_src_main.install = function (Vue) {
  Vue.component(card_src_main.name, card_src_main);
};
/* harmony default export */ var card = (card_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/steps.vue?vue&type=template&id=00495b29&
var stepsvue_type_template_id_00495b29_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-steps",class:[
    'is-' + _vm.direction,
    _vm.rightTitle ? 'is-rightTitle' : '',
    _vm.isCenter ? 'is-center' : ''
  ]},[_vm._t("default")],2)}
var stepsvue_type_template_id_00495b29_staticRenderFns = []


// CONCATENATED MODULE: ./packages/steps/src/steps.vue?vue&type=template&id=00495b29&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/steps.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var stepsvue_type_script_lang_js_ = ({
  name: 'ElSteps',
  mixins: [emitter],
  props: {
    space: {
      type: [Number, String],
      default: null
    },
    active: {
      type: Number,
      default: null
    },
    direction: {
      type: String,
      default: 'horizontal'
    },
    size: {
      type: String,
      default: null
    },
    line: {
      type: Boolean,
      default: true
    },
    rightTitle: {
      type: Boolean,
      default: false
    },
    alignCenter: {
      type: Boolean,
      default: false
    },
    center: {
      type: Boolean,
      default: null
    },
    finishStatus: {
      type: String,
      default: 'finish'
    },
    processStatus: {
      type: String,
      default: 'process'
    },
    disorder: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      steps: [],
      stepOffset: 0
    };
  },
  computed: {
    isCenter() {
      return this.alignCenter || typeof this.space === 'string';
    }
  },
  watch: {
    active(newVal, oldVal) {
      this.$emit('change', newVal, oldVal);
    },
    steps(steps) {
      steps.forEach((child, index) => {
        child.index = index;
      });
      if (this.center) {
        const len = steps.length;
        this.$nextTick(() => {
          this.stepOffset = steps[len - 1].$el.getBoundingClientRect().width / (len - 1);
        });
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/steps/src/steps.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_stepsvue_type_script_lang_js_ = (stepsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/steps/src/steps.vue





/* normalize component */

var steps_component = normalizeComponent(
  src_stepsvue_type_script_lang_js_,
  stepsvue_type_template_id_00495b29_render,
  stepsvue_type_template_id_00495b29_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var steps = (steps_component.exports);
// CONCATENATED MODULE: ./packages/steps/index.js


/* istanbul ignore next */
steps.install = function (Vue) {
  Vue.component(steps.name, steps);
};
/* harmony default export */ var packages_steps = (steps);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/step.vue?vue&type=template&id=549b29de&
var stepvue_type_template_id_549b29de_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-step",class:[
    'is-' + _vm.$parent.direction,
    _vm.$parent.size ? 'el-step--' + _vm.$parent.size : '',
    _vm.icon ? 'el-step--' + 'icon' : '',
    _vm.isLast &&
      !_vm.$parent.space &&
      _vm.$parent.direction === 'horizontal' &&
      'is-flex',
    _vm.$parent.disorder ? 'el-step--' + 'disorder' : ''
  ],style:(_vm.style)},[(_vm.$parent.line)?_c('div',{staticClass:"el-step__line",class:['is-' + _vm.$parent.direction, { 'is-icon': _vm.icon }]},[_c('i',{staticClass:"el-step__line-inner",style:(_vm.lineStyle)})]):_vm._e(),_c('div',{staticClass:"el-step__head",class:['is-' + _vm.currentStatus, { 'is-text': !_vm.icon }],on:{"click":_vm.hdClick}},[_c('span',{staticClass:"el-step__icon"},[(
          _vm.currentStatus !== 'success' &&
            _vm.currentStatus !== 'error' &&
            _vm.$parent.size !== 'mini' &&
            !_vm.$parent.disorder
        )?_vm._t("icon",function(){return [(_vm.icon)?_c('i',{class:['h-icon-' + _vm.icon]}):_vm._e(),(!_vm.icon)?_c('div',[_vm._v(_vm._s(_vm.index + 1))]):_vm._e()]}):(_vm.$parent.size == 'mini' || _vm.$parent.disorder)?_c('i'):_c('i',{class:[
          'h-icon-' + (_vm.currentStatus === 'success' ? 'done' : 'close')
        ]})],2)]),_c('div',{ref:"main",staticClass:"el-step__main",class:[_vm.$parent.rightTitle ? 'rightTitle' : '']},[_c('div',{ref:"title",staticClass:"el-step__title",class:['is-' + _vm.currentStatus]},[_vm._t("title",function(){return [_vm._v(_vm._s(_vm.title))]})],2),_c('div',{staticClass:"el-step__description",class:['is-' + _vm.currentStatus]},[_vm._t("description",function(){return [_vm._v(_vm._s(_vm.description))]})],2)])])}
var stepvue_type_template_id_549b29de_staticRenderFns = []


// CONCATENATED MODULE: ./packages/steps/src/step.vue?vue&type=template&id=549b29de&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/steps/src/step.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var stepvue_type_script_lang_js_ = ({
  name: 'ElStep',
  mixins: [emitter],
  props: {
    title: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    description: {
      type: String,
      default: null
    },
    status: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      index: -1,
      lineStyle: {},
      internalStatus: ''
    };
  },
  computed: {
    currentStatus() {
      return this.status || this.internalStatus;
    },
    prevStatus() {
      const prevStep = this.$parent.steps[this.index - 1];
      return prevStep ? prevStep.currentStatus : 'wait';
    },
    isLast: function () {
      const parent = this.$parent;
      return parent.steps[parent.steps.length - 1] === this;
    },
    style: function () {
      const style = {};
      const parent = this.$parent;
      // const isCenter = parent.center;
      const len = parent.steps.length;

      // if (isCenter && this.isLast) {
      //   return {};
      // }

      const space = typeof parent.space === 'number' ? parent.space + 'px' : parent.space ? parent.space : 100 / (len - (parent.isCenter ? 0 : 1)) + '%';
      if (parent.direction === 'horizontal') {
        style.flexBasis = space;
      } else {
        if (!this.isLast) {
          style.flexBasis = space;
        }
      }
      return style;
    }
  },
  beforeCreate() {
    this.$parent.steps.push(this);
  },
  beforeDestroy() {
    const steps = this.$parent.steps;
    const index = steps.indexOf(this);
    if (index >= 0) {
      steps.splice(index, 1);
    }
  },
  mounted() {
    // const parent = this.$parent;

    const unwatch = this.$watch('index', () => {
      this.$watch('$parent.active', this.updateStatus, {
        immediate: true
      });
      unwatch();
    });
  },
  methods: {
    updateStatus(val) {
      const prevChild = this.$parent.$children[this.index - 1];
      if (val > this.index) {
        this.internalStatus = this.$parent.finishStatus;
      } else if (val === this.index && this.prevStatus !== 'error') {
        this.internalStatus = this.$parent.processStatus;
      } else {
        this.internalStatus = 'wait';
      }
      if (prevChild) prevChild.calcProgress(this.internalStatus);
    },
    calcProgress(status) {
      let step = 100;
      const style = {};
      style.transitionDelay = 150 * this.index + 'ms';
      if (status === this.$parent.processStatus) {
        step = this.currentStatus !== 'error' ? 100 : 0;
      } else if (status === 'wait') {
        step = 0;
        style.transitionDelay = -150 * this.index + 'ms';
      }
      if (this.$parent.direction === 'vertical') {
        style.borderLeftWidth = step ? '1px' : 0;
        style.height = step + '%';
      } else {
        style.borderTopWidth = step ? '1px' : 0;
        style.width = step + '%';
      }
      this.lineStyle = style;
    },
    hdClick() {
      this.$parent.$emit('step-click', this.index);
    }
  }
});
// CONCATENATED MODULE: ./packages/steps/src/step.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_stepvue_type_script_lang_js_ = (stepvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/steps/src/step.vue





/* normalize component */

var step_component = normalizeComponent(
  src_stepvue_type_script_lang_js_,
  stepvue_type_template_id_549b29de_render,
  stepvue_type_template_id_549b29de_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_step = (step_component.exports);
// CONCATENATED MODULE: ./packages/step/index.js


/* istanbul ignore next */
src_step.install = function (Vue) {
  Vue.component(src_step.name, src_step);
};
/* harmony default export */ var packages_step = (src_step);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/main.vue?vue&type=template&id=1894fc1f&
var mainvue_type_template_id_1894fc1f_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-carousel",class:{ 'el-carousel--card': _vm.type === 'card' },on:{"mouseenter":function($event){$event.stopPropagation();return _vm.handleMouseEnter.apply(null, arguments)},"mouseleave":function($event){$event.stopPropagation();return _vm.handleMouseLeave.apply(null, arguments)}}},[_c('div',{staticClass:"el-carousel__container",style:({ height: _vm.height })},[_c('transition',{attrs:{"name":"carousel-arrow-left"}},[(_vm.arrow !== 'never')?_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.arrow === 'always' || _vm.hover),expression:"arrow === 'always' || hover"}],staticClass:"el-carousel__arrow el-carousel__arrow--left",on:{"mouseenter":function($event){return _vm.handleButtonEnter('left')},"mouseleave":_vm.handleButtonLeave,"click":function($event){$event.stopPropagation();return _vm.throttledArrowClick(_vm.activeIndex - 1)}}},[_c('i',{staticClass:"h-icon-angle_left"})]):_vm._e()]),_c('transition',{attrs:{"name":"carousel-arrow-right"}},[(_vm.arrow !== 'never')?_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.arrow === 'always' || _vm.hover),expression:"arrow === 'always' || hover"}],staticClass:"el-carousel__arrow el-carousel__arrow--right",on:{"mouseenter":function($event){return _vm.handleButtonEnter('right')},"mouseleave":_vm.handleButtonLeave,"click":function($event){$event.stopPropagation();return _vm.throttledArrowClick(_vm.activeIndex + 1)}}},[_c('i',{staticClass:"h-icon-angle_right"})]):_vm._e()]),_vm._t("default")],2),(_vm.indicatorPosition !== 'none')?_c('ul',{staticClass:"el-carousel__indicators",class:{
      'el-carousel__indicators--labels': _vm.hasLabel,
      'el-carousel__indicators--outside':
        _vm.indicatorPosition === 'outside' || _vm.type === 'card'
    }},_vm._l((_vm.items),function(item,index){return _c('li',{key:index,staticClass:"el-carousel__indicator",class:{ 'is-active': index === _vm.activeIndex },on:{"mouseenter":function($event){return _vm.throttledIndicatorHover(index)},"click":function($event){$event.stopPropagation();return _vm.handleIndicatorClick(index)}}},[_c('button',{staticClass:"el-carousel__button"},[(_vm.hasLabel)?_c('span',[_vm._v(" "+_vm._s(item.label)+" ")]):_vm._e()])])}),0):_vm._e()])}
var mainvue_type_template_id_1894fc1f_staticRenderFns = []


// CONCATENATED MODULE: ./packages/carousel/src/main.vue?vue&type=template&id=1894fc1f&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var carousel_src_mainvue_type_script_lang_js_ = ({
  name: 'ElCarousel',
  props: {
    initialIndex: {
      type: Number,
      default: 0
    },
    height: {
      type: String,
      default: null
    },
    trigger: {
      type: String,
      default: 'hover'
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    interval: {
      type: Number,
      default: 3000
    },
    indicatorPosition: {
      type: String,
      default: null
    },
    indicator: {
      type: Boolean,
      default: true
    },
    arrow: {
      type: String,
      default: 'hover'
    },
    type: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      items: [],
      activeIndex: 0,
      containerWidth: 0,
      timer: null,
      hover: false
    };
  },
  computed: {
    hasLabel() {
      return this.items.some(item => item.label.toString().length > 0);
    }
  },
  watch: {
    items(val) {
      if (val.length > 0) this.setActiveItem(this.initialIndex);
    },
    activeIndex(val, oldVal) {
      this.resetItemPosition(oldVal);
      this.$emit('change', val, oldVal);
    },
    autoplay(val) {
      val ? this.startTimer() : this.pauseTimer();
    }
  },
  created() {
    this.throttledArrowClick = throttle_default()(300, true, index => {
      this.setActiveItem(index);
    });
    this.throttledIndicatorHover = throttle_default()(300, index => {
      this.handleIndicatorHover(index);
    });
  },
  mounted() {
    this.updateItems();
    this.$nextTick(() => {
      addResizeListener(this.$el, this.resetItemPosition);
      if (this.initialIndex < this.items.length && this.initialIndex >= 0) {
        this.activeIndex = this.initialIndex;
      }
      this.startTimer();
    });
  },
  beforeDestroy() {
    if (this.$el) removeResizeListener(this.$el, this.resetItemPosition);
  },
  methods: {
    handleMouseEnter() {
      this.hover = true;
      this.pauseTimer();
    },
    handleMouseLeave() {
      this.hover = false;
      this.startTimer();
    },
    itemInStage(item, index) {
      const length = this.items.length;
      if (index === length - 1 && item.inStage && this.items[0].active || item.inStage && this.items[index + 1] && this.items[index + 1].active) {
        return 'left';
      } else if (index === 0 && item.inStage && this.items[length - 1].active || item.inStage && this.items[index - 1] && this.items[index - 1].active) {
        return 'right';
      }
      return false;
    },
    handleButtonEnter(arrow) {
      this.items.forEach((item, index) => {
        if (arrow === this.itemInStage(item, index)) {
          item.hover = true;
        }
      });
    },
    handleButtonLeave() {
      this.items.forEach(item => {
        item.hover = false;
      });
    },
    updateItems() {
      this.items = this.$children.filter(child => child.$options.name === 'ElCarouselItem');
    },
    resetItemPosition(oldIndex) {
      this.items.forEach((item, index) => {
        item.translateItem(index, this.activeIndex, oldIndex);
      });
    },
    playSlides() {
      if (this.activeIndex < this.items.length - 1) {
        this.activeIndex++;
      } else {
        this.activeIndex = 0;
      }
    },
    pauseTimer() {
      clearInterval(this.timer);
    },
    startTimer() {
      if (this.interval <= 0 || !this.autoplay) return;
      this.timer = setInterval(this.playSlides, this.interval);
    },
    setActiveItem(index) {
      if (typeof index === 'string') {
        const filteredItems = this.items.filter(item => item.name === index);
        if (filteredItems.length > 0) {
          index = this.items.indexOf(filteredItems[0]);
        }
      }
      index = Number(index);
      if (isNaN(index) || index !== Math.floor(index)) {
        // eslint-disable-next-line
         false && false;
        return;
      }
      const length = this.items.length;
      if (index < 0) {
        this.activeIndex = length - 1;
      } else if (index >= length) {
        this.activeIndex = 0;
      } else {
        this.activeIndex = index;
      }
    },
    prev() {
      this.setActiveItem(this.activeIndex - 1);
    },
    next() {
      this.setActiveItem(this.activeIndex + 1);
    },
    handleIndicatorClick(index) {
      this.activeIndex = index;
    },
    handleIndicatorHover(index) {
      if (this.trigger === 'hover' && index !== this.activeIndex) {
        this.activeIndex = index;
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/carousel/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_carousel_src_mainvue_type_script_lang_js_ = (carousel_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/carousel/src/main.vue





/* normalize component */

var carousel_src_main_component = normalizeComponent(
  packages_carousel_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_1894fc1f_render,
  mainvue_type_template_id_1894fc1f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var carousel_src_main = (carousel_src_main_component.exports);
// CONCATENATED MODULE: ./packages/carousel/index.js


/* istanbul ignore next */
carousel_src_main.install = function (Vue) {
  Vue.component(carousel_src_main.name, carousel_src_main);
};
/* harmony default export */ var carousel = (carousel_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/item.vue?vue&type=template&id=206a29d2&
var itemvue_type_template_id_206a29d2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.ready),expression:"ready"}],staticClass:"el-carousel__item",class:{
    'is-active': _vm.active,
    'el-carousel__item--card': _vm.$parent.type === 'card',
    'is-in-stage': _vm.inStage,
    'is-hover': _vm.hover,
    'is-animating': _vm.animating
  },style:({
    msTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
    webkitTransform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")"),
    transform: ("translateX(" + _vm.translate + "px) scale(" + _vm.scale + ")")
  }),on:{"click":_vm.handleItemClick}},[(_vm.$parent.type === 'card')?_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.active),expression:"!active"}],staticClass:"el-carousel__mask"}):_vm._e(),_vm._t("default")],2)}
var itemvue_type_template_id_206a29d2_staticRenderFns = []


// CONCATENATED MODULE: ./packages/carousel/src/item.vue?vue&type=template&id=206a29d2&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/carousel/src/item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

const CARD_SCALE = 0.83;
/* harmony default export */ var itemvue_type_script_lang_js_ = ({
  name: 'ElCarouselItem',
  props: {
    name: {
      type: String,
      default: null
    },
    label: {
      type: [String, Number],
      default: ''
    }
  },
  data() {
    return {
      hover: false,
      translate: 0,
      scale: 1,
      active: false,
      ready: false,
      inStage: false,
      animating: false
    };
  },
  created() {
    this.$parent && this.$parent.updateItems();
  },
  destroyed() {
    this.$parent && this.$parent.updateItems();
  },
  methods: {
    processIndex(index, activeIndex, length) {
      if (activeIndex === 0 && index === length - 1) {
        return -1;
      } else if (activeIndex === length - 1 && index === 0) {
        return length;
      } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
        return length + 1;
      } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
        return -2;
      }
      return index;
    },
    calculateTranslate(index, activeIndex, parentWidth) {
      if (this.inStage) {
        return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
      } else if (index < activeIndex) {
        return -(1 + CARD_SCALE) * parentWidth / 4;
      } else {
        return (3 + CARD_SCALE) * parentWidth / 4;
      }
    },
    translateItem(index, activeIndex, oldIndex) {
      const parentWidth = this.$parent.$el.offsetWidth;
      const length = this.$parent.items.length;
      if (this.$parent.type !== 'card' && oldIndex !== undefined) {
        this.animating = index === activeIndex || index === oldIndex;
      }
      if (index !== activeIndex && length > 2) {
        index = this.processIndex(index, activeIndex, length);
      }
      if (this.$parent.type === 'card') {
        this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
        this.active = index === activeIndex;
        this.translate = this.calculateTranslate(index, activeIndex, parentWidth);
        this.scale = this.active ? 1 : CARD_SCALE;
      } else {
        this.active = index === activeIndex;
        this.translate = parentWidth * (index - activeIndex);
      }
      this.ready = true;
    },
    handleItemClick() {
      const parent = this.$parent;
      if (parent && parent.type === 'card') {
        const index = parent.items.indexOf(this);
        parent.setActiveItem(index);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/carousel/src/item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_itemvue_type_script_lang_js_ = (itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/carousel/src/item.vue





/* normalize component */

var item_component = normalizeComponent(
  src_itemvue_type_script_lang_js_,
  itemvue_type_template_id_206a29d2_render,
  itemvue_type_template_id_206a29d2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_item = (item_component.exports);
// CONCATENATED MODULE: ./packages/carousel-item/index.js


/* istanbul ignore next */
src_item.install = function (Vue) {
  Vue.component(src_item.name, src_item);
};
/* harmony default export */ var carousel_item = (src_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse.vue?vue&type=template&id=1a3dc2b3&
var collapsevue_type_template_id_1a3dc2b3_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-collapse"},[_vm._t("default")],2)}
var collapsevue_type_template_id_1a3dc2b3_staticRenderFns = []


// CONCATENATED MODULE: ./packages/collapse/src/collapse.vue?vue&type=template&id=1a3dc2b3&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse.vue?vue&type=script&lang=js&
//
//
//
//
//

/* harmony default export */ var collapsevue_type_script_lang_js_ = ({
  name: 'ElCollapse',
  componentName: 'ElCollapse',
  props: {
    accordion: {
      type: Boolean,
      default: null
    },
    value: {
      type: [Array, String, Number],
      default() {
        return [];
      }
    }
  },
  data() {
    return {
      activeNames: [].concat(this.value)
    };
  },
  watch: {
    value(value) {
      this.activeNames = [].concat(value);
    }
  },
  created() {
    this.$on('item-click', this.handleItemClick);
  },
  methods: {
    setActiveNames(activeNames) {
      activeNames = [].concat(activeNames);
      const value = this.accordion ? activeNames[0] : activeNames;
      this.activeNames = activeNames;
      this.$emit('input', value);
      this.$emit('change', value);
    },
    handleItemClick(item) {
      if (this.accordion) {
        this.setActiveNames((this.activeNames[0] || this.activeNames[0] === 0) && this.activeNames[0] === item.name ? '' : item.name);
      } else {
        const activeNames = this.activeNames.slice(0);
        const index = activeNames.indexOf(item.name);
        if (index > -1) {
          activeNames.splice(index, 1);
        } else {
          activeNames.push(item.name);
        }
        this.setActiveNames(activeNames);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/collapse/src/collapse.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_collapsevue_type_script_lang_js_ = (collapsevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/collapse/src/collapse.vue





/* normalize component */

var collapse_component = normalizeComponent(
  src_collapsevue_type_script_lang_js_,
  collapsevue_type_template_id_1a3dc2b3_render,
  collapsevue_type_template_id_1a3dc2b3_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var collapse = (collapse_component.exports);
// CONCATENATED MODULE: ./packages/collapse/index.js


/* istanbul ignore next */
collapse.install = function (Vue) {
  Vue.component(collapse.name, collapse);
};
/* harmony default export */ var packages_collapse = (collapse);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse-item.vue?vue&type=template&id=7c76866e&
var collapse_itemvue_type_template_id_7c76866e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-collapse-item",class:{ 'is-active': _vm.isActive }},[_c('div',{staticClass:"el-collapse-item__header",on:{"click":_vm.handleHeaderClick}},[(_vm.arrowPlacement !== 'right')?_c('i',{staticClass:"el-collapse-item__arrow h-icon-angle_right_sm",class:{
        'is-active': _vm.isActive
      }}):_vm._e(),_c('span',[_vm._t("title",function(){return [_vm._v(" "+_vm._s(_vm.title)+" ")]})],2),(_vm.arrowPlacement === 'right')?_c('i',{staticClass:"el-collapse-item__arrow h-icon-angle_right_sm on-right",class:{
        'is-active': _vm.isActive
      }}):_vm._e()]),_c('el-collapse-transition',[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"el-collapse-item__wrap"},[_c('div',{staticClass:"el-collapse-item__content"},[_vm._t("default")],2)])])],1)}
var collapse_itemvue_type_template_id_7c76866e_staticRenderFns = []


// CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue?vue&type=template&id=7c76866e&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/collapse/src/collapse-item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var collapse_itemvue_type_script_lang_js_ = ({
  name: 'ElCollapseItem',
  componentName: 'ElCollapseItem',
  components: {
    ElCollapseTransition: collapse_transition
  },
  mixins: [emitter],
  props: {
    title: {
      type: String,
      default: null
    },
    arrowPlacement: {
      type: String,
      default: 'left'
    },
    name: {
      type: [String, Number],
      default() {
        return this._uid;
      }
    }
  },
  data() {
    return {
      contentWrapStyle: {
        height: 'auto',
        display: 'block'
      },
      contentHeight: 0
    };
  },
  computed: {
    isActive() {
      return this.$parent.activeNames.indexOf(this.name) > -1;
    }
  },
  mounted() {},
  // watch: {
  //     isActive(value) {}
  // },

  methods: {
    handleHeaderClick() {
      this.dispatch('ElCollapse', 'item-click', this);
    }
  }
});
// CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_collapse_itemvue_type_script_lang_js_ = (collapse_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/collapse/src/collapse-item.vue





/* normalize component */

var collapse_item_component = normalizeComponent(
  src_collapse_itemvue_type_script_lang_js_,
  collapse_itemvue_type_template_id_7c76866e_render,
  collapse_itemvue_type_template_id_7c76866e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var collapse_item = (collapse_item_component.exports);
// CONCATENATED MODULE: ./packages/collapse-item/index.js


/* istanbul ignore next */
collapse_item.install = function (Vue) {
  Vue.component(collapse_item.name, collapse_item);
};
/* harmony default export */ var packages_collapse_item = (collapse_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader/src/main.vue?vue&type=template&id=138fbbe2&
var mainvue_type_template_id_138fbbe2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.handleClickoutside),expression:"handleClickoutside"}],ref:"reference",staticClass:"el-cascader",class:[
    {
      'is-opened': _vm.menuVisible,
      'is-disabled': _vm.disabled
    },
    _vm.size ? 'el-cascader--' + _vm.size : ''
  ],on:{"click":_vm.handleClick,"mouseenter":function($event){_vm.inputHover = true},"mouseleave":function($event){_vm.inputHover = false},"focus":function($event){_vm.inputHover = true},"blur":function($event){_vm.inputHover = false}}},[_c('el-input',{ref:"input",attrs:{"readonly":!_vm.filterable,"placeholder":_vm.currentLabels.length ? undefined : _vm.placeholder,"validate-event":false,"size":_vm.size,"disabled":_vm.disabled},on:{"change":_vm.debouncedInputChange,"focus":_vm.handleFocus,"blur":_vm.handleBlur},model:{value:(_vm.inputValue),callback:function ($$v) {_vm.inputValue=$$v},expression:"inputValue"}},[_c('template',{slot:"suffix"},[(_vm.clearable && _vm.inputHover && (_vm.currentLabels.length || _vm.inputValue))?_c('i',{key:"1",staticClass:"el-input__icon h-icon-close_f",on:{"click":_vm.clearValue}}):_c('i',{key:"2",staticClass:"el-input__icon h-icon-angle_down_sm"})])],2),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.inputValue === ''),expression:"inputValue === ''"}],staticClass:"el-cascader__label",attrs:{"title":_vm.currentValueTitle}},[(_vm.showAllLevels)?_vm._l((_vm.currentLabels),function(label,index){return _c('span',{key:index},[_vm._v(" "+_vm._s(label)+" "),(index < _vm.currentLabels.length - 1)?_c('span',{staticClass:"el-cascader__separator"},[_vm._v(" / ")]):_vm._e()])}):[_vm._v(" "+_vm._s(_vm.currentLabels[_vm.currentLabels.length - 1])+" ")]],2)],1)}
var mainvue_type_template_id_138fbbe2_staticRenderFns = []


// CONCATENATED MODULE: ./packages/cascader/src/main.vue?vue&type=template&id=138fbbe2&

// CONCATENATED MODULE: ./src/utils/shared.js
function isDef(val) {
  return val !== undefined && val !== null;
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader/src/menu.vue?vue&type=script&lang=js&



const copyArray = (arr, props) => {
  if (!arr || !Array.isArray(arr) || !props) return arr;
  const result = [];
  const configurableProps = ['__IS__FLAT__OPTIONS', 'label', 'value', 'disabled'];
  const childrenProp = props.children || 'children';
  arr.forEach(item => {
    const itemCopy = {};
    configurableProps.forEach(prop => {
      const propName = item.__IS__FLAT__OPTIONS ? prop : props[prop] || prop;
      const value = item[propName];
      if (value !== undefined) itemCopy[propName] = value;
    });
    if (Array.isArray(item[childrenProp])) {
      itemCopy[childrenProp] = copyArray(item[childrenProp], props);
    }
    result.push(itemCopy);
  });
  return result;
};
/* harmony default export */ var cascader_src_menuvue_type_script_lang_js_ = ({
  name: 'ElCascaderMenu',
  data() {
    return {
      inputWidth: 0,
      options: [],
      loading: false,
      props: {},
      visible: false,
      activeValue: [],
      value: [],
      check: Function,
      expandTrigger: 'click',
      changeOnSelect: false,
      popperClass: '',
      titleLabel: '',
      noMatch: '',
      filterable: false,
      loadingTitle: ''
    };
  },
  computed: {
    activeOptions: {
      cache: false,
      get() {
        const activeValue = this.activeValue;
        const configurableProps = ['label', 'value', 'children', 'disabled'];
        const formatOptions = options => {
          options.forEach(option => {
            if (option.__IS__FLAT__OPTIONS) return;
            configurableProps.forEach(prop => {
              const value = option[this.props[prop] || prop];
              if (value !== undefined) option[prop] = value;
            });
            if (Array.isArray(option.children)) {
              formatOptions(option.children);
            }
          });
        };
        const loadActiveOptions = (options, activeOptions = []) => {
          const level = activeOptions.length;
          activeOptions[level] = options;
          const active = activeValue[level];
          if (isDef(active)) {
            options = options.filter(option => option.value === active)[0];
            if (options && options.children) {
              loadActiveOptions(options.children, activeOptions);
            }
          }
          return activeOptions;
        };
        const optionsCopy = copyArray(this.options, this.props);
        formatOptions(optionsCopy);
        return loadActiveOptions(optionsCopy);
      }
    }
  },
  watch: {
    visible(value) {
      if (value) {
        this.activeValue = this.value;
      }
    },
    value: {
      immediate: true,
      handler(value) {
        this.activeValue = value;
      }
    }
  },
  methods: {
    select(item, menuIndex) {
      if (item.__IS__FLAT__OPTIONS) {
        this.activeValue = item.value;
      } else if (menuIndex) {
        this.activeValue.splice(menuIndex, this.activeValue.length - 1, item.value);
      } else {
        this.activeValue = [item.value];
      }
      this.$emit('pick', this.activeValue.slice(), item.children);
    },
    handleMenuLeave() {
      this.$emit('menuLeave');
    },
    activeItem(item, menuIndex) {
      const len = this.activeOptions.length;
      this.activeValue.splice(menuIndex, len, item.value);
      this.activeOptions.splice(menuIndex + 1, len, item.children);
      this.$emit('activeItemChange', this.activeValue, item);
    },
    scrollMenu(menu, index) {
      scrollIntoView(menu, menu.getElementsByClassName('is-active')[0], index > -1 ? this.$refs.scroll[index] : this.$refs.scroll);
    },
    handleMenuEnter() {
      this.$nextTick(() => this.$refs.menus.forEach((menu, index) => this.scrollMenu(menu, index)));
    },
    // 最终选中某列事件
    pitchOnItem(item, menuIndex) {
      if (this.check(item, menuIndex)) {
        this.select(item, menuIndex);
      }
      this.$nextTick(() => this.scrollMenu(this.$refs.menus[menuIndex], menuIndex));
    }
  },
  render() {
    const h = arguments[0];
    const {
      activeValue,
      activeOptions,
      visible,
      expandTrigger,
      popperClass,
      noMatch,
      filterable,
      loadingTitle,
      loading
    } = this;
    const menus = this._l(activeOptions, (menu, menuIndex) => {
      let isFlat = false;
      const items = this._l(menu, item => {
        const events = {
          on: {}
        };
        if (item.__IS__FLAT__OPTIONS) isFlat = true;
        if (!item.disabled) {
          if (item.children) {
            const triggerEvent = {
              click: 'click',
              hover: 'mouseenter'
            }[expandTrigger];
            // if (this.changeOnSelect) {
            //   events.on['mouseenter'] = () => {
            //     const len = this.activeOptions.length;
            //     this.activeValue.splice(menuIndex, len, item.value);
            //     this.activeOptions.splice(menuIndex + 1, len, item.children);
            //     this.$emit('activeItemChange', this.activeValue);
            //     // this.activeItem(item, menuIndex);
            //     this.$nextTick(() => {
            //     // adjust self and next level
            //       this.scrollMenu(this.$refs.menus[menuIndex]);
            //       this.scrollMenu(this.$refs.menus[menuIndex + 1]);
            //     });
            //   };
            // }

            events.on[triggerEvent] = () => {
              if (this.changeOnSelect && this.check(item, menuIndex)) {
                // hover + change-on-select 情况下，mouseenter 不调用select事件
                if (!(expandTrigger === 'hover' && this.changeOnSelect)) {
                  this.select(item, menuIndex);
                }
                // this.$nextTick(() => this.scrollMenu(this.$refs.menus[menuIndex]));
              }
              this.activeItem(item, menuIndex);
              if (triggerEvent === 'click') {
                this.$nextTick(() => {
                  // adjust self and next level
                  this.scrollMenu(this.$refs.menus[menuIndex], menuIndex);
                  this.scrollMenu(this.$refs.menus[menuIndex + 1], menuIndex + 1);
                });
              }
            };
          } else {
            events.on.click = () => {
              this.pitchOnItem(item, menuIndex);
            };
          }

          // hover + change-on-select 情况下，无论是否有子节点(所以不在前面item.children的判断中去加入以下逻辑)，click事件作为选中item的行为
          if (expandTrigger === 'hover' && this.changeOnSelect) {
            events.on.click = () => {
              this.pitchOnItem(item, menuIndex);
            };
          }
        }
        /*
         * 文字超出时显示title否则不显示，后续需要优化为toolTip显示
         * zhangxiaogang  2017-12-13
         */
        events.on.mouseover = e => {
          const t = e.target;
          if (t.tagName === 'LI') {
            if (t.scrollWidth > t.offsetWidth) {
              this.titleLabel = t.innerText;
            } else {
              this.titleLabel = '';
            }
          }
        };
        return h("li", babel_helper_vue_jsx_merge_props_default()([{
          "class": {
            'el-cascader-menu__item': true,
            'el-cascader-menu__item--extensible': item.children,
            'is-active': item.value === activeValue[menuIndex],
            'is-disabled': item.disabled
          }
        }, events, {
          "attrs": {
            "title": this.titleLabel
          }
        }]), [item.label, h("i", {
          "class": {
            'h-icon-angle_right_sm': item.children
          }
        })]);
      });
      const menuStyle = {};
      const noDataStyle = {};
      if (isFlat) {
        menuStyle.minWidth = this.inputWidth + 'px';
      }
      noDataStyle.width = this.inputWidth + 'px';
      noDataStyle.height = '94px';
      if (items.length > 0) {
        return h("ul", {
          "class": {
            'el-cascader-menu': true,
            'el-cascader-menu--flexible': isFlat
          },
          "style": menuStyle,
          "refInFor": true,
          "ref": 'menus'
        }, [h("el-scrollbar", {
          "refInFor": true,
          "ref": 'scroll',
          "attrs": {
            "wrap-class": 'el-cascader-scrollbar__wrap',
            "view-class": 'el-cascader-scrollbar__view',
            "isSmall": true
          }
        }, [items])]);
      } else if (loading) {
        return h("ul", {
          "class": {
            'el-cascader-menu': true,
            'el-cascader-menu--flexible': isFlat,
            'el-cascader-menu--noDate': true
          },
          "style": menuStyle,
          "refInFor": true,
          "ref": 'menus'
        }, [h("span", {
          "class": {
            'el-cascader-noDate': true
          }
        }, [loadingTitle])]);
      } else if (filterable & activeOptions[0].length === 0) {
        return h("ul", {
          "class": {
            'el-cascader-menu': true,
            'el-cascader-menu--flexible': isFlat,
            'el-cascader-menu--noDate': true
          },
          "style": noDataStyle,
          "refInFor": true,
          "ref": 'menus'
        }, [h("span", {
          "class": {
            'el-cascader-noDate': true
          }
        }, [noMatch])]);
      } else {
        return h("ul", {
          "class": {
            'el-cascader-menu': true,
            'el-cascader-menu--flexible': isFlat,
            'el-cascader-menu--noDateFirst': true,
            'el-cascader-menu--noDate': true
          },
          "style": menuStyle,
          "refInFor": true,
          "ref": 'menus'
        }, [h("span", {
          "class": {
            'el-cascader-noDate': true
          }
        }, [noMatch])]);
      }
    });
    const {
      header,
      footer
    } = this.$scopedSlots;
    return h("transition", {
      "attrs": {
        "name": 'el-zoom-in-top'
      },
      "on": {
        "before-enter": this.handleMenuEnter,
        "after-leave": this.handleMenuLeave
      }
    }, [h("div", {
      "directives": [{
        name: "show",
        value: visible
      }],
      "class": ['el-cascader-menus', popperClass],
      "ref": 'wrapper'
    }, [header ? header(this) : '', menus, footer ? footer(this) : ''])]);
  }
});
// CONCATENATED MODULE: ./packages/cascader/src/menu.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_cascader_src_menuvue_type_script_lang_js_ = (cascader_src_menuvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/cascader/src/menu.vue
var menu_render, menu_staticRenderFns




/* normalize component */

var src_menu_component = normalizeComponent(
  packages_cascader_src_menuvue_type_script_lang_js_,
  menu_render,
  menu_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var cascader_src_menu = (src_menu_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/cascader/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










// import ElScrollbar from 'hui/packages/scrollbar';

const popperMixin = {
  props: {
    placement: {
      type: String,
      default: 'bottom-start'
    },
    appendToBody: vue_popper.props.appendToBody,
    offset: vue_popper.props.offset,
    boundariesPadding: vue_popper.props.boundariesPadding,
    popperOptions: vue_popper.props.popperOptions
  },
  methods: vue_popper.methods,
  data: vue_popper.data,
  beforeDestroy: vue_popper.beforeDestroy
};
/* harmony default export */ var cascader_src_mainvue_type_script_lang_js_ = ({
  name: 'ElCascader',
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    ElInput: packages_input
    // ElScrollbar
  },
  mixins: [popperMixin, emitter, locale],
  props: {
    options: {
      type: Array,
      required: true
    },
    props: {
      type: Object,
      default() {
        return {
          children: 'children',
          label: 'label',
          value: 'value',
          disabled: 'disabled'
        };
      }
    },
    value: {
      type: Array,
      default() {
        return [];
      }
    },
    placeholder: {
      type: String,
      default() {
        return Object(locale_["t"])('el.cascader.placeholder');
      }
    },
    disabled: {
      type: Boolean,
      default: null
    },
    clearable: {
      type: Boolean,
      default: false
    },
    changeOnSelect: {
      type: Boolean,
      default: null
    },
    popperClass: {
      type: String,
      default: null
    },
    noMatch: {
      type: String,
      default() {
        return Object(locale_["t"])('el.cascader.noMatch');
      }
    },
    loading: {
      type: Boolean,
      default: false
    },
    check: {
      type: Function,
      default: () => {
        return true;
      }
    },
    expandTrigger: {
      type: String,
      default: 'click'
    },
    filterable: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: () => () => {}
    }
  },
  data() {
    return {
      currentValue: this.value || [],
      // currentValueTitle: '',
      menu: null,
      debouncedInputChange() {},
      menuVisible: false,
      inputHover: false,
      inputValue: '',
      flatOptions: null
    };
  },
  computed: {
    labelKey() {
      return this.props.label || 'label';
    },
    valueKey() {
      return this.props.value || 'value';
    },
    childrenKey() {
      return this.props.children || 'children';
    },
    currentLabels() {
      let options = this.options;
      const labels = [];
      this.currentValue.forEach(value => {
        const targetOption = options && options.filter(option => option[this.valueKey] === value)[0];
        if (targetOption) {
          labels.push(targetOption[this.labelKey]);
          options = targetOption[this.childrenKey];
        }
      });
      return labels;
    },
    currentValueTitle() {
      return this.currentLabels.join('/');
    }
  },
  watch: {
    menuVisible(value) {
      value ? this.showMenu() : this.hideMenu();
    },
    value(value) {
      this.currentValue = value;
    },
    currentValue(value) {
      this.dispatch('ElFormItem', 'el.form.change', [value]);
    },
    options: {
      deep: true,
      handler(value) {
        if (!this.menu) {
          this.initMenu();
        }
        this.flatOptions = this.flattenOptions(this.options);
        this.menu.options = value;
      }
    },
    loading: {
      deep: true,
      handler(value) {
        if (!this.menu) {
          this.initMenu();
        }
        this.menu.loading = value;
      }
    }
  },
  created() {
    this.debouncedInputChange = debounce_default()(this.debounce, value => {
      const before = this.beforeFilter(value);
      if (before && before.then) {
        this.menu.options = [{
          __IS__FLAT__OPTIONS: true,
          label: this.t('el.cascader.loading'),
          value: '',
          disabled: true
        }];
        before.then(() => {
          this.$nextTick(() => {
            this.handleInputChange(value);
          });
        });
      } else if (before !== false) {
        this.$nextTick(() => {
          this.handleInputChange(value);
        });
      }
    });
  },
  mounted() {
    this.flatOptions = this.flattenOptions(this.options);
  },
  methods: {
    initMenu() {
      this.menu = new external_vue_default.a(cascader_src_menu).$mount();
      this.menu.$scopedSlots = this.$scopedSlots;
      this.menu.options = this.options;
      this.menu.loading = this.loading;
      this.menu.filterable = this.filterable;
      this.menu.inputValue = this.inputValue;
      this.menu.props = this.props;
      this.menu.expandTrigger = this.expandTrigger;
      this.menu.noMatch = this.noMatch;
      this.menu.loadingTitle = this.t('el.cascader.loading');
      this.menu.check = this.check;
      this.menu.changeOnSelect = this.changeOnSelect;
      this.menu.popperClass = this.popperClass;
      this.popperElm = this.menu.$el;
      this.menu.$on('pick', this.handlePick);
      this.menu.$on('activeItemChange', this.handleActiveItemChange);
      this.menu.$on('menuLeave', this.doDestroy);
    },
    showMenu() {
      if (!this.menu) {
        this.initMenu();
      }
      this.menu.value = this.currentValue.slice(0);
      this.menu.visible = true;
      this.menu.options = this.options;
      this.$nextTick(() => {
        this.updatePopper();
        this.menu.inputWidth = this.$refs.input.$el.offsetWidth - 2;
      });
    },
    hideMenu() {
      this.inputValue = '';
      this.menu.visible = false;
    },
    handleActiveItemChange(value, item) {
      this.$nextTick(() => {
        this.updatePopper();
      });
      this.$emit('active-item-change', value, item);
    },
    handlePick(value, children, close = true) {
      this.currentValue = value;
      this.$emit('input', value);
      this.$emit('change', value);
      // hover + change-on-select 情况下，click点击选中后也主动隐藏菜单
      if (close && !(this.changeOnSelect && children) || this.expandTrigger === 'hover' && this.changeOnSelect) {
        this.menuVisible = false;
      } else {
        this.$nextTick(this.updatePopper);
      }
    },
    handleFocus(event) {
      this.$emit('focus', event);
    },
    handleBlur(event) {
      this.$emit('blur', event);
    },
    handleInputChange(value) {
      if (!this.menuVisible) return;
      const flatOptions = this.flatOptions;

      // 搜索内容包含特殊的则屏蔽
      const regStr = String(value).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
      if (!value || !regStr) {
        this.menu.options = this.options;
        this.$nextTick(this.updatePopper);
        return;
      }
      let filteredFlatOptions = flatOptions.filter(optionsStack => {
        return optionsStack.some(option => !option.disabled && new RegExp(regStr, 'i').test(option[this.labelKey]));
      });
      if (filteredFlatOptions.length > 0) {
        filteredFlatOptions = filteredFlatOptions.map(optionStack => {
          return {
            __IS__FLAT__OPTIONS: true,
            value: optionStack.map(item => item[this.valueKey]),
            label: this.renderFilteredOptionLabel(value, optionStack)
          };
        });
      } else {
        filteredFlatOptions = [];
      }
      this.menu.options = filteredFlatOptions;
      this.$nextTick(this.updatePopper);
    },
    renderFilteredOptionLabel(inputValue, optionsStack) {
      return optionsStack.map((option, index) => {
        const label = option[this.labelKey];
        const keywordIndex = label.toLowerCase().indexOf(inputValue.toLowerCase());
        const labelPart = label.slice(keywordIndex, inputValue.length + keywordIndex);
        const node = keywordIndex > -1 ? this.highlightKeyword(label, labelPart) : label;
        return index === 0 ? node : ['/', node];
      });
    },
    highlightKeyword(label, keyword) {
      const h = this._c;
      return label.split(keyword).map((node, index) => index === 0 ? node : [h('span', {
        class: {
          'el-cascader-menu__item__keyword': true
        }
      }, [this._v(keyword)]), node]);
    },
    flattenOptions(options, ancestor = []) {
      let flatOptions = [];
      options.forEach(option => {
        const optionsStack = ancestor.concat(option);
        if (!option[this.childrenKey]) {
          flatOptions.push(optionsStack);
        } else {
          if (this.changeOnSelect) {
            flatOptions.push(optionsStack);
          }
          flatOptions = flatOptions.concat(this.flattenOptions(option[this.childrenKey], optionsStack));
        }
      });
      return flatOptions;
    },
    clearValue(ev) {
      ev.stopPropagation();
      this.inputValue = '';
      this.handlePick([], true);
    },
    handleClickoutside() {
      this.menuVisible = false;
    },
    handleClick() {
      if (this.disabled) return;
      if (this.filterable) {
        this.menuVisible = true;
        this.$refs.input.$refs.input.focus();
        return;
      }
      this.menuVisible = !this.menuVisible;
    }
  }
});
// CONCATENATED MODULE: ./packages/cascader/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_cascader_src_mainvue_type_script_lang_js_ = (cascader_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/cascader/src/main.vue





/* normalize component */

var cascader_src_main_component = normalizeComponent(
  packages_cascader_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_138fbbe2_render,
  mainvue_type_template_id_138fbbe2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var cascader_src_main = (cascader_src_main_component.exports);
// CONCATENATED MODULE: ./packages/cascader/index.js


/* istanbul ignore next */
cascader_src_main.install = function (Vue) {
  Vue.component(cascader_src_main.name, cascader_src_main);
};
/* harmony default export */ var cascader = (cascader_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/main.vue?vue&type=template&id=33b06286&
var mainvue_type_template_id_33b06286_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"clickoutside",rawName:"v-clickoutside",value:(_vm.hide),expression:"hide"}],staticClass:"h-color-picker"},[_c('el-input',{ref:"inputColor",staticClass:"h-color-picker__input",class:{ 'is-disabled': _vm.disabled },style:(_vm.innerStyle),attrs:{"placeholder":_vm.inputPlaceholder,"readonly":true},nativeOn:{"click":function($event){return _vm.switchShow.apply(null, arguments)}},model:{value:(_vm.inputValue),callback:function ($$v) {_vm.inputValue=$$v},expression:"inputValue"}}),_c('picker-dropdown',{ref:"dropdown",staticClass:"h-color-picker__panel",class:{ 'is-Simple': _vm.isSimple },attrs:{"input-width":_vm.inputWidth,"current-color":_vm.value,"placement":_vm.placement,"color-list":_vm.colorList,"is-simple":_vm.isSimple,"color":_vm.color,"show-alpha":_vm.showAlpha},on:{"selectSimpleColor":_vm.selectColor,"selectColor":_vm.selectColor,"pick":_vm.confirmValue},model:{value:(_vm.showPicker),callback:function ($$v) {_vm.showPicker=$$v},expression:"showPicker"}})],1)}
var mainvue_type_template_id_33b06286_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/main.vue?vue&type=template&id=33b06286&

// CONCATENATED MODULE: ./packages/color-picker/src/color.js

const hsv2hsl = function (hue, sat, val) {
  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
};

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
const isOnePointZero = function (n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
};
const isPercentage = function (n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
};

// Take input from [0, n] and return it as [0, 1]
const bound01 = function (value, max) {
  if (isOnePointZero(value)) value = '100%';
  const processPercent = isPercentage(value);
  value = Math.min(max, Math.max(0, parseFloat(value)));

  // Automatically convert percentage into number
  if (processPercent) {
    value = parseInt(value * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(value - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return value % max / parseFloat(max);
};
const INT_HEX_MAP = {
  10: 'A',
  11: 'B',
  12: 'C',
  13: 'D',
  14: 'E',
  15: 'F'
};
const toHex = function ({
  r,
  g,
  b
}) {
  const hexOne = function (value) {
    value = Math.min(Math.round(value), 255);
    const high = Math.floor(value / 16);
    const low = value % 16;
    return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
  };
  if (isNaN(r) || isNaN(g) || isNaN(b)) return '';
  return '#' + hexOne(r) + hexOne(g) + hexOne(b);
};
const HEX_INT_MAP = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
const parseHexChannel = function (hex) {
  if (hex.length === 2) {
    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
  }
  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};
const hsl2hsv = function (hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  let smin = sat;
  const lmin = Math.max(light, 0.01);
  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (light + sat) / 2;
  const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v * 100
  };
};

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
const rgb2hsv = function (r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h;
  const v = max;
  const d = max - min;
  const s = max === 0 ? 0 : d / max;
  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h * 360,
    s: s * 100,
    v: v * 100
  };
};

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
const hsv2rgb = function (h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
};
class color_Color {
  constructor(options) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = 'hex';
    this.value = '';
    options = options || {};
    for (const option in options) {
      if (hasOwn(options, option)) {
        this[option] = options[option];
      }
    }
    this.doOnChange();
  }
  set(prop, value) {
    if (arguments.length === 1 && typeof prop === 'object') {
      for (const p in prop) {
        if (hasOwn(prop, p)) {
          this.set(p, prop[p]);
        }
      }
      return;
    }
    this['_' + prop] = value;
    this.doOnChange();
  }
  get(prop) {
    return this['_' + prop];
  }
  toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  }
  toHsl() {
    return hsv2hsl(this._hue, this._saturation / 100, this._value / 100);
  }
  toHsla() {
    const hsl = hsv2hsl(this._hue, this._saturation / 100, this._value / 100);
    return {
      h: Number(this._hue).toFixed(0),
      s: Math.round(hsl[1] * 100) + '%',
      l: Math.round(hsl[2] * 100) + '%',
      a: this._alpha / 100
    };
  }
  toHex() {
    return toHex(hsv2rgb(this._hue, this._saturation, this._value));
  }
  rgbToHex() {
    // rgba 转 hex 会放弃 alpha 通道
    const matches = this.value.match(/^rgba\((\d+), ?(\d+), ?(\d+), ?([.0-9]+)\)$/);
    const list = matches.map(v => parseInt(v, 10)).slice(1);
    // list [169, 71, 71, 1]
    return toHex({
      r: list[0],
      g: list[1],
      b: list[2]
    });
  }
  fromString(value) {
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    const fromHSV = (h, s, v) => {
      this._hue = h;
      this._saturation = s;
      this._value = v;
      this.doOnChange();
    };
    if (value.indexOf('hsl') !== -1) {
      const parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        const {
          h,
          s,
          v
        } = hsl2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      const parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      const parts = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        const {
          h,
          s,
          v
        } = rgb2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('#') !== -1) {
      const hex = value.replace('#', '').trim();
      let r, g, b;
      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4));
      }
      const {
        h,
        s,
        v
      } = rgb2hsv(r, g, b);
      fromHSV(h, s, v);
    }
  }
  doOnChange() {
    const {
      _hue,
      _saturation,
      _value,
      _alpha,
      format
    } = this;
    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          {
            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
            this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${_alpha / 100})`;
            break;
          }
        case 'hsv':
          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${_alpha / 100})`;
          break;
        default:
          {
            const {
              r,
              g,
              b
            } = hsv2rgb(_hue, _saturation, _value);
            this.value = `rgba(${r}, ${g}, ${b}, ${_alpha / 100})`;
          }
      }
    } else {
      switch (format) {
        case 'hsl':
          {
            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
            this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
            break;
          }
        case 'hsv':
          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
          break;
        case 'rgb':
          {
            const {
              r,
              g,
              b
            } = hsv2rgb(_hue, _saturation, _value);
            this.value = `rgb(${r}, ${g}, ${b})`;
            break;
          }
        default:
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
      }
    }
  }
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/picker-dropdown.vue?vue&type=template&id=7ca48617&
var picker_dropdownvue_type_template_id_7ca48617_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"el-zoom-in-top"},on:{"after-leave":_vm.doDestroy}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPopper),expression:"showPopper"}],staticClass:"h-color-dropdown"},[(!_vm.isSimple)?_c('div',{staticClass:"h-color-dropdown__complex-main-wrapper",class:{ 'is-showAlpha': _vm.showAlpha },attrs:{"show-alpha":_vm.showAlpha}},[_c('sv-panel',{ref:"sl",attrs:{"color":_vm.color,"show-alpha":_vm.showAlpha},on:{"clearEditColor":_vm.clearEditColor}}),_c('hue-slider',{ref:"hue",attrs:{"color":_vm.color,"vertical":"","show-alpha":_vm.showAlpha},on:{"clearEditColor":_vm.clearEditColor}}),(_vm.showAlpha)?_c('alpha-slider',{ref:"alpha",attrs:{"vertical":"","color":_vm.color,"show-alpha":_vm.showAlpha},on:{"clearEditColor":_vm.clearEditColor}}):_vm._e(),_c('color-details',{ref:"details",attrs:{"color":_vm.color,"show-alpha":_vm.showAlpha,"vertical":"","current-color":_vm.currentColor},on:{"selectColor":_vm.selectColor}})],1):_c('div',{staticClass:"h-color-dropdown__simple-main-wrapper",style:({ minWidth: _vm.inputWidth, maxWidth: _vm.inputWidth })},[_c('simple-panel',{attrs:{"color-list":_vm.colorList,"color":_vm.color},on:{"selectSimpleColor":_vm.selectSimpleColor}})],1)])])}
var picker_dropdownvue_type_template_id_7ca48617_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue?vue&type=template&id=7ca48617&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/sv-panel.vue?vue&type=template&id=07d81169&
var sv_panelvue_type_template_id_07d81169_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-color-svpanel",class:{ 'is-showAlpha': _vm.showAlpha },style:({
    backgroundColor: _vm.background
  })},[_c('div',{staticClass:"h-color-svpanel__white"}),_c('div',{staticClass:"h-color-svpanel__black"}),_c('div',{staticClass:"h-color-svpanel__cursor",style:({
      top: _vm.cursorTop + 'px',
      left: _vm.cursorLeft + 'px'
    })},[_c('div')])])}
var sv_panelvue_type_template_id_07d81169_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue?vue&type=template&id=07d81169&

// CONCATENATED MODULE: ./packages/color-picker/src/draggable.js

let isDragging = false;
/* harmony default export */ var draggable = (function (element, options) {
  if (external_vue_default.a.prototype.$isServer) return;
  const moveFn = function (event) {
    if (options.drag) {
      options.drag(event);
    }
  };
  const upFn = function (event) {
    document.removeEventListener('mousemove', moveFn);
    document.removeEventListener('mouseup', upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    if (options.end) {
      options.end(event);
    }
  };
  element.addEventListener('mousedown', function (event) {
    if (isDragging) return;
    document.onselectstart = function () {
      return false;
    };
    document.ondragstart = function () {
      return false;
    };
    document.addEventListener('mousemove', moveFn);
    document.addEventListener('mouseup', upFn);
    isDragging = true;
    if (options.start) {
      options.start(event);
    }
  });
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/sv-panel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var sv_panelvue_type_script_lang_js_ = ({
  name: 'ElSlPanel',
  props: {
    color: {
      type: null,
      default: null,
      required: true
    },
    showAlpha: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      cursorTop: 0,
      cursorLeft: 0,
      background: 'hsl(0, 100%, 50%)'
    };
  },
  computed: {
    colorValue() {
      const hue = this.color.get('hue');
      const value = this.color.get('value');
      return {
        hue,
        value
      };
    }
  },
  watch: {
    colorValue() {
      this.update();
    }
  },
  mounted() {
    draggable(this.$el, {
      drag: event => {
        this.handleDrag(event);
      },
      end: event => {
        this.handleDrag(event);
      }
    });
    this.update();
  },
  methods: {
    update() {
      const saturation = this.color.get('saturation');
      const value = this.color.get('value');
      const el = this.$el;
      const {
        width
      } = el.getBoundingClientRect();
      let {
        height
      } = el.getBoundingClientRect();
      if (!height) height = width * 3 / 4;
      this.cursorLeft = saturation * width / 100;
      this.cursorTop = (100 - value) * height / 100;
      this.background = 'hsl(' + this.color.get('hue') + ', 100%, 50%)';
    },
    handleDrag(event) {
      const el = this.$el;
      const rect = el.getBoundingClientRect();
      let left = event.clientX - rect.left;
      let top = event.clientY - rect.top;
      left = Math.max(0, left);
      left = Math.min(left, rect.width);
      top = Math.max(0, top);
      top = Math.min(top, rect.height);
      this.cursorLeft = left;
      this.cursorTop = top;
      this.color.set({
        saturation: left / rect.width * 100,
        value: 100 - top / rect.height * 100
      });
      this.$emit('clearEditColor');
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_sv_panelvue_type_script_lang_js_ = (sv_panelvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/sv-panel.vue





/* normalize component */

var sv_panel_component = normalizeComponent(
  components_sv_panelvue_type_script_lang_js_,
  sv_panelvue_type_template_id_07d81169_render,
  sv_panelvue_type_template_id_07d81169_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var sv_panel = (sv_panel_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/hue-slider.vue?vue&type=template&id=6be7a112&
var hue_slidervue_type_template_id_6be7a112_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-color-hue-slider",class:{ 'is-vertical': _vm.vertical, 'is-showAlpha': _vm.showAlpha }},[_c('div',{ref:"bar",staticClass:"h-color-hue-slider__bar",on:{"click":_vm.handleClick}}),_c('div',{ref:"thumb",staticClass:"h-color-hue-slider__thumb",style:({
      left: _vm.thumbLeft + 'px',
      top: _vm.thumbTop + 'px'
    })})])}
var hue_slidervue_type_template_id_6be7a112_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue?vue&type=template&id=6be7a112&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/hue-slider.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var hue_slidervue_type_script_lang_js_ = ({
  name: 'ElColorHueSlider',
  props: {
    color: {
      type: null,
      default: null,
      required: true
    },
    vertical: {
      type: Boolean,
      default: null
    },
    showAlpha: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      thumbLeft: 0,
      thumbTop: 0
    };
  },
  computed: {
    hueValue() {
      const hue = this.color.get('hue');
      return hue;
    }
  },
  watch: {
    hueValue() {
      this.update();
    }
  },
  mounted() {
    const {
      bar,
      thumb
    } = this.$refs;
    const dragConfig = {
      drag: event => {
        this.handleDrag(event);
      },
      end: event => {
        this.handleDrag(event);
      }
    };
    draggable(bar, dragConfig);
    draggable(thumb, dragConfig);
    this.update();
  },
  methods: {
    handleClick(event) {
      const thumb = this.$refs.thumb;
      const target = event.target;
      if (target !== thumb) {
        this.handleDrag(event);
      }
    },
    handleDrag(event) {
      const rect = this.$el.getBoundingClientRect();
      const {
        thumb
      } = this.$refs;
      let hue;
      if (!this.vertical) {
        let left = event.clientX - rect.left;
        left = Math.min(left, rect.width - thumb.offsetWidth / 2);
        left = Math.max(thumb.offsetWidth / 2, left);
        hue = Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 360);
      } else {
        let top = event.clientY - rect.top;
        top = Math.min(top, rect.height - thumb.offsetHeight / 2);
        top = Math.max(thumb.offsetHeight / 2, top);
        hue = Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 360);
      }
      this.color.set('hue', hue);
      this.$emit('clearEditColor');
    },
    getThumbLeft() {
      if (this.vertical) return 0;
      const el = this.$el;
      const hue = this.color.get('hue');
      if (!el) return 0;
      const thumb = this.$refs.thumb;
      return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
    },
    getThumbTop() {
      if (!this.vertical) return 0;
      const el = this.$el;
      const hue = this.color.get('hue');
      if (!el) return 0;
      const thumb = this.$refs.thumb;
      return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
    },
    update() {
      this.thumbLeft = this.getThumbLeft();
      this.thumbTop = this.getThumbTop();
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_hue_slidervue_type_script_lang_js_ = (hue_slidervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/hue-slider.vue





/* normalize component */

var hue_slider_component = normalizeComponent(
  components_hue_slidervue_type_script_lang_js_,
  hue_slidervue_type_template_id_6be7a112_render,
  hue_slidervue_type_template_id_6be7a112_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var hue_slider = (hue_slider_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/simple-panel.vue?vue&type=template&id=5fccd522&
var simple_panelvue_type_template_id_5fccd522_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-color-simple-panel",style:({ minWidth: _vm.minWidth, maxWidth: _vm.maxWidth })},[_c('el-scrollbar',{attrs:{"wrap-class":"h-colorPicker-scrollbar-wrap"}},[_c('div',{staticClass:"h-color-simple-panel-wrapper"},_vm._l((_vm.colorList),function(itemColor,index){return _c('div',{key:index,staticClass:"h-color-simple-panel-item",style:({
          background: itemColor,
          border:
            itemColor === _vm.color.value.toLowerCase() ? '2px solid black' : ''
        }),on:{"click":function($event){return _vm.selectSimpleColor(itemColor)}}})}),0)])],1)}
var simple_panelvue_type_template_id_5fccd522_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/simple-panel.vue?vue&type=template&id=5fccd522&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/simple-panel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var simple_panelvue_type_script_lang_js_ = ({
  nameL: 'ElColorSimplePanel',
  components: {
    ElScrollbar: scrollbar
  },
  props: {
    colorList: {
      type: Array,
      default: null
    },
    color: {
      type: null,
      default: null,
      required: true
    }
  },
  data() {
    return {
      minWidth: '',
      maxWidth: ''
    };
  },
  methods: {
    selectSimpleColor(color) {
      this.color.fromString(color);
      this.$emit('selectSimpleColor', color);
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/simple-panel.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_simple_panelvue_type_script_lang_js_ = (simple_panelvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/simple-panel.vue





/* normalize component */

var simple_panel_component = normalizeComponent(
  components_simple_panelvue_type_script_lang_js_,
  simple_panelvue_type_template_id_5fccd522_render,
  simple_panelvue_type_template_id_5fccd522_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var simple_panel = (simple_panel_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/alpha-slider.vue?vue&type=template&id=9dd2418c&
var alpha_slidervue_type_template_id_9dd2418c_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-color-alpha-slider",class:{ 'is-vertical': _vm.vertical, 'is-showAlpha': _vm.showAlpha }},[_c('div',{ref:"bar",staticClass:"h-color-alpha-slider__bar",style:({
      background: _vm.background
    }),on:{"click":_vm.handleClick}}),_c('div',{ref:"thumb",staticClass:"h-color-alpha-slider__thumb",style:({
      left: _vm.thumbLeft + 'px',
      top: _vm.thumbTop + 'px'
    })})])}
var alpha_slidervue_type_template_id_9dd2418c_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue?vue&type=template&id=9dd2418c&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/alpha-slider.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var alpha_slidervue_type_script_lang_js_ = ({
  name: 'ElColorAlphaSlider',
  props: {
    color: {
      type: null,
      default: null,
      required: true
    },
    vertical: {
      type: Boolean,
      default: null
    },
    showAlpha: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      thumbLeft: 0,
      thumbTop: 0,
      background: null
    };
  },
  watch: {
    'color._alpha'() {
      this.update();
    },
    'color.value'() {
      this.update();
    }
  },
  mounted() {
    const {
      bar,
      thumb
    } = this.$refs;
    const dragConfig = {
      drag: event => {
        this.handleDrag(event);
      },
      end: event => {
        this.handleDrag(event);
      }
    };
    draggable(bar, dragConfig);
    draggable(thumb, dragConfig);
    this.update();
  },
  methods: {
    handleClick(event) {
      const thumb = this.$refs.thumb;
      const target = event.target;
      if (target !== thumb) {
        this.handleDrag(event);
      }
    },
    handleDrag(event) {
      const rect = this.$el.getBoundingClientRect();
      const {
        thumb
      } = this.$refs;
      let top = event.clientY - rect.top;
      top = Math.max(thumb.offsetHeight / 2, top);
      top = Math.min(top, rect.height - thumb.offsetHeight / 2);
      this.color.set('alpha', Math.round((278 - (top + thumb.offsetHeight / 2)) / (rect.height - thumb.offsetHeight) * 100));
      this.$emit('clearEditColor');
    },
    getThumbLeft() {
      if (this.vertical) return 0;
      const el = this.$el;
      const alpha = this.color._alpha;
      if (!el) return 0;
      const thumb = this.$refs.thumb;
      return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
    },
    getThumbTop() {
      if (!this.vertical) return 0;
      const el = this.$el;
      const alpha = this.color._alpha;
      if (!el) return 0;
      return Math.round(el.offsetHeight - alpha * el.offsetHeight / 100);
    },
    getBackground() {
      if (this.color && this.color.value) {
        const {
          r,
          g,
          b
        } = this.color.toRgb();
        return `linear-gradient(to top, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
      }
      return null;
    },
    update() {
      this.thumbTop = this.getThumbTop();
      this.background = this.getBackground();
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_alpha_slidervue_type_script_lang_js_ = (alpha_slidervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/alpha-slider.vue





/* normalize component */

var alpha_slider_component = normalizeComponent(
  components_alpha_slidervue_type_script_lang_js_,
  alpha_slidervue_type_template_id_9dd2418c_render,
  alpha_slidervue_type_template_id_9dd2418c_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var alpha_slider = (alpha_slider_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/color-details.vue?vue&type=template&id=e5ed9e0a&
var color_detailsvue_type_template_id_e5ed9e0a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-color-details"},[_c('div',{staticClass:"h-color-details-contrast"},[_vm._v(" "+_vm._s(_vm.t('el.colorpicker.new_name'))+" "),_c('div',[_c('div',{staticClass:"h-color-details-contrast-color h-color-details-contrast__newColor",style:({ background: _vm.newColor })}),_c('div',{staticClass:"h-color-details-contrast-color h-color-details-contrast__currentColor",style:({ background: _vm.currentColor })})]),_vm._v(" "+_vm._s(_vm.t('el.colorpicker.current_name'))+" ")]),_c('div',{staticClass:"h-color-details-numerical"},[_c('div',{staticClass:"h-color-details-numerical-rgb-hsb-group"},[_c('div',{staticClass:"h-color-details-numerical-rgb"},[_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":3},on:{"blur":_vm.inputRgb},model:{value:(_vm.rgbColor.r),callback:function ($$v) {_vm.$set(_vm.rgbColor, "r", $$v)},expression:"rgbColor.r"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("R")])])],2)],1),_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":3},on:{"blur":_vm.inputRgb},model:{value:(_vm.rgbColor.g),callback:function ($$v) {_vm.$set(_vm.rgbColor, "g", $$v)},expression:"rgbColor.g"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("G")])])],2)],1),_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":3},on:{"blur":_vm.inputRgb},model:{value:(_vm.rgbColor.b),callback:function ($$v) {_vm.$set(_vm.rgbColor, "b", $$v)},expression:"rgbColor.b"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("B")])])],2)],1),(_vm.showAlpha)?_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":4},on:{"focus":_vm.inputRgb,"blur":_vm.inputRgb},model:{value:(_vm.rgbColor.a),callback:function ($$v) {_vm.$set(_vm.rgbColor, "a", $$v)},expression:"rgbColor.a"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("A")])])],2)],1):_vm._e()]),_c('div',{staticClass:"h-color-details-numerical-hsb"},[_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":3},on:{"blur":_vm.inputHsl},model:{value:(_vm.hslColor.h),callback:function ($$v) {_vm.$set(_vm.hslColor, "h", $$v)},expression:"hslColor.h"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("H")])])],2)],1),_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":4},on:{"blur":_vm.inputHsl},model:{value:(_vm.hslColor.s),callback:function ($$v) {_vm.$set(_vm.hslColor, "s", $$v)},expression:"hslColor.s"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("S")])])],2)],1),_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":4},on:{"blur":_vm.inputHsl},model:{value:(_vm.hslColor.l),callback:function ($$v) {_vm.$set(_vm.hslColor, "l", $$v)},expression:"hslColor.l"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("L")])])],2)],1),(_vm.showAlpha)?_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":4},on:{"focus":_vm.inputHsl,"blur":_vm.inputHsl},model:{value:(_vm.hslColor.a),callback:function ($$v) {_vm.$set(_vm.hslColor, "a", $$v)},expression:"hslColor.a"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("A")])])],2)],1):_vm._e()])]),_c('div',{staticClass:"h-color-details-numerical-hex"},[_c('div',{staticClass:"h-color-details-numerical__input"},[_c('el-input',{attrs:{"size":"mini","maxlength":6},on:{"focus":_vm.inputHex,"blur":_vm.inputHex},model:{value:(_vm.hexColor),callback:function ($$v) {_vm.hexColor=$$v},expression:"hexColor"}},[_c('template',{slot:"prepend"},[_c('span',{},[_vm._v("#")])])],2)],1)])]),_c('div',{staticClass:"h-color-details-button"},[_c('el-button',{attrs:{"type":"primary"},on:{"click":_vm.confirmValue}},[_vm._v(" "+_vm._s(_vm.t('el.colorpicker.confirm'))+" ")])],1)])}
var color_detailsvue_type_template_id_e5ed9e0a_staticRenderFns = []


// CONCATENATED MODULE: ./packages/color-picker/src/components/color-details.vue?vue&type=template&id=e5ed9e0a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/color-details.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var color_detailsvue_type_script_lang_js_ = ({
  name: 'ElColorDetails',
  components: {
    ElInput: packages_input,
    ElButton: packages_button
  },
  mixins: [locale],
  props: {
    color: {
      type: null,
      default: null,
      required: true
    },
    currentColor: {
      type: String,
      default: ''
    },
    showAlpha: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      hexColor: '',
      // 进制颜色
      rgbColor: {
        r: '',
        g: '',
        b: '',
        a: 1
      },
      hslColor: {
        h: '',
        s: '',
        l: '',
        a: 1
      },
      newColor: '',
      editColor: ''
    };
  },
  computed: {
    cacheHslColor() {
      return JSON.parse(JSON.stringify(this.hslColor));
    },
    cacheRgbColor() {
      return JSON.parse(JSON.stringify(this.rgbColor));
    }
  },
  watch: {
    color: {
      deep: true,
      immediate: true,
      handler(val) {
        this.hexColor = this.showAlpha ? this.color.rgbToHex().split('#')[1] : this.color.value.split('#')[1];
        this.newColor = this.showAlpha ? this.color.rgbToHex() : this.color.value;
        if (this.showAlpha) {
          const matches = this.color.value.match(/^rgba\((\d+), ?(\d+), ?(\d+), ?([.0-9]+)\)$/);
          const list = matches.map(v => parseFloat(v, 10)).slice(1);
          this.rgbColor = {
            r: list[0],
            g: list[1],
            b: list[2],
            a: list[3]
          };
        } else {
          this.rgbColor = {
            ...this.color.toRgb()
          };
        }
        const hslColorData = [...this.color.toHsl()];
        this.hslColor = this.showAlpha ? this.color.toHsla() : {
          h: Number(hslColorData[0]).toFixed(0),
          s: Number(hslColorData[1] * 100).toFixed(0) + '%',
          l: Number(hslColorData[2] * 100).toFixed(0) + '%'
        };
        this.newColor = val.value;
      }
    },
    hexColor(val, oldvalue) {
      if (val !== oldvalue && this.editColor === 'hex') {
        if (this.validHex(val)) {
          this.color.fromString('#' + val);
        }
      }
    },
    cacheRgbColor: {
      handler(color, oldvalue) {
        if (JSON.stringify(color) !== JSON.stringify(oldvalue) && this.editColor === 'rgb') {
          if (this.validRgbColor(color)) {
            this.color.fromString(`rgb(${color.r},${color.g},${color.b},${color.a})`);
          }
        }
      },
      deep: true
    },
    cacheHslColor: {
      handler(color, oldvalue) {
        if (oldvalue.h === '' && oldvalue.l === '' && oldvalue.a === '') return;
        if (JSON.stringify(color) !== JSON.stringify(oldvalue) && this.editColor === 'hsl') {
          if (this.validHslColor(color)) {
            this.color.fromString(`hsl(${color.h},${color.s},${color.l},${color.a})`);
          }
        }
      },
      deep: true
    }
  },
  methods: {
    inputRgb() {
      this.editColor = 'rgb';
      // 重新控制变量的值
      let {
        r,
        g,
        b
      } = this.rgbColor;
      r = parseInt(r, 10);
      g = parseInt(g, 10);
      b = parseInt(b, 10);
      this.rgbColor.r = isNaN(r) ? 0 : Math.min(Math.max(r, 0), 255);
      this.rgbColor.g = isNaN(g) ? 0 : Math.min(Math.max(g, 0), 255);
      this.rgbColor.b = isNaN(b) ? 0 : Math.min(Math.max(b, 0), 255);
    },
    inputHsl() {
      this.editColor = 'hsl';
      // 重新控制变量的值
      let {
        h,
        s,
        l
      } = this.hslColor;
      h = parseInt(h, 10);
      s = parseInt(s, 10);
      l = parseInt(l, 10);
      this.hslColor.h = isNaN(h) ? 0 : Math.min(Math.max(h, 0), 360);
      this.hslColor.s = isNaN(s) ? '0%' : Math.min(Math.max(s, 0), 100) + '%';
      this.hslColor.l = isNaN(l) ? '0%' : Math.min(Math.max(l, 0), 100) + '%';
    },
    inputHex() {
      this.editColor = 'hex';
      if (!this.validHex(this.hexColor)) {
        this.hexColor = this.showAlpha ? this.color.rgbToHex().split('#')[1] : this.color.value.split('#')[1];
      }
    },
    clearEditColor() {
      this.editColor = '';
    },
    confirmValue() {
      this.$emit('selectColor', this.color);
    },
    validHex(color) {
      return /^[A-Fa-f0-9]{6}$/.test(color);
    },
    validRgbColor(color) {
      const {
        r,
        g,
        b,
        a
      } = color;
      let newArr = [r, g, b];
      const numReg = /^(0|[1-9]\d*)$/;
      const aReg = /^(0\.[0-9]{0,2}|0|1)$/;
      if (newArr.some(item => !numReg.test(item))) return false;
      newArr = newArr.map(item => parseInt(item, 10));
      if (newArr.some(v => v < 0 || v > 255)) return false;
      if (this.showAlpha && (!aReg.test(a) || /\.$/.test(a))) return false;
      return true;
    },
    validHslColor(color) {
      const {
        h,
        s,
        l,
        a
      } = color;
      const numReg = /^(0|[1-9]\d*)%$/;
      const aReg = /^(0\.[0-9]{0,2}|0|1)$/; // /^(0\.[0-9]{0,2}|0|1)$/
      let slArr = [s, l];
      if (slArr.some(item => !numReg.test(item))) return false; // sl 都为百分数
      if (!/^(0|[1-9]\d*)$/.test(h) || /^(0|[1-9]\d*)$/.test(h) && parseInt(h, 10) > 360) return false; // h 没有百分数
      slArr = slArr.map(v => v.split('%')[0]).map(v => parseInt(v, 10));
      if (slArr.some(v => v < 0 || v > 100)) return false;
      if (this.showAlpha && (!aReg.test(a) || /\.$/.test(a))) return false;
      return true;
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/color-details.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_color_detailsvue_type_script_lang_js_ = (color_detailsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/color-details.vue





/* normalize component */

var color_details_component = normalizeComponent(
  components_color_detailsvue_type_script_lang_js_,
  color_detailsvue_type_template_id_e5ed9e0a_render,
  color_detailsvue_type_template_id_e5ed9e0a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var color_details = (color_details_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/components/picker-dropdown.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








/* harmony default export */ var picker_dropdownvue_type_script_lang_js_ = ({
  name: 'ElColorPickerDropdown',
  components: {
    SvPanel: sv_panel,
    HueSlider: hue_slider,
    ColorDetails: color_details,
    SimplePanel: simple_panel,
    AlphaSlider: alpha_slider
  },
  mixins: [vue_popper, locale],
  props: {
    color: {
      type: null,
      default: null,
      required: true
    },
    showAlpha: {
      type: Boolean,
      default: null
    },
    isSimple: {
      type: Boolean,
      default: true
    },
    colorList: {
      type: Array,
      default: null
    },
    currentColor: {
      type: String,
      default: ''
    },
    inputWidth: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      customInput: ''
    };
  },
  watch: {
    showPopper(val) {
      if (val === true) {
        this.$nextTick(() => {
          const {
            sl,
            hue,
            alpha
          } = this.$refs;
          sl && sl.update();
          hue && hue.update();
          alpha && alpha.update();
        });
      }
    }
  },
  mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$el;
  },
  methods: {
    confirmValue() {
      this.$emit('pick');
    },
    handleConfirm() {
      const valid = this.showAlpha ? this.validRGBA(this.customInput) : this.validRGBHex(this.customInput);
      if (valid) {
        this.color.fromString(this.customInput);
      } else {
        this.customInput = this.currentColor;
      }
    },
    validRGBHex(color) {
      return /^#[A-Fa-f0-9]{6}$/.test(color);
    },
    validRGBA(color) {
      const matches = color.match(/^rgba\((\d+), ?(\d+), ?(\d+), ?([.0-9]+)\)$/);
      if (!matches) return false;
      const list = matches.map(v => parseInt(v, 10)).slice(1);
      if (list.some(v => isNaN(v))) return false;
      const [r, g, b, a] = list;
      if ([r, g, b].some(v => v < 0 || v > 255) || a < 0 || a > 1) return false;
      return true;
    },
    selectSimpleColor(color) {
      this.$emit('selectSimpleColor', color);
    },
    selectColor(color) {
      this.$emit('selectColor', color);
    },
    clearEditColor() {
      this.$refs.details.clearEditColor();
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_picker_dropdownvue_type_script_lang_js_ = (picker_dropdownvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/components/picker-dropdown.vue





/* normalize component */

var picker_dropdown_component = normalizeComponent(
  components_picker_dropdownvue_type_script_lang_js_,
  picker_dropdownvue_type_template_id_7ca48617_render,
  picker_dropdownvue_type_template_id_7ca48617_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var picker_dropdown = (picker_dropdown_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/color-picker/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var color_picker_src_mainvue_type_script_lang_js_ = ({
  name: 'HColorPicker',
  directives: {
    Clickoutside: clickoutside
  },
  components: {
    PickerDropdown: picker_dropdown,
    ElInput: packages_input
  },
  props: {
    value: {
      type: String,
      default: ''
    },
    showAlpha: {
      type: Boolean,
      default: false
    },
    colorFormat: {
      type: String,
      default: null
    },
    showColorText: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    defaultColor: {
      type: String,
      default: ''
    },
    placeholder: {
      type: String,
      default: ''
    },
    colorList: {
      type: Array,
      default: () => {
        return ['#f30303', '#e92656', '#960fa3', '#3f40a9', '#2c84ee', '#00b2cd', '#008b7e', '#36a751', '#79be4d', '#c2da46', '#fdeb4a', '#ff911b'];
      }
    },
    isSimple: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: 'bottom-start'
    }
  },
  data() {
    const color = new color_Color({
      enableAlpha: this.showAlpha,
      format: this.colorFormat
    });
    return {
      color,
      showPicker: false,
      showPanelColor: false,
      inputWidth: ''
    };
  },
  computed: {
    displayedColor() {
      if (!this.value && !this.showPanelColor) {
        return 'transparent';
      } else {
        const {
          r,
          g,
          b
        } = this.color.toRgb();
        return this.showAlpha ? `rgba(${r}, ${g}, ${b}, ${this.color.get('alpha') / 100})` : `rgb(${r}, ${g}, ${b})`;
      }
    },
    inputValue() {
      if (this.showColorText) {
        return this.value;
      }
      return '';
    },
    innerStyle() {
      if (this.defaultColor) {
        return {
          background: this.defaultColor
        };
      } else {
        return '';
      }
    },
    inputPlaceholder() {
      // 当有绑定值或缺省值时，不展示placeholder
      return this.value || this.defaultColor ? '' : this.placeholder;
    }
  },
  watch: {
    value(val) {
      if (!val && this.defaultColor !== 'transparent' && this.defaultColor !== '') {
        // 没有输入颜色 且defaultColor不为透明与空字符串时，将颜色设置为缺省颜色
        this.color.fromString(this.defaultColor);
        this.setInputColor();
      } else if (!val && (this.defaultColor === 'transparent' || this.defaultColor === '')) {
        // 没有输入颜色 且defaultColor不为透明与空字符串时，直接设置背景色为 transparent
        this.$refs.inputColor.$el.style.background = 'transparent';
        this.showPanelColor = false;
      } else if (val && val !== this.color.value) {
        this.color.fromString(val);
        this.setInputColor();
      }
    },
    color: {
      deep: true,
      handler() {
        this.showPanelColor = true;
      }
    },
    displayedColor(val) {
      this.$emit('active-change', val);
    },
    showPicker(val) {
      if (val) {
        this.inputWidth = this.$refs.inputColor.$el.getBoundingClientRect().width + 'px';
      }
    }
  },
  mounted() {
    const value = this.value;
    if (value) {
      this.color.fromString(value);
      this.setInputColor();
    } else if (this.defaultColor === '' || this.defaultColor === 'transparent') {
      // 当没有输入颜色，且缺省颜色为 '' 或则 'transparent' 时，直接将背景色设置为透明
      this.color.fromString('#ffffff');
      this.$refs.inputColor.$el.style.background = 'transparent';
    } else if (this.defaultColor) {
      // 当没有输入颜色，但有缺省颜色时，设置缺省色为当前颜色
      this.color.fromString(this.defaultColor);
      this.setInputColor();
    } else {
      this.color.fromString('#ffffff');
      this.setInputColor();
    }
  },
  methods: {
    switchShow() {
      if (!this.disabled) {
        this.showPicker = !this.showPicker;
      }
    },
    confirmValue() {
      this.$emit('input', this.color.value);
      this.$emit('change', this.color.value);
      this.showPicker = false;
    },
    hide() {
      this.showPicker = false;
      this.resetColor();
    },
    resetColor() {
      this.$nextTick(() => {
        if (this.value) {
          this.color.fromString(this.value);
        } else {
          this.showPanelColor = false;
        }
      });
    },
    selectColor(color) {
      this.setInputColor();
      const outputColor = this.getOutputColor(color);
      this.showPicker = false;
      this.$emit('input', outputColor);
      this.$emit('change', outputColor);
    },
    judgeColorIsLight(rgb) {
      return 0.213 * rgb.r + 0.715 * rgb.g + 0.072 * rgb.b > 255 / 2;
    },
    setInputColor() {
      const rgbColor = this.color.toRgb();
      const islight = this.judgeColorIsLight(rgbColor);
      this.$refs.inputColor.$el.children[0].style.color = islight ? '#000' : '#fff';
      this.$refs.inputColor.$el.children[0].style.background = this.color.value;
    },
    getOutputColor(color) {
      // 需求：当rgba场景下，当透明度为1时，控制输出的颜色格式
      let outputColor = null;
      if (this.isSimple) {
        outputColor = color;
      } else {
        if (this.showAlpha && this.color._alpha === 100) {
          outputColor = this.color.rgbToHex();
        } else {
          outputColor = color.value;
        }
      }
      return outputColor;
    }
  }
});
// CONCATENATED MODULE: ./packages/color-picker/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_color_picker_src_mainvue_type_script_lang_js_ = (color_picker_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/color-picker/src/main.vue





/* normalize component */

var color_picker_src_main_component = normalizeComponent(
  packages_color_picker_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_33b06286_render,
  mainvue_type_template_id_33b06286_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var color_picker_src_main = (color_picker_src_main_component.exports);
// CONCATENATED MODULE: ./packages/color-picker/index.js


/* istanbul ignore next */
color_picker_src_main.install = function (Vue) {
  Vue.component(color_picker_src_main.name, color_picker_src_main);
};
/* harmony default export */ var color_picker = (color_picker_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/main.vue?vue&type=template&id=52867b1e&
var mainvue_type_template_id_52867b1e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-transfer"},[_c('transfer-panel',_vm._b({ref:"leftPanel",attrs:{"data":_vm.sourceData,"title":_vm.titles[0] || _vm.t('el.transfer.titles.0'),"default-checked":_vm.leftDefaultChecked,"panel-at":"left"},on:{"checked-change":_vm.onSourceCheckedChange}},'transfer-panel',_vm.$props,false),[_vm._t("left-footer")],2),_c('div',{staticClass:"el-transfer__buttons"},[_c('el-button',{staticClass:"el-transfer__button",attrs:{"disabled":_vm.leftChecked.length === 0},nativeOn:{"click":function($event){return _vm.addToRight.apply(null, arguments)}}},[(_vm.buttonTexts[1] !== undefined)?_c('span',[_vm._v(" "+_vm._s(_vm.buttonTexts[1])+" ")]):_vm._e(),_c('i',{staticClass:"h-icon-angle_right"})]),_c('el-button',{staticClass:"el-transfer__button",attrs:{"disabled":_vm.rightChecked.length === 0},nativeOn:{"click":function($event){return _vm.addToLeft.apply(null, arguments)}}},[_c('i',{staticClass:"h-icon-angle_left"}),(_vm.buttonTexts[0] !== undefined)?_c('span',[_vm._v(" "+_vm._s(_vm.buttonTexts[0])+" ")]):_vm._e()])],1),_c('transfer-panel',_vm._b({ref:"rightPanel",attrs:{"data":_vm.targetData,"title":_vm.titles[1] || _vm.t('el.transfer.titles.1'),"default-checked":_vm.rightDefaultChecked,"panel-at":"right"},on:{"checked-change":_vm.onTargetCheckedChange}},'transfer-panel',_vm.$props,false),[_vm._t("right-footer")],2)],1)}
var mainvue_type_template_id_52867b1e_staticRenderFns = []


// CONCATENATED MODULE: ./packages/transfer/src/main.vue?vue&type=template&id=52867b1e&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/transfer-panel.vue?vue&type=template&id=9ff040fc&
var transfer_panelvue_type_template_id_9ff040fc_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-transfer-panel"},[_c('p',{staticClass:"el-transfer-panel__header"},[_vm._v(" "+_vm._s(_vm.title)+" ")]),_c('div',{class:[
      'el-transfer-panel__body',
      !_vm.isShowFooter ? 'no-footer' : 'is-with-footer',
      _vm.filterable ? 'is-filterable' : ''
    ]},[(_vm.filterable && !_vm.isSearch)?_c('el-input',{staticClass:"el-transfer-panel__filter",attrs:{"placeholder":_vm.placeholder,"icon":_vm.inputIcon,"size":"small"},on:{"click":_vm.clearQuery},nativeOn:{"mouseenter":function($event){_vm.inputHover = true},"mouseleave":function($event){_vm.inputHover = false}},model:{value:(_vm.query),callback:function ($$v) {_vm.query=$$v},expression:"query"}}):(_vm.isSearch)?_c('el-input',{staticClass:"el-transfer-panel__filter",attrs:{"placeholder":_vm.placeholder,"icon":_vm.inputIcon,"size":"small"},on:{"click":_vm.clearQuery},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.searchMethod(_vm.searchQuery)},"mouseenter":function($event){_vm.inputHover = true},"mouseleave":function($event){_vm.inputHover = false}},model:{value:(_vm.searchQuery),callback:function ($$v) {_vm.searchQuery=$$v},expression:"searchQuery"}}):_vm._e(),_c('el-scrollbar',{directives:[{name:"show",rawName:"v-show",value:(_vm.data.length > 0),expression:"data.length > 0"}],attrs:{"wrap-class":_vm.filterable
          ? 'el-transfer-scrollbar-filterable__wrap'
          : 'el-transfer-scrollbar__wrap',"view-class":"el-transfer-scrollbar__view","is-small":""},on:{"on-scrolling":_vm.onScrolling}},[_c('el-checkbox-group',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hasNoMatch && _vm.data.length > 0),expression:"!hasNoMatch && data.length > 0"}],staticClass:"el-transfer-panel__list",class:{
          'is-filterable': _vm.filterable
        },model:{value:(_vm.checked),callback:function ($$v) {_vm.checked=$$v},expression:"checked"}},_vm._l((_vm.filteredData),function(item){return _c('el-checkbox',{key:item[_vm.keyProp],staticClass:"el-transfer-panel__item",attrs:{"label":item[_vm.keyProp],"disabled":item[_vm.disabledProp]}},[_c('option-content',{attrs:{"option":item}})],1)}),1)],1),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasNoMatch),expression:"hasNoMatch"}],staticClass:"el-transfer-panel__empty"},[_vm._v(" "+_vm._s(_vm.t('el.transfer.noMatch'))+" ")]),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.data.length === 0 && !_vm.hasNoMatch),expression:"data.length === 0 && !hasNoMatch"}],staticClass:"el-transfer-panel__empty"},[_vm._v(" "+_vm._s(_vm.t('el.transfer.noData'))+" ")])],1),(_vm.isShowFooter)?_c('p',{staticClass:"el-transfer-panel__footer"},[_c('el-checkbox',{attrs:{"indeterminate":_vm.isIndeterminate},on:{"change":_vm.handleAllCheckedChange},model:{value:(_vm.allChecked),callback:function ($$v) {_vm.allChecked=$$v},expression:"allChecked"}},[_vm._v(" "+_vm._s(_vm.checkedSummary)+" ")]),_vm._t("default")],2):_vm._e()])}
var transfer_panelvue_type_template_id_9ff040fc_staticRenderFns = []


// CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue?vue&type=template&id=9ff040fc&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/transfer-panel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ var transfer_panelvue_type_script_lang_js_ = ({
  name: 'ElTransferPanel',
  components: {
    ElCheckboxGroup: packages_checkbox_group,
    ElCheckbox: packages_checkbox,
    ElInput: packages_input,
    ElScrollbar: scrollbar,
    OptionContent: {
      props: {
        option: Object
      },
      render(h) {
        const getParent = vm => {
          if (vm.$options.componentName === 'ElTransferPanel') {
            return vm;
          } else if (vm.$parent) {
            return getParent(vm.$parent);
          } else {
            return vm;
          }
        };
        const parent = getParent(this);
        return parent.renderContent ? parent.renderContent(h, this.option) : h("span", [this.option[parent.labelProp] || this.option[parent.keyProp]]);
      }
    }
  },
  mixins: [locale],
  componentName: 'ElTransferPanel',
  props: {
    data: {
      type: Array,
      default() {
        return [];
      }
    },
    renderContent: {
      type: Function,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    filterable: {
      type: Boolean,
      default: null
    },
    filterPlaceholder: {
      type: String,
      default: ''
    },
    footerFormat: {
      type: [Object, Boolean],
      default: null
    },
    filterMethod: {
      type: Function,
      default: null
    },
    defaultChecked: {
      type: Array,
      default: null
    },
    props: {
      type: Object,
      default: null
    },
    panelAt: {
      type: String,
      default: null
    },
    searchPlaceholder: {
      type: String,
      default: ''
    },
    searchMethod: {
      type: Function,
      default: null
    }
  },
  data() {
    return {
      checked: [],
      allChecked: false,
      query: '',
      inputHover: false,
      searchQuery: ''
    };
  },
  computed: {
    filteredData() {
      return this.data.filter(item => {
        if (typeof this.filterMethod === 'function') {
          return this.filterMethod(this.query, item);
        } else {
          const label = item[this.labelProp] || item[this.keyProp].toString();
          return label.toLowerCase().indexOf(this.query.toLowerCase()) > -1;
        }
      });
    },
    checkableData() {
      return this.filteredData.filter(item => !item[this.disabledProp]);
    },
    checkedSummary() {
      if (this.footerFormat === false) return '';
      const checkedLength = this.checked.length;
      const dataLength = this.data.length;
      const {
        noChecked,
        hasChecked
      } = this.footerFormat;
      if (noChecked && hasChecked) {
        return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength).replace(/\${total}/g, dataLength) : noChecked.replace(/\${total}/g, dataLength);
      } else {
        return checkedLength > 0 ? this.t('el.transfer.hasCheckedFormat', {
          total: dataLength,
          checked: checkedLength
        }) : this.t('el.transfer.noCheckedFormat', {
          total: dataLength
        });
      }
    },
    isIndeterminate() {
      const checkedLength = this.checked.length;
      return checkedLength > 0 && checkedLength < this.checkableData.length;
    },
    hasNoMatch() {
      return this.query.length > 0 && this.filteredData.length === 0;
    },
    inputIcon() {
      return this.query.length > 0 && this.inputHover ? 'h-icon-close_f' : 'h-icon-search';
    },
    labelProp() {
      return this.props.label || 'label';
    },
    keyProp() {
      return this.props.key || 'key';
    },
    disabledProp() {
      return this.props.disabled || 'disabled';
    },
    isSearch() {
      return this.panelAt === 'left' && typeof this.searchMethod === 'function';
    },
    isShowFooter() {
      return this.footerFormat !== false;
    },
    placeholder() {
      const {
        filterPlaceholder,
        filterable,
        searchPlaceholder,
        isSearch,
        t
      } = this;
      if (filterable && !isSearch) {
        return filterPlaceholder || t('el.transfer.filterPlaceholder');
      } else if (isSearch) {
        return searchPlaceholder || t('el.transfer.filterPlaceholder');
      } else {
        return '';
      }
    }
  },
  watch: {
    checked(val) {
      this.updateAllChecked();
      this.$emit('checked-change', val);
    },
    data() {
      const checked = [];
      const filteredDataKeys = this.filteredData.map(item => item[this.keyProp]);
      this.checked.forEach(item => {
        if (filteredDataKeys.indexOf(item) > -1) {
          checked.push(item);
        }
      });
      this.checked = checked;
    },
    checkableData() {
      this.updateAllChecked();
    },
    defaultChecked: {
      immediate: true,
      handler(val, oldVal) {
        if (oldVal && val.length === oldVal.length && val.every(item => oldVal.indexOf(item) > -1)) {
          return;
        }
        const checked = [];
        const checkableDataKeys = this.checkableData.map(item => item[this.keyProp]);
        val.forEach(item => {
          if (checkableDataKeys.indexOf(item) > -1) {
            checked.push(item);
          }
        });
        this.checked = checked;
      }
    }
  },
  methods: {
    updateAllChecked() {
      const checkableDataKeys = this.checkableData.map(item => item[this.keyProp]);
      this.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every(item => this.checked.indexOf(item) > -1);
    },
    handleAllCheckedChange(value) {
      this.checked = value ? this.checkableData.map(item => item[this.keyProp]) : [];
    },
    clearQuery() {
      const {
        searchMethod,
        searchQuery,
        isSearch
      } = this;
      if (this.inputIcon === 'h-icon-close_f') {
        if (isSearch) {
          this.searchQuery = '';
        } else {
          this.query = '';
        }
      } else if (isSearch) {
        searchMethod(searchQuery);
      }
    },
    onScrolling(s) {
      const {
        scrollTop,
        percentY
      } = s;
      this.$parent.$emit(`on-${this.panelAt}-scrolling`, {
        scrollTop,
        percentY
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_transfer_panelvue_type_script_lang_js_ = (transfer_panelvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/transfer/src/transfer-panel.vue





/* normalize component */

var transfer_panel_component = normalizeComponent(
  src_transfer_panelvue_type_script_lang_js_,
  transfer_panelvue_type_template_id_9ff040fc_render,
  transfer_panelvue_type_template_id_9ff040fc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var transfer_panel = (transfer_panel_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/transfer/src/main.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var transfer_src_mainvue_type_script_lang_js_ = ({
  name: 'ElTransfer',
  components: {
    TransferPanel: transfer_panel,
    ElButton: packages_button
  },
  mixins: [emitter, locale],
  props: {
    data: {
      type: Array,
      default() {
        return [];
      }
    },
    titles: {
      type: Array,
      default() {
        return [];
      }
    },
    buttonTexts: {
      type: Array,
      default() {
        return [];
      }
    },
    filterPlaceholder: {
      type: String,
      default: ''
    },
    filterMethod: {
      type: Function,
      default: null
    },
    leftDefaultChecked: {
      type: Array,
      default() {
        return [];
      }
    },
    rightDefaultChecked: {
      type: Array,
      default() {
        return [];
      }
    },
    renderContent: {
      type: Function,
      default: null
    },
    value: {
      type: Array,
      default() {
        return [];
      }
    },
    footerFormat: {
      type: [Object, Boolean],
      default() {
        return {};
      }
    },
    filterable: {
      type: Boolean,
      default: null
    },
    props: {
      type: Object,
      default() {
        return {
          label: 'label',
          key: 'key',
          disabled: 'disabled'
        };
      }
    },
    searchPlaceholder: {
      type: String,
      default: ''
    },
    searchMethod: {
      type: Function,
      default: null
    },
    beforeAddToRight: {
      type: Function,
      default: () => new Promise(resolve => resolve())
    },
    beforeAddToLeft: {
      type: Function,
      default: () => new Promise(resolve => resolve())
    }
  },
  data() {
    return {
      leftChecked: [],
      rightChecked: []
    };
  },
  computed: {
    sourceData() {
      return this.data.filter(item => this.value.indexOf(item[this.props.key]) === -1);
    },
    targetData() {
      return this.data.filter(item => this.value.indexOf(item[this.props.key]) > -1);
    }
  },
  watch: {
    value(val) {
      this.dispatch('ElFormItem', 'el.form.change', val);
    }
  },
  methods: {
    onSourceCheckedChange(val) {
      this.leftChecked = val;
    },
    onTargetCheckedChange(val) {
      this.rightChecked = val;
    },
    addToLeft() {
      this.beforeAddToLeft().then(() => {
        const currentValue = this.value.slice();
        this.rightChecked.forEach(item => {
          const index = currentValue.indexOf(item);
          if (index > -1) {
            currentValue.splice(index, 1);
          }
        });
        this.$emit('input', currentValue);
        this.$emit('change', currentValue, 'left', this.rightChecked);
      }).catch(() => {});
    },
    addToRight() {
      this.beforeAddToRight().then(() => {
        let currentValue = this.value.slice();
        this.leftChecked.forEach(item => {
          if (this.value.indexOf(item) === -1) {
            currentValue = currentValue.concat(item);
          }
        });
        this.$emit('input', currentValue);
        this.$emit('change', currentValue, 'right', this.leftChecked);
      }).catch(() => {});
    },
    clearQuery(which) {
      if (which === 'left') {
        this.$refs.leftPanel.query = '';
      } else if (which === 'right') {
        this.$refs.rightPanel.query = '';
      } else if (which === undefined) {
        this.$refs.leftPanel.query = '';
        this.$refs.rightPanel.query = '';
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/transfer/src/main.vue?vue&type=script&lang=js&
 /* harmony default export */ var packages_transfer_src_mainvue_type_script_lang_js_ = (transfer_src_mainvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/transfer/src/main.vue





/* normalize component */

var transfer_src_main_component = normalizeComponent(
  packages_transfer_src_mainvue_type_script_lang_js_,
  mainvue_type_template_id_52867b1e_render,
  mainvue_type_template_id_52867b1e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var transfer_src_main = (transfer_src_main_component.exports);
// CONCATENATED MODULE: ./packages/transfer/index.js


/* istanbul ignore next */
transfer_src_main.install = function (Vue) {
  Vue.component(transfer_src_main.name, transfer_src_main);
};
/* harmony default export */ var transfer = (transfer_src_main);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/affix/src/affix.vue?vue&type=template&id=916cbf54&
var affixvue_type_template_id_916cbf54_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{ref:"point",class:{ 'h-affix': _vm.affix },style:(_vm.styles)},[_vm._t("default")],2),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.slot),expression:"slot"}],style:(_vm.slotStyle)})])}
var affixvue_type_template_id_916cbf54_staticRenderFns = []


// CONCATENATED MODULE: ./packages/affix/src/affix.vue?vue&type=template&id=916cbf54&

// CONCATENATED MODULE: ./packages/affix/src/util.js
const src_util_getScroll = (target, top) => {
  const prop = top ? 'pageYOffset' : 'pageXOffset';
  const method = top ? 'scrollTop' : 'scrollLeft';
  let ret = target[prop];
  if (typeof ret !== 'number') {
    ret = target ? target[method] : window.document.documentElement[method];
  }
  return ret;
};
const affix_src_util_getOffset = (element, target) => {
  const rect = element.getBoundingClientRect();
  const targetTop = target && target.getBoundingClientRect ? target.getBoundingClientRect().top : 0;
  const scrollTop = src_util_getScroll(target || window, true);
  const scrollLeft = src_util_getScroll(target || window);
  const docEl = window.document.body;
  const clientTop = docEl.clientTop || 0;
  const clientLeft = docEl.clientLeft || 0;
  return {
    top: rect.top + scrollTop - clientTop - targetTop,
    left: rect.left + scrollLeft - clientLeft
  };
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/affix/src/affix.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//



/* harmony default export */ var affixvue_type_script_lang_js_ = ({
  name: 'HAffix',
  props: {
    offsetTop: {
      type: Number,
      default: 0
    },
    offsetBottom: {
      type: Number,
      default: -1
    },
    slotWidth: {
      type: Number,
      default: undefined
    },
    slotHeight: {
      type: Number,
      default: undefined
    },
    container: {
      type: [String, Object],
      default: ''
    }
  },
  data() {
    return {
      affix: false,
      styles: {},
      slot: false,
      slotStyle: {}
    };
  },
  computed: {
    offsetType() {
      let type = 'top';
      if (this.offsetBottom >= 0) {
        type = 'bottom';
      }
      return type;
    },
    scrollContainer() {
      return this.container ? typeof this.container === 'string' ? document.querySelector(this.container) : this.container : window;
    }
  },
  mounted() {
    this.handleScroll();
    on(this.scrollContainer, 'scroll', this.handleScroll);
    on(this.scrollContainer, 'resize', this.handleScroll);
    if (this.scrollContainer !== window) {
      on(window, 'resize', this.handleScroll);
      on(window, 'scroll', this.handleScroll);
    }
  },
  beforeDestroy() {
    off(this.scrollContainer, 'scroll', this.handleScroll);
    off(this.scrollContainer, 'resize', this.handleScroll);
    if (this.scrollContainer !== window) {
      off(window, 'resize', this.handleScroll);
      off(window, 'scroll', this.handleScroll);
    }
  },
  methods: {
    /**
     * @desc 响应滚动条滚动事件
     * @author chenguanbin
     */
    handleScroll() {
      const affix = this.affix;
      const scrollTop = src_util_getScroll(this.scrollContainer, true);
      const elOffset = affix_src_util_getOffset(this.$el, this.scrollContainer);
      const windowHeight = this.container ? this.scrollContainer.offsetHeight : window.innerHeight;
      const elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight;
      const containerTop = this.scrollContainer.getBoundingClientRect ? this.scrollContainer.getBoundingClientRect().top : 0;
      // Fixed Top
      if (elOffset.top - this.offsetTop < scrollTop && this.offsetType === 'top' && !affix) {
        this.affix = true;
        this.slotStyle = {
          width: `${this.slotWidth || this.$refs.point.clientWidth}px`,
          height: `${this.slotHeight || this.$refs.point.clientHeight}px`
        };
        this.slot = true;
        this.styles = {
          top: `${this.offsetTop + containerTop}px`,
          left: `${elOffset.left}px`,
          width: `${this.$el.offsetWidth}px`
        };
        this.$emit('on-change', true);
      } else if (elOffset.top - this.offsetTop > scrollTop && this.offsetType === 'top' && affix) {
        this.slotStyle = {};
        this.affix = false;
        this.slot = false;
        this.styles = null;
        this.$emit('on-change', false);
      } else if (this.offsetType === 'top' && affix) {
        this.slotStyle = {
          width: `${this.slotWidth || this.$refs.point.clientWidth}px`,
          height: `${this.slotHeight || this.$refs.point.clientHeight}px`
        };
        this.styles = {
          top: `${this.offsetTop + containerTop}px`,
          left: `${elOffset.left}px`,
          width: `${this.$el.offsetWidth}px`
        };
      }

      // Fixed Bottom
      const containerHeight = window.innerHeight - windowHeight - containerTop;
      if (elOffset.top + this.offsetBottom + elHeight > scrollTop + windowHeight && this.offsetType === 'bottom' && !affix) {
        this.affix = true;
        this.slotStyle = {
          width: `${this.slotWidth || this.$refs.point.clientWidth}px`,
          height: `${this.slotHeight || this.$refs.point.clientHeight}px`
        };
        this.slot = true;
        this.styles = {
          bottom: `${this.offsetBottom + containerHeight}px`,
          left: `${elOffset.left}px`,
          width: `${this.$el.offsetWidth}px`
        };
        this.$emit('on-change', true);
      } else if (elOffset.top + this.offsetBottom + elHeight < scrollTop + windowHeight && this.offsetType === 'bottom' && affix) {
        this.slot = false;
        this.affix = false;
        this.styles = null;
        this.$emit('on-change', false);
      } else if (this.offsetType === 'bottom' && affix) {
        this.slotStyle = {
          width: `${this.slotWidth || this.$refs.point.clientWidth}px`,
          height: `${this.slotHeight || this.$refs.point.clientHeight}px`
        };
        this.styles = {
          bottom: `${this.offsetBottom + containerHeight}px`,
          left: `${elOffset.left}px`,
          width: `${this.$el.offsetWidth}px`
        };
      }
    },
    updateAffixStyle(affixStyle) {
      if (!this.affix) return;
      const {
        top,
        bottom,
        left,
        width
      } = affixStyle;
      if (top !== undefined) this.styles.top = `${parseInt(top)}px`;
      if (bottom !== undefined) this.styles.bottom = `${parseInt(bottom)}px`;
      if (left !== undefined) this.styles.left = `${parseInt(left)}px`;
      if (width !== undefined) {
        this.styles.width = `${parseInt(width)}px`;
        this.slotStyle.width = `${parseInt(width)}px`;
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/affix/src/affix.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_affixvue_type_script_lang_js_ = (affixvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/affix/src/affix.vue





/* normalize component */

var affix_component = normalizeComponent(
  src_affixvue_type_script_lang_js_,
  affixvue_type_template_id_916cbf54_render,
  affixvue_type_template_id_916cbf54_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_affix = (affix_component.exports);
// CONCATENATED MODULE: ./packages/affix/index.js

src_affix.install = function (Vue) {
  Vue.component(src_affix.name, src_affix);
};
/* harmony default export */ var packages_affix = (src_affix);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/anchor.vue?vue&type=template&id=0d9f26d6&
var anchorvue_type_template_id_0d9f26d6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.wrapperComponent,{ref:"affix",tag:"component",staticStyle:{"text-align":"right"},attrs:{"container":_vm.container,"offset-top":_vm.offsetTop,"offset-bottom":_vm.offsetBottom}},[_c('div',{staticClass:"h-anchor-wrapper",class:{ folded: _vm.folded },style:(_vm.wrapperStyle),on:{"mouseenter":_vm.handleMouseenter,"mouseleave":_vm.handleMouseleave}},[_c(_vm.scrollComponent,{ref:"scrollbar",tag:"component",attrs:{"wrap-class":"el-anchor-scrollbar__wrap","view-class":"el-anchor-scrollbar__view"}},[_c('div',{ref:"anchor",staticClass:"h-anchor",class:{ 'is-folded': _vm.folded && _vm.isFolded }},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.folded || !_vm.isFolded),expression:"!folded || !isFolded"}]},[_vm._t("default"),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.showInk && _vm.inkActived),expression:"showInk && inkActived"}],staticClass:"h-anchor__ink-ball",style:({ top: ((_vm.inkTop + 8) + "px"), left: '15px' })})],2),_c('i',{directives:[{name:"show",rawName:"v-show",value:(_vm.folded && _vm.isFolded),expression:"folded && isFolded"}],staticClass:"h-anchor-icon h-icon-ctrl_anchor"})])])],1)])}
var anchorvue_type_template_id_0d9f26d6_staticRenderFns = []


// CONCATENATED MODULE: ./packages/anchor/src/anchor.vue?vue&type=template&id=0d9f26d6&

// CONCATENATED MODULE: ./packages/anchor/src/util.js
/**
 * @desc 元素滚动到目标位置
 * @author chenguanbin
 * @param {Document} el 滚动元素
 * @param {Number} from 开始位置
 * @param {Number} to 目标位置
 * @param {Number} duration 持续时间
 * @param {Function} endCallback 回调函数
 */
const util_scrollTop = (el, from = 0, to, duration = 500, endCallback) => {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }
  const difference = Math.abs(from - to);
  const step = Math.ceil(difference / duration * 50);
  function scroll(start, end, step) {
    if (start === end) {
      endCallback && endCallback();
      return;
    }
    let d = start + step > end ? end : start + step;
    if (start > end) {
      d = start - step < end ? end : start - step;
    }
    if (el === window) {
      window.scrollTo(d, d);
    } else {
      el.scrollTop = d;
    }
    window.requestAnimationFrame(() => scroll(d, end, step));
  }
  scroll(from, to, step);
};

/**
 * @desc 找到子组件中的目标组件
 * @author chenguanbin
 * @param {Object} context 父组件
 * @param {String} componentName 子组件名称
 */
const util_findComponentsDownward = (context, componentName) => {
  return context.$children.reduce((components, child) => {
    componentName = Array.isArray(componentName) ? componentName : [componentName];
    if (componentName.includes(child.$options.name)) components.push(child);
    const foundChilds = util_findComponentsDownward(child, componentName);
    return components.concat(foundChilds);
  }, []);
};

// 锚点正则
const sharpMatcherRegx = /#([^#]+)$/;
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/anchor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var anchorvue_type_script_lang_js_ = ({
  name: 'HAnchor',
  provide() {
    return {
      anchor: this
    };
  },
  props: {
    affix: {
      /* 固定模式 */
      type: Boolean,
      default: true
    },
    height: {
      type: [Number, String],
      default: ''
    },
    offsetTop: {
      /* 固定模式下，距离窗口顶部达到指定偏移量后触发 */
      type: Number,
      default: 0
    },
    offsetBottom: {
      type: Number,
      default: -1
    } /* 固定模式下，距离窗口底部达到指定偏移量后触发 */,
    bounds: {
      /* 锚点区域边界，单位：px */
      type: Number,
      default: 5
    },
    scrollOffset: {
      /* 点击滚动的额外距离 */
      type: Number,
      default: 0
    },
    container: {
      type: [String, Object],
      default: ''
    } /* 指定滚动的容器 */,
    showInk: {
      /* 是否显示小圆点 */
      type: Boolean,
      default: false
    },
    folded: {
      /* 是否能收起面板 */
      type: Boolean,
      default: false
    },
    foldedScrollTime: {
      /* 滚动停止时，面板收起的延后时间 */
      type: Number,
      default: 1000
    }
  },
  data() {
    return {
      inkActived: false,
      // 小圆点是否处于激活状态
      inkTop: 0,
      // 小圆点top值
      animating: false,
      // 是否正在滚动中
      currentLink: '#',
      // current show link =>  #href -> currentLink = #href
      currentId: '',
      // current show title id =>  #href -> currentId = href
      scrollContainer: null,
      // 绑定滚动事件的对象，默认情况下是 window 对象
      scrollElement: null,
      // 滚动的元素，默认情况下是 document.documentElement || document.body
      titlesOffsetArr: [],
      // 锚点关联元素的位置
      wrapperTop: 0,
      scrollTop: 0,
      isFolded: false,
      isMouseEnter: false,
      timer: null,
      childWidth: null,
      minWidth: 120,
      scrollTimer: null
      // upperFirstTitle: true
    };
  },
  computed: {
    // 固定模式下使用 Affix 图钉控件
    wrapperComponent() {
      return this.affix ? 'h-affix' : 'div';
    },
    // 传入height时，为页面存在滚动条
    scrollComponent() {
      return this.height && !(this.folded && this.isFolded) ? 'el-scrollbar' : 'div';
    },
    // 锚点容器样式
    wrapperStyle() {
      const isFolded = this.folded && this.isFolded;
      const isFoldedStyle = {
        padding: '0',
        'box-shadow': 'none',
        'background-color': 'transparent'
      };
      return Object.assign({
        height: this.height ? `${this.height}px` : 'inherit',
        maxHeight: this.offsetTop ? `calc(100vh - ${this.offsetTop}px)` : '100vh',
        'min-width': `${this.minWidth}px`
      }, isFolded ? isFoldedStyle : {});
    },
    // 判断绑定滚动事件的元素是否是 window
    containerIsWindow() {
      return this.scrollContainer === window;
    }
  },
  watch: {
    $route() {
      this.handleHashChange();
      this.$nextTick(() => {
        this.handleScrollTo();
      });
    },
    container() {
      this.init();
    },
    currentLink(newHref, oldHref) {
      this.$emit('on-change', newHref, oldHref);
    },
    isFolded: {
      handler(val) {
        if (!val) {
          this.$nextTick(() => {
            const offsetWidth = this.$refs.anchor.offsetWidth;
            this.minWidth = offsetWidth > 120 ? offsetWidth : 120;
          });
        }
      },
      immediate: true
    }
  },
  mounted() {
    this.init();
  },
  beforeDestroy() {
    this.removeListener();
  },
  methods: {
    handleMouseenter(e) {
      this.isFolded = false;
      this.isMouseEnter = true;
      this.scrollTop = document.documentElement.scrollTop || document.body.scrollTop || e.target.scrollTop;
      clearTimeout(this.timer);
    },
    handleMouseleave() {
      this.isMouseEnter = false;
      this.isFolded = true;
    },
    /**
     * @desc 滚动容器的滚动事件
     * @author chenguanbin
     * @param {Event} e
     */
    handleScroll(e) {
      if (this.animating) return;
      this.updateTitleOffset();
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop || e.target.scrollTop;
      this.getCurrentScrollAtTitleId(scrollTop);
      if (this.scrollTop !== scrollTop) {
        clearTimeout(this.timer);
        this.isFolded = false;
        this.timer = setTimeout(() => {
          !this.isMouseEnter && (this.isFolded = true);
        }, this.foldedScrollTime);
      }
      this.scrollTop = scrollTop;
    },
    /**
     * @desc 浏览器路径发生变化
     * @author chenguanbin
     */
    handleHashChange() {
      const url = window.location.href;
      const sharpLinkMatch = sharpMatcherRegx.exec(url);
      if (!sharpLinkMatch) return;
      this.currentLink = sharpLinkMatch[0];
      this.currentId = sharpLinkMatch[1];
    },
    /**
     * @desc 滚动到目标锚点
     * @author chenguanbin
     */
    handleScrollTo() {
      const anchor = document.getElementById(this.currentId);
      const currentLinkElementA = document.querySelector(`a[data-href="${this.currentLink}"]`);
      let offset = this.scrollOffset;
      if (currentLinkElementA) {
        offset = parseFloat(currentLinkElementA.getAttribute('data-scroll-offset'));
      }
      if (!anchor) return;
      const offsetTop = getOffset(anchor, this.scrollContainer === window ? null : this.scrollContainer).top - this.wrapperTop - offset;
      this.animating = true;
      util_scrollTop(this.scrollContainer, this.scrollElement.scrollTop, offsetTop, 600, () => {
        this.animating = false;
      });
      this.handleSetInkTop();
    },
    /**
     * @desc 设置小圆点的 top 值
     * @author chenguanbin
     */
    handleSetInkTop() {
      let currentLinkElementA = document.querySelector(`a[data-href="${this.currentLink}"]`);
      if (!currentLinkElementA) {
        const currentChild = this.titlesOffsetArr.find(item => item.active);
        if (!currentChild) {
          this.inkActived = false;
          return;
        } else {
          currentLinkElementA = document.querySelector(`a[data-href="${currentChild.link}"]`);
        }
      }
      this.inkActived = true;
      this.$nextTick(() => {
        const elementATop = getOffset(currentLinkElementA, this.$refs.anchor).top;
        // const top = elementATop < 0 ? this.offsetTop : elementATop;
        // this.inkTop = top;
        this.inkTop = Math.abs(elementATop);
      });
    },
    /**
     * @desc 更新锚点关联元素的位置信息
     * @author chenguanbin
     */
    updateTitleOffset() {
      const links = util_findComponentsDownward(this, ['HAnchorLink', 'HSubanchor']).map(link => {
        return {
          href: link.href,
          active: link.active
        };
      });
      const offsetArr = [];
      for (const link of links) {
        const id = link.href.split('#')[1];
        const titleEle = document.getElementById(id);
        if (titleEle) {
          offsetArr.push({
            link: `#${id}`,
            offset: getOffset(titleEle, this.scrollContainer === window ? null : this.scrollContainer).top - this.scrollElement.offsetTop,
            active: link.active
          });
        }
      }
      this.titlesOffsetArr = offsetArr;
      this.handleSetScroll();
    },
    /**
     * @author xuzilong
     * @desc 设置面板内滚动条的滚动值
     */
    handleSetScroll() {
      if (!this.height) return;
      const currentLinkElementA = document.querySelector(`a[data-href="${this.currentLink}"]`);
      if (!currentLinkElementA) return;
      const offset = getOffset(currentLinkElementA, this.$refs.anchor);

      // 给个防抖，否则面板会不停跳动
      clearTimeout(this.scrollTimer);
      this.scrollTimer = setTimeout(() => {
        this.$refs.scrollbar.setScroll(offset.top);
      }, 100);
    },
    /**
     * @desc 根据滚动距离，判断目前激活的锚点
     * @author chenguanbin
     * @param {Number} scrollTop 滚动距离
     */
    getCurrentScrollAtTitleId(scrollTop) {
      let i = -1;
      const len = this.titlesOffsetArr.length;
      let titleItem = {
        link: '#',
        offset: 0
      };
      scrollTop += this.bounds;
      while (++i < len) {
        const currentEle = this.titlesOffsetArr[i];
        const nextEle = this.titlesOffsetArr[i + 1];
        if (scrollTop >= currentEle.offset && scrollTop < (nextEle && nextEle.offset || Infinity)) {
          titleItem = this.titlesOffsetArr[i];
          break;
        }
      }
      this.currentLink = titleItem.link;
      this.handleSetInkTop();
    },
    /**
     * @desc 获取滚动的对象和元素
     *       默认情况下分别是 window、document.documentElement || document.body，若设置了 container，则两个都是 container
     * @author chenguanbin
     */
    getContainer() {
      this.scrollContainer = this.container ? typeof this.container === 'string' ? document.querySelector(this.container) : this.container : window;
      this.scrollElement = this.container ? this.scrollContainer : document.documentElement || document.body;
    },
    /**
     * @desc 移除事件监听
     * @author chenguanbin
     */
    removeListener() {
      off(this.scrollContainer, 'scroll', this.handleScroll);
      off(window, 'hashchange', this.handleHashChange);
    },
    /**
     * @desc 初始化
     * @author chenguanbin
     */
    init() {
      this.handleHashChange();
      this.$nextTick(() => {
        this.removeListener();
        this.getContainer();
        this.wrapperTop = this.containerIsWindow ? 0 : this.scrollElement.offsetTop;
        this.updateTitleOffset();
        this.handleScrollTo();
        this.handleSetInkTop();
        on(this.scrollContainer, 'scroll', this.handleScroll);
        on(window, 'hashchange', this.handleHashChange);
      });
    }
  }
});
// CONCATENATED MODULE: ./packages/anchor/src/anchor.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_anchorvue_type_script_lang_js_ = (anchorvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/anchor/src/anchor.vue





/* normalize component */

var anchor_component = normalizeComponent(
  src_anchorvue_type_script_lang_js_,
  anchorvue_type_template_id_0d9f26d6_render,
  anchorvue_type_template_id_0d9f26d6_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_anchor = (anchor_component.exports);
// CONCATENATED MODULE: ./packages/anchor/index.js

src_anchor.install = function (Vue) {
  Vue.component(src_anchor.name, src_anchor);
};
/* harmony default export */ var packages_anchor = (src_anchor);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/subanchor.vue?vue&type=template&id=17ec8821&
var subanchorvue_type_template_id_17ec8821_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"h-subanchor",class:{ 'is-expand': _vm.expand }},[_c('div',{staticClass:"h-subanchor-item"},[_c('span',{staticClass:"h-subanchor__point"}),_c('a',{staticClass:"h-subanchor__title",style:({ 'padding-left': ((_vm.level * 16 + 36) + "px") }),attrs:{"href":_vm.href,"data-scroll-offset":_vm.scrollOffset,"data-href":_vm.href,"title":_vm.title}},[_vm._v(" "+_vm._s(_vm.title)+" ")])]),_c('div',{staticClass:"h-subanchor__content"},[_vm._t("default")],2)])}
var subanchorvue_type_template_id_17ec8821_staticRenderFns = []


// CONCATENATED MODULE: ./packages/anchor/src/subanchor.vue?vue&type=template&id=17ec8821&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/subanchor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var subanchorvue_type_script_lang_js_ = ({
  name: 'HSubanchor',
  inject: ['anchor'],
  props: {
    href: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    scrollOffset: {
      type: Number,
      default() {
        return this.anchor.scrollOffset;
      }
    },
    isCurrent: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      level: 0,
      expand: false
    };
  },
  computed: {
    active() {
      return this.href === this.anchor.currentLink || this.anchor.currentLink === '#' && this.isCurrent;
    }
  },
  watch: {
    active(val) {
      this.expand = val;
      this.handleParentAction(this, 'HSubanchor', 'getChildrenActive');
    }
  },
  mounted() {
    this.setAnchorLevel(this, 'HSubanchor');
  },
  methods: {
    setAnchorLevel(context, name) {
      const parent = context.$parent;
      if (parent.$options.name === name) {
        this.level++;
        this.setAnchorLevel(parent, name);
      }
    },
    getChildrenActive() {
      const children = util_findComponentsDownward(this, ['HAnchorLink', 'HSubanchor']);
      this.expand = children.some(item => item.active) || this.anchor.currentLink === this.href;
    },
    handleParentAction(context, name, actionName) {
      const parent = context.$parent;
      if (parent && parent.$options.name === name) {
        parent[actionName]();
      }
      if (parent) {
        this.handleParentAction(parent, name, actionName);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/anchor/src/subanchor.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_subanchorvue_type_script_lang_js_ = (subanchorvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/anchor/src/subanchor.vue





/* normalize component */

var subanchor_component = normalizeComponent(
  src_subanchorvue_type_script_lang_js_,
  subanchorvue_type_template_id_17ec8821_render,
  subanchorvue_type_template_id_17ec8821_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var subanchor = (subanchor_component.exports);
// CONCATENATED MODULE: ./packages/subanchor/index.js

subanchor.install = function (Vue) {
  Vue.component(subanchor.name, subanchor);
};
/* harmony default export */ var packages_subanchor = (subanchor);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/anchor-link.vue?vue&type=template&id=6ab99bb4&
var anchor_linkvue_type_template_id_6ab99bb4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"anchorLink",class:[
    'h-anchor-link',
    _vm.active ? "is-active" : '',
    _vm.hasChildren && 'is-parent'
  ]},[_c('span',{staticClass:"h-anchor-link__point"}),_c('a',{staticClass:"h-anchor-link__title",style:({ 'padding-left': ((_vm.level * 16 + 36) + "px") }),attrs:{"href":_vm.href,"data-scroll-offset":_vm.scrollOffset,"data-href":_vm.href,"title":_vm.title},on:{"click":_vm.goAnchor}},[_vm._v(" "+_vm._s(_vm.title)+" ")]),_vm._t("default")],2)}
var anchor_linkvue_type_template_id_6ab99bb4_staticRenderFns = []


// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.vue?vue&type=template&id=6ab99bb4&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/anchor/src/anchor-link.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var anchor_linkvue_type_script_lang_js_ = ({
  name: 'HAnchorLink',
  inject: ['anchor'],
  props: {
    href: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    scrollOffset: {
      type: Number,
      default() {
        return this.anchor.scrollOffset;
      }
    },
    isCurrent: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      hasChildren: false,
      level: 0,
      width: 0
    };
  },
  computed: {
    active() {
      return this.href === this.anchor.currentLink || this.anchor.currentLink === '#' && this.isCurrent;
    }
  },
  watch: {
    active(val) {
      this.handleParentAction(this, 'HSubanchor', 'getChildrenActive');
    }
  },
  mounted() {
    if (util_findComponentsDownward(this, 'HAnchorLink').length) {
      this.hasChildren = true;
    }
    this.setAnchorLevel(this, 'HSubanchor');
    this.getWidth();
  },
  methods: {
    getWidth() {
      this.width = this.$refs.anchorLink.clientWidth;
    },
    goAnchor() {
      const noChange = this.active;
      this.anchor.$emit('on-select', this.href);
      const isRoute = this.$router;
      if (isRoute) {
        // 不需要引入多余包处理
        const query = this.$route.query;
        const queryParams = new URLSearchParams(query);
        this.$router.replace(this.$route.path + '?' + queryParams + this.href);
      } else {
        const location = window.location;
        window.location.href = location.origin + location.pathname + location.search + this.href;
      }
      if (noChange) {
        this.anchor.handleHashChange();
        this.anchor.handleScrollTo();
      }
    },
    setAnchorLevel(context, name) {
      const parent = context.$parent;
      if (parent.$options.name === name) {
        this.level++;
        this.setAnchorLevel(parent, name);
      }
    },
    setAnchorProp(context, name, prop, val) {
      const parent = context.$parent;
      if (parent && parent.$options.name === name) {
        parent[prop] = val;
      }
      if (parent) {
        this.setAnchorProp(parent, name, prop, val);
      }
    },
    handleParentAction(context, name, actionName) {
      const parent = context.$parent;
      if (parent && parent.$options.name === name) {
        parent[actionName]();
      }
      if (parent) {
        this.handleParentAction(parent, name, actionName);
      }
    }
  }
});
// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_anchor_linkvue_type_script_lang_js_ = (anchor_linkvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.vue





/* normalize component */

var anchor_link_component = normalizeComponent(
  src_anchor_linkvue_type_script_lang_js_,
  anchor_linkvue_type_template_id_6ab99bb4_render,
  anchor_linkvue_type_template_id_6ab99bb4_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var anchor_link = (anchor_link_component.exports);
// CONCATENATED MODULE: ./packages/anchor-link/index.js

anchor_link.install = function (Vue) {
  Vue.component(anchor_link.name, anchor_link);
};
/* harmony default export */ var packages_anchor_link = (anchor_link);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"87b2317e-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-sub-item.vue?vue&type=template&id=3b4e3d14&
var breadcrumb_sub_itemvue_type_template_id_3b4e3d14_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.type === 'dropdown')?_c('el-dropdown-item',{class:[_vm.to ? '' : 'el-breadcrumb__item__unclickable'],attrs:{"command":_vm.to}},[_vm._t("default")],2):_c('el-breadcrumb-item',{attrs:{"to":_vm.to,"separator-class":_vm.separatorClass,"max-width":_vm.maxWidth},on:{"click":_vm.goto}},[_vm._t("default")],2)}
var breadcrumb_sub_itemvue_type_template_id_3b4e3d14_staticRenderFns = []


// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-sub-item.vue?vue&type=template&id=3b4e3d14&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/breadcrumb/src/breadcrumb-sub-item.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var breadcrumb_sub_itemvue_type_script_lang_js_ = ({
  name: 'ElBreadcrumbSubItem',
  props: {
    to: {
      type: null,
      default: null
    },
    separator: {
      type: String,
      default: ''
    },
    separatorClass: {
      type: String,
      default: ''
    },
    replace: {
      type: Boolean,
      default: null
    },
    // 面包屑子项最大宽度
    maxWidth: {
      type: [String, Number],
      default: null
    }
  },
  data() {
    return {
      type: ''
    };
  },
  mounted() {
    this.type = this.$parent.$attrs.type;
  },
  methods: {
    goto() {
      const {
        to,
        $router
      } = this;
      if (!to || !$router) return;
      self.replace ? $router.replace(to) : $router.push(to);
    }
  }
});
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-sub-item.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_breadcrumb_sub_itemvue_type_script_lang_js_ = (breadcrumb_sub_itemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-sub-item.vue





/* normalize component */

var breadcrumb_sub_item_component = normalizeComponent(
  src_breadcrumb_sub_itemvue_type_script_lang_js_,
  breadcrumb_sub_itemvue_type_template_id_3b4e3d14_render,
  breadcrumb_sub_itemvue_type_template_id_3b4e3d14_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var breadcrumb_sub_item = (breadcrumb_sub_item_component.exports);
// CONCATENATED MODULE: ./packages/breadcrumb-subitem/index.js


/* istanbul ignore next */
breadcrumb_sub_item.install = function (Vue) {
  Vue.component(breadcrumb_sub_item.name, breadcrumb_sub_item);
};
/* harmony default export */ var breadcrumb_subitem = (breadcrumb_sub_item);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./packages/config-provider/src/config-provider.vue?vue&type=script&lang=js&
/* harmony default export */ var config_providervue_type_script_lang_js_ = ({
  name: 'ElConfigProvider',
  props: {
    zIndex: {
      type: Number,
      default: 2000
    }
  },
  provide() {
    return {
      configProvider: this
    };
  },
  render() {
    return this.$slots.default ? this.$slots.default[0] : '';
  }
});
// CONCATENATED MODULE: ./packages/config-provider/src/config-provider.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_config_providervue_type_script_lang_js_ = (config_providervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./packages/config-provider/src/config-provider.vue
var config_provider_render, config_provider_staticRenderFns




/* normalize component */

var config_provider_component = normalizeComponent(
  src_config_providervue_type_script_lang_js_,
  config_provider_render,
  config_provider_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var config_provider = (config_provider_component.exports);
// CONCATENATED MODULE: ./packages/config-provider/index.js


/* istanbul ignore next */
config_provider.install = function (Vue) {
  Vue.component(config_provider.name, config_provider);
};
/* harmony default export */ var packages_config_provider = (config_provider);
// EXTERNAL MODULE: ./packages/theme/index.scss
var theme = __webpack_require__("2c81");

// EXTERNAL MODULE: ./package.json
var package_0 = __webpack_require__("9224");

// CONCATENATED MODULE: ./src/index.js



























































// import Rate from '../packages/rate/index.js';





















const components = [packages_pagination, dialog, packages_autocomplete, packages_dropdown, packages_dropdown_menu, packages_dropdown_item, packages_menu, packages_submenu, packages_menu_item, packages_menu_item_group, packages_menu_collapse, packages_input, packages_input_number, packages_ip_input, packages_radio, packages_radio_group, packages_radio_button, packages_checkbox, packages_checkbox_button, packages_checkbox_group, packages_switch, packages_select, packages_option, packages_option_group, packages_button, packages_button_group, packages_table, packages_table_column, h_paged_table, packages_date_picker, packages_time_select, packages_time_picker, popover, packages_tooltip, packages_breadcrumb, packages_breadcrumb_item, packages_form, packages_form_item, packages_tabs, packages_tab_pane, packages_tag, packages_tree, packages_alert, slider, packages_icon, packages_svg_icon, packages_loading_icon, packages_feedback_icon, packages_row, packages_col, packages_upload, packages_progress, packages_spinner, badge, card,
// Rate,
packages_steps, packages_step, carousel, scrollbar, carousel_item, packages_collapse, packages_collapse_item, cascader, color_picker, transfer, collapse_transition, packages_affix, packages_anchor, packages_subanchor, packages_anchor_link, breadcrumb_subitem, packages_config_provider];
const src_install = function (Vue, opts = {}) {
  /* istanbul ignore if */
  if (src_install.installed) return;
  locale_default.a.use(opts.locale);
  locale_default.a.i18n(opts.i18n);
  components.map(component => {
    Vue.component(component.name, component);
  });
  Vue.use(packages_loading.directive);
  Vue.prototype.$loading = packages_loading.service;
  Vue.prototype.$msgbox = message_box;
  Vue.prototype.$alert = message_box.alert;
  Vue.prototype.$confirm = message_box.confirm;
  Vue.prototype.$prompt = message_box.prompt;
  Vue.prototype.$notify = notification;
  Vue.prototype.$message = packages_message;
};

/* istanbul ignore if */
if (typeof window !== 'undefined' && window.Vue) {
  src_install(window.Vue);
}
/* harmony default export */ var src_0 = ({
  version: package_0["a" /* version */],
  locale: locale_default.a.use,
  i18n: locale_default.a.i18n,
  install: src_install,
  CollapseTransition: collapse_transition,
  Loading: packages_loading,
  PopupManager: popup_manager,
  nextZIndex: popup_manager.nextZIndex,
  Pagination: packages_pagination,
  Dialog: dialog,
  Autocomplete: packages_autocomplete,
  Dropdown: packages_dropdown,
  DropdownMenu: packages_dropdown_menu,
  DropdownItem: packages_dropdown_item,
  Menu: packages_menu,
  Submenu: packages_submenu,
  MenuItem: packages_menu_item,
  MenuItemGroup: packages_menu_item_group,
  MenuCollapse: packages_menu_collapse,
  Input: packages_input,
  InputNumber: packages_input_number,
  IpInput: packages_ip_input,
  Radio: packages_radio,
  RadioGroup: packages_radio_group,
  RadioButton: packages_radio_button,
  Checkbox: packages_checkbox,
  CheckboxButton: packages_checkbox_button,
  CheckboxGroup: packages_checkbox_group,
  Switch: packages_switch,
  Select: packages_select,
  Option: packages_option,
  OptionGroup: packages_option_group,
  Button: packages_button,
  ButtonGroup: packages_button_group,
  Table: packages_table,
  TableColumn: packages_table_column,
  HPagedTable: h_paged_table,
  DatePicker: packages_date_picker,
  TimeSelect: packages_time_select,
  TimePicker: packages_time_picker,
  Popover: popover,
  Tooltip: packages_tooltip,
  MessageBox: message_box,
  Breadcrumb: packages_breadcrumb,
  BreadcrumbItem: packages_breadcrumb_item,
  Form: packages_form,
  FormItem: packages_form_item,
  Tabs: packages_tabs,
  TabPane: packages_tab_pane,
  Tag: packages_tag,
  Tree: packages_tree,
  Alert: packages_alert,
  Notification: notification,
  Slider: slider,
  Icon: packages_icon,
  SvgIcon: packages_svg_icon,
  LoadingIcon: packages_loading_icon,
  FeedbackIcon: packages_feedback_icon,
  Row: packages_row,
  Col: packages_col,
  Upload: packages_upload,
  Progress: packages_progress,
  Spinner: packages_spinner,
  Message: packages_message,
  Badge: badge,
  Card: card,
  // Rate,
  Steps: packages_steps,
  Step: packages_step,
  Carousel: carousel,
  Scrollbar: scrollbar,
  CarouselItem: carousel_item,
  Collapse: packages_collapse,
  CollapseItem: packages_collapse_item,
  Cascader: cascader,
  ColorPicker: color_picker,
  Transfer: transfer,
  Affix: packages_affix,
  Anchor: packages_anchor,
  Subanchor: packages_subanchor,
  AnchorLink: packages_anchor_link,
  BreadcrumbSubItem: breadcrumb_subitem
});
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_0);



/***/ })

/******/ })["default"];